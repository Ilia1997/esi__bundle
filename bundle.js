
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value === null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
        return context;
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.48.0' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    const months = [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December",
      ];
    let currentDate = new Date();
      let currentMonthIndex = currentDate.getMonth();
      let paymentMounthIndex = currentMonthIndex + 1;


    const contributionData = writable({
    	period: 'Monthly',
    	currency: 'USD',
        currencySymbol: '$',
        amount: 600,
        monthlyValue: 600,
        nextPaymentDay: 1,
        nextPaymentMonth: months[paymentMounthIndex]
    });

    const allocatedContributions = writable({
        safe: 0,
        safeName: "0 of Total Contribution",
        adventure: 0,
        adventureName: "0 of Total Contribution",
        founder: 0,
        founderName: "0 of Total Contribution",
    });

    /* src\components\contributions\NextPaymentDate.svelte generated by Svelte v3.48.0 */
    const file$y = "src\\components\\contributions\\NextPaymentDate.svelte";

    function create_fragment$y(ctx) {
    	let div;
    	let t0;
    	let span0;
    	let t1_value = /*$contributionData*/ ctx[1].nextPaymentMonth + "";
    	let t1;
    	let t2;
    	let span1;
    	let t3_value = /*$contributionData*/ ctx[1].nextPaymentDay + "";
    	let t3;
    	let t4;
    	let t5;
    	let span2;
    	let t6;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("*The next payment will be on the ");
    			span0 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = text("st");
    			t5 = space();
    			span2 = element("span");
    			t6 = text(/*currentYear*/ ctx[0]);
    			attr_dev(span0, "class", "svelte-1wt9cnr");
    			add_location(span0, file$y, 19, 35, 586);
    			attr_dev(span1, "class", "payment__day svelte-1wt9cnr");
    			add_location(span1, file$y, 21, 4, 646);
    			attr_dev(span2, "class", "currentYear svelte-1wt9cnr");
    			add_location(span2, file$y, 22, 2, 720);
    			attr_dev(div, "class", "next__payment svelte-1wt9cnr");
    			add_location(div, file$y, 18, 0, 522);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			append_dev(div, span1);
    			append_dev(span1, t3);
    			append_dev(span1, t4);
    			append_dev(div, t5);
    			append_dev(div, span2);
    			append_dev(span2, t6);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$contributionData*/ 2 && t1_value !== (t1_value = /*$contributionData*/ ctx[1].nextPaymentMonth + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$contributionData*/ 2 && t3_value !== (t3_value = /*$contributionData*/ ctx[1].nextPaymentDay + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*currentYear*/ 1) set_data_dev(t6, /*currentYear*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $contributionData;
    	validate_store(contributionData, 'contributionData');
    	component_subscribe($$self, contributionData, $$value => $$invalidate(1, $contributionData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NextPaymentDate', slots, []);
    	let currentDate = new Date();
    	let currentYear = currentDate.getFullYear();
    	let currentDay = currentDate.getDate();

    	if ($contributionData.nextPaymentMonth === "January") {
    		if ($contributionData.period === "Monthly") {
    			currentYear = currentYear + 1;
    		} else if ($contributionData.period === "Bi-Monthly" && currentDay >= 15) {
    			currentYear = currentYear + 1;
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NextPaymentDate> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		contributionData,
    		currentDate,
    		currentYear,
    		currentDay,
    		$contributionData
    	});

    	$$self.$inject_state = $$props => {
    		if ('currentDate' in $$props) currentDate = $$props.currentDate;
    		if ('currentYear' in $$props) $$invalidate(0, currentYear = $$props.currentYear);
    		if ('currentDay' in $$props) currentDay = $$props.currentDay;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*currentYear*/ 1) ;
    	};

    	return [currentYear, $contributionData];
    }

    class NextPaymentDate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NextPaymentDate",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* src\components\contributions\Form.svelte generated by Svelte v3.48.0 */
    const file$x = "src\\components\\contributions\\Form.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	return child_ctx;
    }

    // (89:12) {#each periods as period}
    function create_each_block_1$1(ctx) {
    	let div;
    	let t0_value = /*period*/ ctx[21] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[9](/*period*/ ctx[21]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "dropdown__item svelte-1xs7a49");
    			add_location(div, file$x, 89, 14, 3245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(89:12) {#each periods as period}",
    		ctx
    	});

    	return block;
    }

    // (122:12) {#each currencys as currency}
    function create_each_block$5(ctx) {
    	let div;
    	let t0_value = /*currency*/ ctx[18] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[11](/*currency*/ ctx[18]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "dropdown__item svelte-1xs7a49");
    			add_location(div, file$x, 122, 14, 4921);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(122:12) {#each currencys as currency}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div14;
    	let form;
    	let div5;
    	let div0;
    	let t1;
    	let div4;
    	let div3;
    	let svg0;
    	let path0;
    	let t2;
    	let div1;
    	let t3_value = /*$contributionData*/ ctx[2].period + "";
    	let t3;
    	let t4;
    	let div2;
    	let t5;
    	let div11;
    	let div6;
    	let t7;
    	let div10;
    	let div9;
    	let svg1;
    	let path1;
    	let t8;
    	let div7;
    	let t9_value = /*$contributionData*/ ctx[2].currency + "";
    	let t9;
    	let t10;
    	let div8;
    	let t11;
    	let div12;
    	let label;
    	let t13;
    	let input;
    	let t14;
    	let nextpaymentday;
    	let t15;
    	let div13;
    	let t16;
    	let span0;
    	let t18;
    	let span1;
    	let t20;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*periods*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	let each_value = /*currencys*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	nextpaymentday = new NextPaymentDate({ $$inline: true });

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			form = element("form");
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "Period*";
    			t1 = space();
    			div4 = element("div");
    			div3 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t2 = space();
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t5 = space();
    			div11 = element("div");
    			div6 = element("div");
    			div6.textContent = "Currency*";
    			t7 = space();
    			div10 = element("div");
    			div9 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t8 = space();
    			div7 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			div8 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t11 = space();
    			div12 = element("div");
    			label = element("label");
    			label.textContent = "Amount*";
    			t13 = space();
    			input = element("input");
    			t14 = space();
    			create_component(nextpaymentday.$$.fragment);
    			t15 = space();
    			div13 = element("div");
    			t16 = text("*Min. ");
    			span0 = element("span");
    			span0.textContent = "$20";
    			t18 = text(" and ");
    			span1 = element("span");
    			span1.textContent = "$9,999";
    			t20 = text(" Total contribution");
    			attr_dev(div0, "class", "label__text svelte-1xs7a49");
    			add_location(div0, file$x, 67, 6, 1837);
    			attr_dev(path0, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path0, "fill", "#032B01");
    			add_location(path0, file$x, 81, 12, 2254);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svelte-1xs7a49");
    			add_location(svg0, file$x, 74, 10, 2068);
    			attr_dev(div1, "class", "dropdown__item--current svelte-1xs7a49");
    			add_location(div1, file$x, 86, 10, 3080);
    			attr_dev(div2, "class", "dropdown__items svelte-1xs7a49");
    			add_location(div2, file$x, 87, 10, 3161);
    			attr_dev(div3, "class", "dropdown svelte-1xs7a49");
    			toggle_class(div3, "activePeriod", /*activePeriod*/ ctx[0]);
    			add_location(div3, file$x, 69, 8, 1924);
    			attr_dev(div4, "class", "dropdown__wrapper svelte-1xs7a49");
    			add_location(div4, file$x, 68, 6, 1883);
    			attr_dev(div5, "class", "period svelte-1xs7a49");
    			add_location(div5, file$x, 66, 4, 1809);
    			attr_dev(div6, "class", "label__text svelte-1xs7a49");
    			add_location(div6, file$x, 98, 6, 3473);
    			attr_dev(path1, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path1, "fill", "#032B01");
    			add_location(path1, file$x, 112, 12, 3898);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "svelte-1xs7a49");
    			add_location(svg1, file$x, 105, 10, 3712);
    			attr_dev(div7, "class", "dropdown__item--current svelte-1xs7a49");
    			add_location(div7, file$x, 117, 10, 4724);
    			attr_dev(div8, "class", "dropdown__items svelte-1xs7a49");
    			add_location(div8, file$x, 120, 10, 4833);
    			attr_dev(div9, "class", "dropdown svelte-1xs7a49");
    			toggle_class(div9, "activeCurrency", /*activeCurrency*/ ctx[1]);
    			add_location(div9, file$x, 100, 8, 3562);
    			attr_dev(div10, "class", "dropdown__wrapper svelte-1xs7a49");
    			add_location(div10, file$x, 99, 6, 3521);
    			attr_dev(div11, "class", "currency svelte-1xs7a49");
    			add_location(div11, file$x, 97, 4, 3443);
    			attr_dev(label, "class", "label__text svelte-1xs7a49");
    			attr_dev(label, "for", "amount");
    			add_location(label, file$x, 135, 6, 5206);
    			attr_dev(input, "type", "number");
    			attr_dev(input, "min", "20");
    			attr_dev(input, "max", "9999");
    			attr_dev(input, "maxlength", "4");
    			attr_dev(input, "onkeypress", "if(this.value.length==4) return false;");
    			attr_dev(input, "class", "svelte-1xs7a49");
    			add_location(input, file$x, 136, 6, 5269);
    			attr_dev(div12, "class", "amount svelte-1xs7a49");
    			add_location(div12, file$x, 134, 4, 5178);
    			attr_dev(form, "class", "svelte-1xs7a49");
    			add_location(form, file$x, 65, 2, 1772);
    			attr_dev(span0, "class", "svelte-1xs7a49");
    			add_location(span0, file$x, 152, 10, 5653);
    			attr_dev(span1, "class", "svelte-1xs7a49");
    			add_location(span1, file$x, 152, 31, 5674);
    			attr_dev(div13, "class", "contribution__help--text svelte-1xs7a49");
    			add_location(div13, file$x, 151, 2, 5603);
    			attr_dev(div14, "class", "contribution__form svelte-1xs7a49");
    			add_location(div14, file$x, 64, 0, 1736);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, form);
    			append_dev(form, div5);
    			append_dev(div5, div0);
    			append_dev(div5, t1);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, svg0);
    			append_dev(svg0, path0);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, t3);
    			append_dev(div3, t4);
    			append_dev(div3, div2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(form, t5);
    			append_dev(form, div11);
    			append_dev(div11, div6);
    			append_dev(div11, t7);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, svg1);
    			append_dev(svg1, path1);
    			append_dev(div9, t8);
    			append_dev(div9, div7);
    			append_dev(div7, t9);
    			append_dev(div9, t10);
    			append_dev(div9, div8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			append_dev(form, t11);
    			append_dev(form, div12);
    			append_dev(div12, label);
    			append_dev(div12, t13);
    			append_dev(div12, input);
    			set_input_value(input, /*$contributionData*/ ctx[2].amount);
    			append_dev(form, t14);
    			mount_component(nextpaymentday, form, null);
    			append_dev(div14, t15);
    			append_dev(div14, div13);
    			append_dev(div13, t16);
    			append_dev(div13, span0);
    			append_dev(div13, t18);
    			append_dev(div13, span1);
    			append_dev(div13, t20);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "click", /*click_handler_1*/ ctx[10], false, false, false),
    					listen_dev(div9, "click", /*click_handler_3*/ ctx[12], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[13]),
    					listen_dev(input, "mousewheel", mousewheel_handler, false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[8]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$contributionData*/ 4) && t3_value !== (t3_value = /*$contributionData*/ ctx[2].period + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*setPeriod, periods*/ 40) {
    				each_value_1 = /*periods*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*activePeriod*/ 1) {
    				toggle_class(div3, "activePeriod", /*activePeriod*/ ctx[0]);
    			}

    			if ((!current || dirty & /*$contributionData*/ 4) && t9_value !== (t9_value = /*$contributionData*/ ctx[2].currency + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*showCurrency, currencys*/ 80) {
    				each_value = /*currencys*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div8, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*activeCurrency*/ 2) {
    				toggle_class(div9, "activeCurrency", /*activeCurrency*/ ctx[1]);
    			}

    			if (dirty & /*$contributionData*/ 4 && to_number(input.value) !== /*$contributionData*/ ctx[2].amount) {
    				set_input_value(input, /*$contributionData*/ ctx[2].amount);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nextpaymentday.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nextpaymentday.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			destroy_component(nextpaymentday);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const mousewheel_handler = e => {
    	e.target.blur();
    };

    function instance$v($$self, $$props, $$invalidate) {
    	let $contributionData;
    	validate_store(contributionData, 'contributionData');
    	component_subscribe($$self, contributionData, $$value => $$invalidate(2, $contributionData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Form', slots, []);
    	let activePeriod = false;
    	let activeCurrency = false;
    	let periods = ["Monthly", "Bi-Monthly"];
    	let currencys = ["USD", "EUR", "CAD", "CHF", "GBP", "JPY"];

    	const months = [
    		"January",
    		"February",
    		"March",
    		"April",
    		"May",
    		"June",
    		"July",
    		"August",
    		"September",
    		"October",
    		"November",
    		"December"
    	];

    	let currentMonthIndex = new Date().getMonth();
    	let currentDay = new Date().getDate();
    	let paymentMounthIndex = currentMonthIndex + 1;

    	let currencySymbols = {
    		USD: "$",
    		EUR: "€",
    		CAD: "$",
    		CHF: "₣",
    		GBP: "£",
    		JPY: "¥"
    	};

    	afterUpdate(() => {
    		// if period bi-monthly set next payment day and payment mounth
    		if ($contributionData.period === "Bi-Monthly") {
    			if (currentDay < 15) {
    				$$invalidate(7, paymentMounthIndex = currentMonthIndex);
    				set_store_value(contributionData, $contributionData.nextPaymentDay = 15, $contributionData);
    			} else if (currentDay >= 15) {
    				$$invalidate(7, paymentMounthIndex = currentMonthIndex + 1);
    				set_store_value(contributionData, $contributionData.nextPaymentDay = 1, $contributionData);
    			}
    		} else {
    			$$invalidate(7, paymentMounthIndex = currentMonthIndex + 1);
    			set_store_value(contributionData, $contributionData.nextPaymentDay = 1, $contributionData);
    		}
    	});

    	function setPeriod(value) {
    		// set data to our store
    		set_store_value(contributionData, $contributionData.period = value, $contributionData);
    	}

    	function showCurrency(value) {
    		// set data to our store
    		set_store_value(contributionData, $contributionData.currency = value, $contributionData);

    		set_store_value(contributionData, $contributionData.currencySymbol = currencySymbols[value], $contributionData);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Form> was created with unknown prop '${key}'`);
    	});

    	function submit_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	const click_handler = period => setPeriod(period);
    	const click_handler_1 = () => $$invalidate(0, activePeriod = !activePeriod);
    	const click_handler_2 = currency => showCurrency(currency);
    	const click_handler_3 = () => $$invalidate(1, activeCurrency = !activeCurrency);

    	function input_input_handler() {
    		$contributionData.amount = to_number(this.value);
    		contributionData.set($contributionData);
    	}

    	$$self.$capture_state = () => ({
    		contributionData,
    		afterUpdate,
    		NextPaymentDay: NextPaymentDate,
    		activePeriod,
    		activeCurrency,
    		periods,
    		currencys,
    		months,
    		currentMonthIndex,
    		currentDay,
    		paymentMounthIndex,
    		currencySymbols,
    		setPeriod,
    		showCurrency,
    		$contributionData
    	});

    	$$self.$inject_state = $$props => {
    		if ('activePeriod' in $$props) $$invalidate(0, activePeriod = $$props.activePeriod);
    		if ('activeCurrency' in $$props) $$invalidate(1, activeCurrency = $$props.activeCurrency);
    		if ('periods' in $$props) $$invalidate(3, periods = $$props.periods);
    		if ('currencys' in $$props) $$invalidate(4, currencys = $$props.currencys);
    		if ('currentMonthIndex' in $$props) currentMonthIndex = $$props.currentMonthIndex;
    		if ('currentDay' in $$props) currentDay = $$props.currentDay;
    		if ('paymentMounthIndex' in $$props) $$invalidate(7, paymentMounthIndex = $$props.paymentMounthIndex);
    		if ('currencySymbols' in $$props) currencySymbols = $$props.currencySymbols;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*paymentMounthIndex*/ 128) {
    			set_store_value(contributionData, $contributionData.nextPaymentMonth = months[paymentMounthIndex], $contributionData);
    		}
    	};

    	return [
    		activePeriod,
    		activeCurrency,
    		$contributionData,
    		periods,
    		currencys,
    		setPeriod,
    		showCurrency,
    		paymentMounthIndex,
    		submit_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		input_input_handler
    	];
    }

    class Form extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Form",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    const stepCounter = writable(1);
    const headSteps = writable({
        firstStep: true,
        secondStep: false,
        thirdStep: false,
        fourthStep: false,
        fifthStep: false
    });

    function incrementStep() {
        stepCounter.update(n => n + 1);
    }
    function decrementStep() {
        if(get_store_value(stepCounter) > 1){
            stepCounter.update(n => n - 1 );
        }
    }
    const successMessageState = writable(false);

    let subscribeAllState = writable(false);

    /* src\components\contributions\Rules.svelte generated by Svelte v3.48.0 */

    const file$w = "src\\components\\contributions\\Rules.svelte";

    function create_fragment$w(ctx) {
    	let div3;
    	let div0;
    	let h2;
    	let t1;
    	let p;
    	let t3;
    	let div2;
    	let div1;
    	let t5;
    	let ol;
    	let li0;
    	let t7;
    	let li1;
    	let t9;
    	let li2;
    	let t11;
    	let li3;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			h2.textContent = "Our House. Our Rules.";
    			t1 = space();
    			p = element("p");
    			p.textContent = "We convert your money into green savings using a “long term” philosophy.\r\n      This allows us to actively produce investment value, whilst simultaneously\r\n      making a green impact. Although we put emphasis on creating value, we do\r\n      not do so at the expense of the environment. To reach our common\r\n      objectives there are few simple rules we need to apply.";
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			div1.textContent = "Our Rules:";
    			t5 = space();
    			ol = element("ol");
    			li0 = element("li");
    			li0.textContent = "We require your periodic contribution to be invested for 12 months.";
    			t7 = space();
    			li1 = element("li");
    			li1.textContent = "We always select investments that have a healthy balance between value and green impact.";
    			t9 = space();
    			li2 = element("li");
    			li2.textContent = "Withdrawals under 20% of the total value of your wallet will be processed immediately. Any amount over that 20% will vary to no more than 30 days.";
    			t11 = space();
    			li3 = element("li");
    			li3.textContent = "Community is an essential value. We encourage you to share the news of our ESi community so we can achieve our goal of becoming pioneers in our field";
    			attr_dev(h2, "class", "svelte-1sow6a7");
    			add_location(h2, file$w, 2, 4, 82);
    			attr_dev(p, "class", "svelte-1sow6a7");
    			add_location(p, file$w, 3, 4, 118);
    			attr_dev(div0, "class", "contribution__right__head svelte-1sow6a7");
    			add_location(div0, file$w, 1, 2, 37);
    			attr_dev(div1, "class", "rules__list__head svelte-1sow6a7");
    			add_location(div1, file$w, 12, 4, 553);
    			attr_dev(li0, "class", "svelte-1sow6a7");
    			add_location(li0, file$w, 14, 6, 618);
    			attr_dev(li1, "class", "svelte-1sow6a7");
    			add_location(li1, file$w, 17, 6, 720);
    			attr_dev(li2, "class", "svelte-1sow6a7");
    			add_location(li2, file$w, 20, 6, 843);
    			attr_dev(li3, "class", "svelte-1sow6a7");
    			add_location(li3, file$w, 23, 6, 1025);
    			attr_dev(ol, "class", "svelte-1sow6a7");
    			add_location(ol, file$w, 13, 4, 606);
    			attr_dev(div2, "class", "rules__list svelte-1sow6a7");
    			add_location(div2, file$w, 11, 2, 522);
    			attr_dev(div3, "class", "contribution__right svelte-1sow6a7");
    			add_location(div3, file$w, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, h2);
    			append_dev(div0, t1);
    			append_dev(div0, p);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div2, t5);
    			append_dev(div2, ol);
    			append_dev(ol, li0);
    			append_dev(ol, t7);
    			append_dev(ol, li1);
    			append_dev(ol, t9);
    			append_dev(ol, li2);
    			append_dev(ol, t11);
    			append_dev(ol, li3);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Rules', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rules> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Rules extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Rules",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src\components\buttons\ButtonRight.svelte generated by Svelte v3.48.0 */

    const file$v = "src\\components\\buttons\\ButtonRight.svelte";

    function create_fragment$v(ctx) {
    	let button;
    	let svg;
    	let path;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.63119 1.43197C4.46715 1.59606 4.375 1.81858 4.375 2.05059C4.375 2.28261 4.46715 2.50513 4.63119 2.66922L8.96244 7.00047L4.63119 11.3317C4.4718 11.4967 4.3836 11.7178 4.3856 11.9472C4.38759 12.1766 4.47961 12.3961 4.64185 12.5583C4.80408 12.7205 5.02354 12.8126 5.25296 12.8146C5.48238 12.8166 5.70341 12.7284 5.86844 12.569L10.8183 7.61909C10.9823 7.45501 11.0745 7.23249 11.0745 7.00047C11.0745 6.76845 10.9823 6.54593 10.8183 6.38184L5.86844 1.43197C5.70435 1.26793 5.48183 1.17578 5.24981 1.17578C5.01779 1.17578 4.79527 1.26793 4.63119 1.43197Z");
    			attr_dev(path, "fill", "#0084FF");
    			attr_dev(path, "class", "svelte-1jabaxy");
    			add_location(path, file$v, 12, 4, 244);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-1jabaxy");
    			add_location(svg, file$v, 5, 2, 114);
    			attr_dev(button, "class", "btn svelte-1jabaxy");
    			button.disabled = button_disabled_value = !/*buttonState*/ ctx[0];
    			add_location(button, file$v, 4, 0, 57);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*buttonState*/ 1 && button_disabled_value !== (button_disabled_value = !/*buttonState*/ ctx[0])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonRight', slots, []);
    	let { buttonState = true } = $$props;
    	const writable_props = ['buttonState'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonRight> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('buttonState' in $$props) $$invalidate(0, buttonState = $$props.buttonState);
    	};

    	$$self.$capture_state = () => ({ buttonState });

    	$$self.$inject_state = $$props => {
    		if ('buttonState' in $$props) $$invalidate(0, buttonState = $$props.buttonState);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [buttonState, click_handler];
    }

    class ButtonRight extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$v, safe_not_equal, { buttonState: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonRight",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get buttonState() {
    		throw new Error("<ButtonRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttonState(value) {
    		throw new Error("<ButtonRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\contributions\Contribution.svelte generated by Svelte v3.48.0 */
    const file$u = "src\\components\\contributions\\Contribution.svelte";

    // (104:8) {#if amountErrorMessageState}
    function create_if_block$9(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*amountErrorMessage*/ ctx[0]);
    			attr_dev(div, "class", "error__message svelte-1etsi9b");
    			add_location(div, file$u, 104, 10, 3240);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*amountErrorMessage*/ 1) set_data_dev(t, /*amountErrorMessage*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(104:8) {#if amountErrorMessageState}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div20;
    	let div19;
    	let div18;
    	let div0;
    	let h2;
    	let t0;
    	let span0;
    	let t2;
    	let form;
    	let t3;
    	let div16;
    	let div15;
    	let div1;
    	let t5;
    	let div14;
    	let div5;
    	let div2;
    	let t6;
    	let span1;
    	let t8;
    	let t9;
    	let div4;
    	let div3;
    	let t10_value = /*data*/ ctx[2].currencySymbol + "";
    	let t10;
    	let t11_value = (/*moVal*/ ctx[3] ? /*moVal*/ ctx[3] : 0) + "";
    	let t11;
    	let span2;
    	let t13;
    	let div9;
    	let div6;
    	let t14;
    	let span3;
    	let t16;
    	let t17;
    	let div8;
    	let div7;
    	let t18_value = /*data*/ ctx[2].currencySymbol + "";
    	let t18;
    	let t19;
    	let span4;
    	let t21;
    	let div13;
    	let div10;
    	let span5;
    	let t23;
    	let t24;
    	let div12;
    	let div11;
    	let t25_value = /*data*/ ctx[2].currencySymbol + "";
    	let t25;
    	let t26;
    	let span6;
    	let t28;
    	let rules;
    	let t29;
    	let div17;
    	let t30;
    	let buttonright;
    	let current;
    	form = new Form({ $$inline: true });
    	rules = new Rules({ $$inline: true });
    	let if_block = /*amountErrorMessageState*/ ctx[1] && create_if_block$9(ctx);
    	buttonright = new ButtonRight({ $$inline: true });
    	buttonright.$on("click", /*changeStep*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div20 = element("div");
    			div19 = element("div");
    			div18 = element("div");
    			div0 = element("div");
    			h2 = element("h2");
    			t0 = text("Choose your ");
    			span0 = element("span");
    			span0.textContent = "Contribution";
    			t2 = space();
    			create_component(form.$$.fragment);
    			t3 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div1 = element("div");
    			div1.textContent = "Projection & Rules";
    			t5 = space();
    			div14 = element("div");
    			div5 = element("div");
    			div2 = element("div");
    			t6 = text("Your ");
    			span1 = element("span");
    			span1.textContent = "Green";
    			t8 = text("\r\n                Contribution");
    			t9 = space();
    			div4 = element("div");
    			div3 = element("div");
    			t10 = text(t10_value);
    			t11 = text(t11_value);
    			span2 = element("span");
    			span2.textContent = "/mo";
    			t13 = space();
    			div9 = element("div");
    			div6 = element("div");
    			t14 = text("Annual ");
    			span3 = element("span");
    			span3.textContent = "Green";
    			t16 = text(" Conversion");
    			t17 = space();
    			div8 = element("div");
    			div7 = element("div");
    			t18 = text(t18_value);
    			t19 = text(/*yrVal*/ ctx[4]);
    			span4 = element("span");
    			span4.textContent = "/yr";
    			t21 = space();
    			div13 = element("div");
    			div10 = element("div");
    			span5 = element("span");
    			span5.textContent = "Green";
    			t23 = text("\r\n                Saving Projection");
    			t24 = space();
    			div12 = element("div");
    			div11 = element("div");
    			t25 = text(t25_value);
    			t26 = text(/*fiveYrVal*/ ctx[5]);
    			span6 = element("span");
    			span6.textContent = "/5yrs";
    			t28 = space();
    			create_component(rules.$$.fragment);
    			t29 = space();
    			div17 = element("div");
    			if (if_block) if_block.c();
    			t30 = space();
    			create_component(buttonright.$$.fragment);
    			attr_dev(span0, "class", "green svelte-1etsi9b");
    			add_location(span0, file$u, 58, 24, 1642);
    			attr_dev(h2, "class", "svelte-1etsi9b");
    			add_location(h2, file$u, 58, 8, 1626);
    			attr_dev(div0, "class", "contribution__head svelte-1etsi9b");
    			add_location(div0, file$u, 57, 6, 1584);
    			attr_dev(div1, "class", "rules__head svelte-1etsi9b");
    			add_location(div1, file$u, 63, 10, 1791);
    			attr_dev(span1, "class", "svelte-1etsi9b");
    			add_location(span1, file$u, 67, 21, 1986);
    			attr_dev(div2, "class", "rules_text contr svelte-1etsi9b");
    			add_location(div2, file$u, 66, 14, 1933);
    			attr_dev(span2, "class", "svelte-1etsi9b");
    			add_location(span2, file$u, 72, 58, 2207);
    			attr_dev(div3, "class", "rules__val svelte-1etsi9b");
    			add_location(div3, file$u, 71, 16, 2123);
    			attr_dev(div4, "class", "rules__val__wrapper svelte-1etsi9b");
    			add_location(div4, file$u, 70, 14, 2072);
    			attr_dev(div5, "class", "rules__item svelte-1etsi9b");
    			add_location(div5, file$u, 65, 12, 1892);
    			attr_dev(span3, "class", "svelte-1etsi9b");
    			add_location(span3, file$u, 78, 23, 2407);
    			attr_dev(div6, "class", "rules_text conver svelte-1etsi9b");
    			add_location(div6, file$u, 77, 14, 2351);
    			attr_dev(span4, "class", "svelte-1etsi9b");
    			add_location(span4, file$u, 82, 46, 2597);
    			attr_dev(div7, "class", "rules__val svelte-1etsi9b");
    			add_location(div7, file$u, 81, 16, 2525);
    			attr_dev(div8, "class", "rules__val__wrapper svelte-1etsi9b");
    			add_location(div8, file$u, 80, 14, 2474);
    			attr_dev(div9, "class", "rules__item center svelte-1etsi9b");
    			add_location(div9, file$u, 76, 12, 2303);
    			attr_dev(span5, "class", "svelte-1etsi9b");
    			add_location(span5, file$u, 88, 16, 2784);
    			attr_dev(div10, "class", "rules_text project svelte-1etsi9b");
    			add_location(div10, file$u, 87, 14, 2734);
    			attr_dev(span6, "class", "svelte-1etsi9b");
    			add_location(span6, file$u, 93, 50, 3002);
    			attr_dev(div11, "class", "rules__val svelte-1etsi9b");
    			add_location(div11, file$u, 92, 16, 2926);
    			attr_dev(div12, "class", "rules__val__wrapper svelte-1etsi9b");
    			add_location(div12, file$u, 91, 14, 2875);
    			attr_dev(div13, "class", "rules__item svelte-1etsi9b");
    			add_location(div13, file$u, 86, 12, 2693);
    			attr_dev(div14, "class", "rules__items svelte-1etsi9b");
    			add_location(div14, file$u, 64, 10, 1852);
    			attr_dev(div15, "class", "rules__top svelte-1etsi9b");
    			add_location(div15, file$u, 62, 8, 1755);
    			attr_dev(div16, "class", "rules svelte-1etsi9b");
    			add_location(div16, file$u, 61, 6, 1726);
    			attr_dev(div17, "class", "step__footer svelte-1etsi9b");
    			add_location(div17, file$u, 102, 6, 3163);
    			add_location(div18, file$u, 56, 4, 1571);
    			attr_dev(div19, "class", "column-left svelte-1etsi9b");
    			add_location(div19, file$u, 55, 2, 1540);
    			attr_dev(div20, "class", "contribution__main svelte-1etsi9b");
    			add_location(div20, file$u, 54, 0, 1504);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div20, anchor);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div0);
    			append_dev(div0, h2);
    			append_dev(h2, t0);
    			append_dev(h2, span0);
    			append_dev(div0, t2);
    			mount_component(form, div0, null);
    			append_dev(div18, t3);
    			append_dev(div18, div16);
    			append_dev(div16, div15);
    			append_dev(div15, div1);
    			append_dev(div15, t5);
    			append_dev(div15, div14);
    			append_dev(div14, div5);
    			append_dev(div5, div2);
    			append_dev(div2, t6);
    			append_dev(div2, span1);
    			append_dev(div2, t8);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, t10);
    			append_dev(div3, t11);
    			append_dev(div3, span2);
    			append_dev(div14, t13);
    			append_dev(div14, div9);
    			append_dev(div9, div6);
    			append_dev(div6, t14);
    			append_dev(div6, span3);
    			append_dev(div6, t16);
    			append_dev(div9, t17);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div7, t18);
    			append_dev(div7, t19);
    			append_dev(div7, span4);
    			append_dev(div14, t21);
    			append_dev(div14, div13);
    			append_dev(div13, div10);
    			append_dev(div10, span5);
    			append_dev(div10, t23);
    			append_dev(div13, t24);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, t25);
    			append_dev(div11, t26);
    			append_dev(div11, span6);
    			append_dev(div16, t28);
    			mount_component(rules, div16, null);
    			append_dev(div18, t29);
    			append_dev(div18, div17);
    			if (if_block) if_block.m(div17, null);
    			append_dev(div17, t30);
    			mount_component(buttonright, div17, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*data*/ 4) && t10_value !== (t10_value = /*data*/ ctx[2].currencySymbol + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*moVal*/ 8) && t11_value !== (t11_value = (/*moVal*/ ctx[3] ? /*moVal*/ ctx[3] : 0) + "")) set_data_dev(t11, t11_value);
    			if ((!current || dirty & /*data*/ 4) && t18_value !== (t18_value = /*data*/ ctx[2].currencySymbol + "")) set_data_dev(t18, t18_value);
    			if (!current || dirty & /*yrVal*/ 16) set_data_dev(t19, /*yrVal*/ ctx[4]);
    			if ((!current || dirty & /*data*/ 4) && t25_value !== (t25_value = /*data*/ ctx[2].currencySymbol + "")) set_data_dev(t25, t25_value);
    			if (!current || dirty & /*fiveYrVal*/ 32) set_data_dev(t26, /*fiveYrVal*/ ctx[5]);

    			if (/*amountErrorMessageState*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					if_block.m(div17, t30);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(form.$$.fragment, local);
    			transition_in(rules.$$.fragment, local);
    			transition_in(buttonright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(form.$$.fragment, local);
    			transition_out(rules.$$.fragment, local);
    			transition_out(buttonright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div20);
    			destroy_component(form);
    			destroy_component(rules);
    			if (if_block) if_block.d();
    			destroy_component(buttonright);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $contributionData;
    	let $headSteps;
    	validate_store(contributionData, 'contributionData');
    	component_subscribe($$self, contributionData, $$value => $$invalidate(8, $contributionData = $$value));
    	validate_store(headSteps, 'headSteps');
    	component_subscribe($$self, headSteps, $$value => $$invalidate(9, $headSteps = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Contribution', slots, []);
    	let changeCounter = 0;
    	let amountErrorMessage = "Error message", amountErrorMessageState = false;

    	function changeStep() {
    		if (validateAmount()) {
    			set_store_value(headSteps, $headSteps.secondStep = true, $headSteps);

    			if (changeCounter === 0) {
    				incrementStep();
    				changeCounter += 1;
    			}
    		}
    	}

    	let data;

    	const unsubscribe = contributionData.subscribe(value => {
    		$$invalidate(2, data = value);
    	});

    	function validateAmount() {
    		if (data.amount < 20) {
    			$$invalidate(0, amountErrorMessage = "Value shoud be more than 20");
    			$$invalidate(1, amountErrorMessageState = true);
    		} else {
    			return true;
    		}
    	}

    	let moVal = data.monthlyValue, yrVal = 7200, fiveYrVal = 36000;

    	beforeUpdate(() => {
    		// if period monthly - set current value
    		if (data.period === "Monthly") {
    			$$invalidate(3, moVal = data.amount);
    			set_store_value(contributionData, $contributionData.monthlyValue = moVal, $contributionData);
    		} else if (data.period === "Bi-Monthly") {
    			$$invalidate(3, moVal = data.amount * 2); // if bi-monthly - divide value into two
    			set_store_value(contributionData, $contributionData.monthlyValue = moVal, $contributionData);
    		}

    		$$invalidate(4, yrVal = moVal * 12);
    		$$invalidate(5, fiveYrVal = yrVal * 5);
    	});

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Contribution> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Form,
    		incrementStep,
    		headSteps,
    		contributionData,
    		beforeUpdate,
    		onDestroy,
    		Rules,
    		ButtonRight,
    		changeCounter,
    		amountErrorMessage,
    		amountErrorMessageState,
    		changeStep,
    		data,
    		unsubscribe,
    		validateAmount,
    		moVal,
    		yrVal,
    		fiveYrVal,
    		$contributionData,
    		$headSteps
    	});

    	$$self.$inject_state = $$props => {
    		if ('changeCounter' in $$props) changeCounter = $$props.changeCounter;
    		if ('amountErrorMessage' in $$props) $$invalidate(0, amountErrorMessage = $$props.amountErrorMessage);
    		if ('amountErrorMessageState' in $$props) $$invalidate(1, amountErrorMessageState = $$props.amountErrorMessageState);
    		if ('data' in $$props) $$invalidate(2, data = $$props.data);
    		if ('moVal' in $$props) $$invalidate(3, moVal = $$props.moVal);
    		if ('yrVal' in $$props) $$invalidate(4, yrVal = $$props.yrVal);
    		if ('fiveYrVal' in $$props) $$invalidate(5, fiveYrVal = $$props.fiveYrVal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		amountErrorMessage,
    		amountErrorMessageState,
    		data,
    		moVal,
    		yrVal,
    		fiveYrVal,
    		changeStep
    	];
    }

    class Contribution extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contribution",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\components\HeadSteps.svelte generated by Svelte v3.48.0 */

    const { console: console_1$5 } = globals;
    const file$t = "src\\components\\HeadSteps.svelte";

    function create_fragment$t(ctx) {
    	let div5;
    	let div0;
    	let svg0;
    	let path0;
    	let span0;
    	let t1;
    	let div1;
    	let svg1;
    	let path1;
    	let t2;
    	let span1;
    	let t4;
    	let div2;
    	let svg2;
    	let path2;
    	let t5;
    	let span2;
    	let t7;
    	let div3;
    	let svg3;
    	let path3;
    	let t8;
    	let span3;
    	let t10;
    	let div4;
    	let svg4;
    	let path4;
    	let t11;
    	let span4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			span0 = element("span");
    			span0.textContent = "Contribution";
    			t1 = space();
    			div1 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t2 = space();
    			span1 = element("span");
    			span1.textContent = "Plan";
    			t4 = space();
    			div2 = element("div");
    			svg2 = svg_element("svg");
    			path2 = svg_element("path");
    			t5 = space();
    			span2 = element("span");
    			span2.textContent = "Legal";
    			t7 = space();
    			div3 = element("div");
    			svg3 = svg_element("svg");
    			path3 = svg_element("path");
    			t8 = space();
    			span3 = element("span");
    			span3.textContent = "Information";
    			t10 = space();
    			div4 = element("div");
    			svg4 = svg_element("svg");
    			path4 = svg_element("path");
    			t11 = space();
    			span4 = element("span");
    			span4.textContent = "Billing Information";
    			attr_dev(path0, "d", "M21 18V19C21 20.1 20.1 21 19 21H5C3.89 21 3 20.1 3 19V5C3 3.9 3.89 3 5 3H19C20.1 3 21 3.9 21 5V6H12C10.89 6 10 6.9 10 8V16C10 17.1 10.89 18 12 18H21ZM12 16H22V8H12V16ZM16 13.5C15.17 13.5 14.5 12.83 14.5 12C14.5 11.17 15.17 10.5 16 10.5C16.83 10.5 17.5 11.17 17.5 12C17.5 12.83 16.83 13.5 16 13.5Z");
    			attr_dev(path0, "fill", "white");
    			attr_dev(path0, "class", "svelte-pungl9");
    			add_location(path0, file$t, 31, 6, 784);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svg__icon svelte-pungl9");
    			add_location(svg0, file$t, 23, 4, 615);
    			attr_dev(span0, "class", "svelte-pungl9");
    			add_location(span0, file$t, 35, 10, 1143);
    			attr_dev(div0, "class", "head__step svelte-pungl9");
    			attr_dev(div0, "data-step", "1");
    			toggle_class(div0, "visited", /*$headSteps*/ ctx[1].firstStep);
    			toggle_class(div0, "current", /*$stepCounter*/ ctx[0] === 1);
    			add_location(div0, file$t, 16, 2, 451);
    			attr_dev(path1, "d", "M19 3H14.82C14.4 1.84 13.3 1 12 1C10.7 1 9.6 1.84 9.18 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM12 3C12.55 3 13 3.45 13 4C13 4.55 12.55 5 12 5C11.45 5 11 4.55 11 4C11 3.45 11.45 3 12 3ZM14 17H7V15H14V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z");
    			attr_dev(path1, "fill", "white");
    			attr_dev(path1, "class", "svelte-pungl9");
    			add_location(path1, file$t, 52, 6, 1516);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "svg__icon svelte-pungl9");
    			add_location(svg1, file$t, 44, 4, 1347);
    			attr_dev(span1, "class", "svelte-pungl9");
    			add_location(span1, file$t, 57, 4, 1869);
    			attr_dev(div1, "class", "head__step svelte-pungl9");
    			attr_dev(div1, "data-step", "2");
    			toggle_class(div1, "visited", /*$headSteps*/ ctx[1].secondStep);
    			toggle_class(div1, "current", /*$stepCounter*/ ctx[0] === 2);
    			add_location(div1, file$t, 37, 2, 1182);
    			attr_dev(path2, "d", "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14 17H7V15H14V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z");
    			attr_dev(path2, "fill", "white");
    			attr_dev(path2, "class", "svelte-pungl9");
    			add_location(path2, file$t, 73, 6, 2209);
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "width", "24");
    			attr_dev(svg2, "height", "24");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "class", "svg__icon svelte-pungl9");
    			add_location(svg2, file$t, 65, 4, 2040);
    			attr_dev(span2, "class", "svelte-pungl9");
    			add_location(span2, file$t, 78, 4, 2421);
    			attr_dev(div2, "class", "head__step svelte-pungl9");
    			attr_dev(div2, "data-step", "3");
    			toggle_class(div2, "visited", /*$headSteps*/ ctx[1].thirdStep);
    			toggle_class(div2, "current", /*$stepCounter*/ ctx[0] === 3);
    			add_location(div2, file$t, 59, 2, 1900);
    			attr_dev(path3, "d", "M10 0C4.48 0 0 4.48 0 10C0 15.52 4.48 20 10 20C15.52 20 20 15.52 20 10C20 4.48 15.52 0 10 0ZM11 15H9V9H11V15ZM11 7H9V5H11V7Z");
    			attr_dev(path3, "fill", "white");
    			attr_dev(path3, "class", "svelte-pungl9");
    			add_location(path3, file$t, 94, 6, 2763);
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "width", "20");
    			attr_dev(svg3, "height", "20");
    			attr_dev(svg3, "viewBox", "0 0 20 20");
    			attr_dev(svg3, "fill", "none");
    			attr_dev(svg3, "class", "svg__icon svelte-pungl9");
    			add_location(svg3, file$t, 86, 4, 2594);
    			attr_dev(span3, "class", "svelte-pungl9");
    			add_location(span3, file$t, 99, 4, 2956);
    			attr_dev(div3, "class", "head__step svelte-pungl9");
    			attr_dev(div3, "data-step", "4");
    			toggle_class(div3, "visited", /*$headSteps*/ ctx[1].fourthStep);
    			toggle_class(div3, "current", /*$stepCounter*/ ctx[0] === 4);
    			add_location(div3, file$t, 80, 2, 2453);
    			attr_dev(path4, "d", "M19 3H5C3.9 3 3 3.9 3 5V12C3 13.1 3.9 14 5 14H19C20.1 14 21 13.1 21 12V5C21 3.9 20.1 3 19 3ZM19 9H15C15 10.62 13.62 12 12 12C10.38 12 9 10.62 9 9H5V5H19V9ZM15 16H21V19C21 20.1 20.1 21 19 21H5C3.9 21 3 20.1 3 19V16H9C9 17.66 10.34 19 12 19C13.66 19 15 17.66 15 16Z");
    			attr_dev(path4, "fill", "white");
    			attr_dev(path4, "class", "svelte-pungl9");
    			add_location(path4, file$t, 115, 6, 3303);
    			attr_dev(svg4, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg4, "width", "24");
    			attr_dev(svg4, "height", "24");
    			attr_dev(svg4, "viewBox", "0 0 24 24");
    			attr_dev(svg4, "fill", "none");
    			attr_dev(svg4, "class", "svg__icon svelte-pungl9");
    			add_location(svg4, file$t, 107, 4, 3134);
    			attr_dev(span4, "class", "svelte-pungl9");
    			add_location(span4, file$t, 120, 4, 3635);
    			attr_dev(div4, "class", "head__step svelte-pungl9");
    			attr_dev(div4, "data-step", "5");
    			toggle_class(div4, "visited", /*$headSteps*/ ctx[1].fifthStep);
    			toggle_class(div4, "current", /*$stepCounter*/ ctx[0] === 5);
    			add_location(div4, file$t, 101, 2, 2994);
    			attr_dev(div5, "class", "head__steps svelte-pungl9");
    			add_location(div5, file$t, 15, 0, 422);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div0, svg0);
    			append_dev(svg0, path0);
    			append_dev(div0, span0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div1, svg1);
    			append_dev(svg1, path1);
    			append_dev(div1, t2);
    			append_dev(div1, span1);
    			append_dev(div5, t4);
    			append_dev(div5, div2);
    			append_dev(div2, svg2);
    			append_dev(svg2, path2);
    			append_dev(div2, t5);
    			append_dev(div2, span2);
    			append_dev(div5, t7);
    			append_dev(div5, div3);
    			append_dev(div3, svg3);
    			append_dev(svg3, path3);
    			append_dev(div3, t8);
    			append_dev(div3, span3);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div4, svg4);
    			append_dev(svg4, path4);
    			append_dev(div4, t11);
    			append_dev(div4, span4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*setStep*/ ctx[2], false, false, false),
    					listen_dev(div1, "click", /*setStep*/ ctx[2], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$headSteps*/ 2) {
    				toggle_class(div0, "visited", /*$headSteps*/ ctx[1].firstStep);
    			}

    			if (dirty & /*$stepCounter*/ 1) {
    				toggle_class(div0, "current", /*$stepCounter*/ ctx[0] === 1);
    			}

    			if (dirty & /*$headSteps*/ 2) {
    				toggle_class(div1, "visited", /*$headSteps*/ ctx[1].secondStep);
    			}

    			if (dirty & /*$stepCounter*/ 1) {
    				toggle_class(div1, "current", /*$stepCounter*/ ctx[0] === 2);
    			}

    			if (dirty & /*$headSteps*/ 2) {
    				toggle_class(div2, "visited", /*$headSteps*/ ctx[1].thirdStep);
    			}

    			if (dirty & /*$stepCounter*/ 1) {
    				toggle_class(div2, "current", /*$stepCounter*/ ctx[0] === 3);
    			}

    			if (dirty & /*$headSteps*/ 2) {
    				toggle_class(div3, "visited", /*$headSteps*/ ctx[1].fourthStep);
    			}

    			if (dirty & /*$stepCounter*/ 1) {
    				toggle_class(div3, "current", /*$stepCounter*/ ctx[0] === 4);
    			}

    			if (dirty & /*$headSteps*/ 2) {
    				toggle_class(div4, "visited", /*$headSteps*/ ctx[1].fifthStep);
    			}

    			if (dirty & /*$stepCounter*/ 1) {
    				toggle_class(div4, "current", /*$stepCounter*/ ctx[0] === 5);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $stepCounter;
    	let $headSteps;
    	validate_store(stepCounter, 'stepCounter');
    	component_subscribe($$self, stepCounter, $$value => $$invalidate(0, $stepCounter = $$value));
    	validate_store(headSteps, 'headSteps');
    	component_subscribe($$self, headSteps, $$value => $$invalidate(1, $headSteps = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HeadSteps', slots, []);
    	let stepCountValue;

    	const unsubscribe = stepCounter.subscribe(value => {
    		stepCountValue = value;
    	});

    	function setStep() {
    		let stepValue = this.getAttribute("data-step");
    		set_store_value(stepCounter, $stepCounter = parseInt(stepValue), $stepCounter);
    		console.log($stepCounter);
    	}

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<HeadSteps> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepCounter,
    		headSteps,
    		onDestroy,
    		stepCountValue,
    		unsubscribe,
    		setStep,
    		$stepCounter,
    		$headSteps
    	});

    	$$self.$inject_state = $$props => {
    		if ('stepCountValue' in $$props) stepCountValue = $$props.stepCountValue;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$stepCounter, $headSteps, setStep];
    }

    class HeadSteps extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeadSteps",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    const plansModalData = writable({
        class: 'safe',
        name: 'Green Safe',
        desc: 'Safe as a bank account. This fund invests exclusively in green bonds and is the perfect option for Green Savers who want to be sure their funds are secure. The Green Safe plan involves a commitment to institutional and governmental bonds and enables subscribers to have a global, national, and local impact.',
        lottie: "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/6281f1b9694dfd538fae0ee3_Safe.json"
    });

    const plansModalState = writable(false);

    const sortPersantageVariable = writable ("all");

    const disableAllDropdown = writable(false);


    let planData = [
        {
          sortName: "all",
          persentage: 0,
          value: "0 of Total Contribution",
          visibility: true,
        },
        {
          sortName: "fourth",
          persentage: 25,
          value: "1/4 of Total Contribution",
          visibility: true,
        },
        {
          sortName: "fourth",
          persentage: 50,
          value: "2/4 of Total Contribution",
          visibility: true,
        },
        {
          sortName: "fourth",
          persentage: 75,
          value: "3/4 of Total Contribution",
          visibility: true,
        },
        {
          sortName: "fourth",
          persentage: 100,
          value: "4/4 of Total Contribution",
          visibility: true,
        }
        
      ];

    /* src\components\plans\PlanHead.svelte generated by Svelte v3.48.0 */
    const file$s = "src\\components\\plans\\PlanHead.svelte";

    function create_fragment$s(ctx) {
    	let div7;
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let span0;
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*data*/ ctx[0].currencySymbol + "";
    	let t4;
    	let t5_value = (/*moVal*/ ctx[1] ? /*moVal*/ ctx[1] : 0) + "";
    	let t5;
    	let span1;
    	let t7;
    	let div3;
    	let t8;
    	let div6;
    	let div5;
    	let p;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text("Your ");
    			span0 = element("span");
    			span0.textContent = "Green";
    			t2 = text("\r\n        Contribution");
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = text(t5_value);
    			span1 = element("span");
    			span1.textContent = "/mo";
    			t7 = space();
    			div3 = element("div");
    			t8 = space();
    			div6 = element("div");
    			div5 = element("div");
    			p = element("p");
    			p.textContent = "You can choose between numerous plans, from the Green Safe to the Green\r\n        Adventure and/or Green Founder. Change your plan selection and choose\r\n        how to distribute your periodic contribution anytime. You can change,\r\n        and therefore we adapt!";
    			attr_dev(span0, "class", "green svelte-oz6esi");
    			add_location(span0, file$s, 15, 13, 423);
    			attr_dev(div0, "class", "text svelte-oz6esi");
    			add_location(div0, file$s, 14, 6, 390);
    			attr_dev(span1, "class", "svelte-oz6esi");
    			add_location(span1, file$s, 19, 48, 573);
    			attr_dev(div1, "class", "plans__val svelte-oz6esi");
    			add_location(div1, file$s, 18, 6, 499);
    			attr_dev(div2, "class", "column__item left svelte-oz6esi");
    			add_location(div2, file$s, 13, 4, 351);
    			attr_dev(div3, "class", "line svelte-oz6esi");
    			add_location(div3, file$s, 23, 4, 623);
    			attr_dev(div4, "class", "column svelte-oz6esi");
    			add_location(div4, file$s, 12, 2, 325);
    			attr_dev(p, "class", "svelte-oz6esi");
    			add_location(p, file$s, 27, 6, 729);
    			attr_dev(div5, "class", "column__item rigth svelte-oz6esi");
    			add_location(div5, file$s, 26, 4, 689);
    			attr_dev(div6, "class", "column right svelte-oz6esi");
    			add_location(div6, file$s, 25, 2, 657);
    			attr_dev(div7, "class", "plans__head svelte-oz6esi");
    			add_location(div7, file$s, 11, 0, 296);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div4);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, span0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div1, t5);
    			append_dev(div1, span1);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, p);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*data*/ ctx[0].currencySymbol + "")) set_data_dev(t4, t4_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlanHead', slots, []);
    	let data;

    	const unsubscribe = contributionData.subscribe(value => {
    		$$invalidate(0, data = value);
    	});

    	let moVal = data.monthlyValue;
    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlanHead> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		contributionData,
    		onDestroy,
    		data,
    		unsubscribe,
    		moVal
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('moVal' in $$props) $$invalidate(1, moVal = $$props.moVal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, moVal];
    }

    class PlanHead extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlanHead",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src\components\buttons\ButtonLeft.svelte generated by Svelte v3.48.0 */

    const file$r = "src\\components\\buttons\\ButtonLeft.svelte";

    function create_fragment$r(ctx) {
    	let button;
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M9.36881 12.568C9.53285 12.4039 9.625 12.1814 9.625 11.9494C9.625 11.7174 9.53285 11.4949 9.36881 11.3308L5.03756 6.99953L9.36881 2.66828C9.5282 2.50325 9.61639 2.28223 9.6144 2.0528C9.61241 1.82338 9.52038 1.60392 9.35815 1.44169C9.19592 1.27946 8.97646 1.18743 8.74704 1.18544C8.51761 1.18345 8.29659 1.27164 8.13156 1.43103L3.18169 6.38091C3.01765 6.54499 2.9255 6.76751 2.9255 6.99953C2.9255 7.23155 3.01765 7.45407 3.18169 7.61816L8.13156 12.568C8.29565 12.7321 8.51817 12.8242 8.75019 12.8242C8.98221 12.8242 9.20473 12.7321 9.36881 12.568Z");
    			attr_dev(path, "fill", "#5E0BC9");
    			attr_dev(path, "class", "svelte-xv2b8a");
    			add_location(path, file$r, 8, 4, 163);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-xv2b8a");
    			add_location(svg, file$r, 1, 3, 33);
    			attr_dev(button, "class", "btn svelte-xv2b8a");
    			add_location(button, file$r, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ButtonLeft', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ButtonLeft> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	return [click_handler];
    }

    class ButtonLeft extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ButtonLeft",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\components\plans\PlanBtn.svelte generated by Svelte v3.48.0 */

    const file$q = "src\\components\\plans\\PlanBtn.svelte";

    function create_fragment$q(ctx) {
    	let div;
    	let button;
    	let t0;
    	let t1;
    	let svg;
    	let path0;
    	let path1;
    	let button_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = text(/*content*/ ctx[0]);
    			t1 = space();
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "d", "M12 1.5C6.20156 1.5 1.5 6.20156 1.5 12C1.5 17.7984 6.20156 22.5 12 22.5C17.7984 22.5 22.5 17.7984 22.5 12C22.5 6.20156 17.7984 1.5 12 1.5ZM12 20.7188C7.18594 20.7188 3.28125 16.8141 3.28125 12C3.28125 7.18594 7.18594 3.28125 12 3.28125C16.8141 3.28125 20.7188 7.18594 20.7188 12C20.7188 16.8141 16.8141 20.7188 12 20.7188Z");
    			attr_dev(path0, "fill", "white");
    			add_location(path0, file$q, 15, 6, 296);
    			attr_dev(path1, "d", "M10.875 7.875C10.875 8.17337 10.9935 8.45952 11.2045 8.6705C11.4155 8.88147 11.7016 9 12 9C12.2984 9 12.5845 8.88147 12.7955 8.6705C13.0065 8.45952 13.125 8.17337 13.125 7.875C13.125 7.57663 13.0065 7.29048 12.7955 7.0795C12.5845 6.86853 12.2984 6.75 12 6.75C11.7016 6.75 11.4155 6.86853 11.2045 7.0795C10.9935 7.29048 10.875 7.57663 10.875 7.875ZM12.5625 10.5H11.4375C11.3344 10.5 11.25 10.5844 11.25 10.6875V17.0625C11.25 17.1656 11.3344 17.25 11.4375 17.25H12.5625C12.6656 17.25 12.75 17.1656 12.75 17.0625V10.6875C12.75 10.5844 12.6656 10.5 12.5625 10.5Z");
    			attr_dev(path1, "fill", "white");
    			add_location(path1, file$q, 19, 6, 677);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-mmg5u2");
    			add_location(svg, file$q, 8, 4, 152);
    			attr_dev(button, "class", button_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-mmg5u2"));
    			add_location(button, file$q, 6, 2, 96);
    			attr_dev(div, "class", "wrapper svelte-mmg5u2");
    			add_location(div, file$q, 5, 0, 71);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*content*/ 1) set_data_dev(t0, /*content*/ ctx[0]);

    			if (dirty & /*className*/ 2 && button_class_value !== (button_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-mmg5u2"))) {
    				attr_dev(button, "class", button_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlanBtn', slots, []);
    	let { content } = $$props;
    	let { className } = $$props;
    	const writable_props = ['content', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlanBtn> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('content' in $$props) $$invalidate(0, content = $$props.content);
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({ content, className });

    	$$self.$inject_state = $$props => {
    		if ('content' in $$props) $$invalidate(0, content = $$props.content);
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [content, className, click_handler];
    }

    class PlanBtn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$q, safe_not_equal, { content: 0, className: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlanBtn",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*content*/ ctx[0] === undefined && !('content' in props)) {
    			console.warn("<PlanBtn> was created without expected prop 'content'");
    		}

    		if (/*className*/ ctx[1] === undefined && !('className' in props)) {
    			console.warn("<PlanBtn> was created without expected prop 'className'");
    		}
    	}

    	get content() {
    		throw new Error("<PlanBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<PlanBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<PlanBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<PlanBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\plans\PlanItems.svelte generated by Svelte v3.48.0 */

    const { console: console_1$4 } = globals;
    const file$p = "src\\components\\plans\\PlanItems.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    // (203:16) {#each savePercentages as item}
    function create_each_block_2(ctx) {
    	let div;
    	let t0_value = /*item*/ ctx[33].persentage + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[18](/*item*/ ctx[33]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text("%\r\n                  ");
    			attr_dev(div, "class", "dropdown__item svelte-w0dult");
    			toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].safe < /*item*/ ctx[33].persentage);
    			add_location(div, file$p, 203, 18, 9381);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*savePercentages*/ 1 && t0_value !== (t0_value = /*item*/ ctx[33].persentage + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions*/ 515) {
    				toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].safe < /*item*/ ctx[33].persentage);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(203:16) {#each savePercentages as item}",
    		ctx
    	});

    	return block;
    }

    // (340:16) {#each savePercentages as item}
    function create_each_block_1(ctx) {
    	let div;
    	let t0_value = /*item*/ ctx[33].persentage + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[22](/*item*/ ctx[33]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text("%\r\n                  ");
    			attr_dev(div, "class", "dropdown__item svelte-w0dult");
    			toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].adventure < /*item*/ ctx[33].persentage);
    			add_location(div, file$p, 340, 18, 16089);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_5, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*savePercentages*/ 1 && t0_value !== (t0_value = /*item*/ ctx[33].persentage + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions*/ 515) {
    				toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].adventure < /*item*/ ctx[33].persentage);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(340:16) {#each savePercentages as item}",
    		ctx
    	});

    	return block;
    }

    // (479:16) {#each savePercentages as item}
    function create_each_block$4(ctx) {
    	let div;
    	let t0_value = /*item*/ ctx[33].persentage + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_9() {
    		return /*click_handler_9*/ ctx[26](/*item*/ ctx[33]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = text("%\r\n                  ");
    			attr_dev(div, "class", "dropdown__item svelte-w0dult");
    			toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].founder < /*item*/ ctx[33].persentage);
    			add_location(div, file$p, 479, 18, 22923);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_9, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*savePercentages*/ 1 && t0_value !== (t0_value = /*item*/ ctx[33].persentage + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions*/ 515) {
    				toggle_class(div, "disabled", !/*item*/ ctx[33].visibility || /*item*/ ctx[33].persentage > /*allowPercentageVal*/ ctx[9] && /*allowPercentageVal*/ ctx[9] + /*$allocatedContributions*/ ctx[1].founder < /*item*/ ctx[33].persentage);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(479:16) {#each savePercentages as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div69;
    	let div22;
    	let div5;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div0;
    	let t2;
    	let div4;
    	let div2;
    	let svg0;
    	let path0;
    	let defs0;
    	let linearGradient0;
    	let stop0;
    	let stop1;
    	let t3;
    	let div3;
    	let svg1;
    	let path1;
    	let t4;
    	let div21;
    	let div20;
    	let div13;
    	let div6;
    	let t6;
    	let div10;
    	let div9;
    	let svg2;
    	let path2;
    	let t7;
    	let div7;
    	let t8_value = /*$allocatedContributions*/ ctx[1].safe + "";
    	let t8;
    	let t9;
    	let t10;
    	let div8;
    	let t11;
    	let div12;
    	let div11;
    	let t12_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*safePrice*/ ctx[2]) + "";
    	let t12;
    	let t13;
    	let div16;
    	let div14;
    	let t15;
    	let div15;
    	let t17;
    	let div19;
    	let div17;
    	let t19;
    	let ul0;
    	let li0;
    	let t21;
    	let li1;
    	let t23;
    	let li2;
    	let t25;
    	let div18;
    	let t27;
    	let planbtn0;
    	let t28;
    	let div45;
    	let div28;
    	let div24;
    	let img1;
    	let img1_src_value;
    	let t29;
    	let div23;
    	let t31;
    	let div27;
    	let div25;
    	let svg3;
    	let path3;
    	let defs1;
    	let linearGradient1;
    	let stop2;
    	let stop3;
    	let t32;
    	let div26;
    	let svg4;
    	let path4;
    	let t33;
    	let div44;
    	let div43;
    	let div36;
    	let div29;
    	let t35;
    	let div33;
    	let div32;
    	let svg5;
    	let path5;
    	let t36;
    	let div30;
    	let t37_value = /*$allocatedContributions*/ ctx[1].adventure + "";
    	let t37;
    	let t38;
    	let t39;
    	let div31;
    	let t40;
    	let div35;
    	let div34;
    	let t41_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*adventurePrice*/ ctx[3]) + "";
    	let t41;
    	let t42;
    	let div39;
    	let div37;
    	let t44;
    	let div38;
    	let t46;
    	let div42;
    	let div40;
    	let t48;
    	let ul1;
    	let li3;
    	let t50;
    	let li4;
    	let t52;
    	let li5;
    	let t54;
    	let div41;
    	let t55;
    	let planbtn1;
    	let t56;
    	let div68;
    	let div51;
    	let div47;
    	let img2;
    	let img2_src_value;
    	let t57;
    	let div46;
    	let t59;
    	let div50;
    	let div48;
    	let svg6;
    	let path6;
    	let defs2;
    	let linearGradient2;
    	let stop4;
    	let stop5;
    	let t60;
    	let div49;
    	let svg7;
    	let path7;
    	let t61;
    	let div67;
    	let div66;
    	let div59;
    	let div52;
    	let t63;
    	let div56;
    	let div55;
    	let svg8;
    	let path8;
    	let t64;
    	let div53;
    	let t65_value = /*$allocatedContributions*/ ctx[1].founder + "";
    	let t65;
    	let t66;
    	let t67;
    	let div54;
    	let t68;
    	let div58;
    	let div57;
    	let t69_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*founderPrice*/ ctx[4]) + "";
    	let t69;
    	let t70;
    	let div62;
    	let div60;
    	let t72;
    	let div61;
    	let t74;
    	let div65;
    	let div63;
    	let t76;
    	let ul2;
    	let li6;
    	let t78;
    	let div64;
    	let t80;
    	let planbtn2;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*savePercentages*/ ctx[0];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	planbtn0 = new PlanBtn({
    			props: {
    				content: "Green Safe info",
    				className: "blue"
    			},
    			$$inline: true
    		});

    	planbtn0.$on("click", /*click_handler_3*/ ctx[20]);
    	let each_value_1 = /*savePercentages*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	planbtn1 = new PlanBtn({
    			props: {
    				content: "Green Adventure info",
    				className: "green"
    			},
    			$$inline: true
    		});

    	planbtn1.$on("click", /*click_handler_7*/ ctx[24]);
    	let each_value = /*savePercentages*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	planbtn2 = new PlanBtn({
    			props: {
    				content: "Green Founder info",
    				className: "violet"
    			},
    			$$inline: true
    		});

    	planbtn2.$on("click", /*click_handler_11*/ ctx[28]);

    	const block = {
    		c: function create() {
    			div69 = element("div");
    			div22 = element("div");
    			div5 = element("div");
    			div1 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Select GREEN SAFE";
    			t2 = space();
    			div4 = element("div");
    			div2 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			defs0 = svg_element("defs");
    			linearGradient0 = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			t3 = space();
    			div3 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t4 = space();
    			div21 = element("div");
    			div20 = element("div");
    			div13 = element("div");
    			div6 = element("div");
    			div6.textContent = "You contribute to Green Safe";
    			t6 = space();
    			div10 = element("div");
    			div9 = element("div");
    			svg2 = svg_element("svg");
    			path2 = svg_element("path");
    			t7 = space();
    			div7 = element("div");
    			t8 = text(t8_value);
    			t9 = text("% Total Contribution");
    			t10 = space();
    			div8 = element("div");

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t11 = space();
    			div12 = element("div");
    			div11 = element("div");
    			t12 = text(t12_value);
    			t13 = space();
    			div16 = element("div");
    			div14 = element("div");
    			div14.textContent = "Green Safe";
    			t15 = space();
    			div15 = element("div");
    			div15.textContent = "Safe as a bank account. This fund invests exclusively in green bonds\r\n            and is the perfect option for Green Savers who want to be sure their\r\n            funds are secure. The Green Safe plan involves a commitment to\r\n            institutional and governmental bonds and enables subscribers to have\r\n            a global, national, and local impact.";
    			t17 = space();
    			div19 = element("div");
    			div17 = element("div");
    			div17.textContent = "Portfolio";
    			t19 = space();
    			ul0 = element("ul");
    			li0 = element("li");
    			li0.textContent = "50% international green bonds";
    			t21 = space();
    			li1 = element("li");
    			li1.textContent = "25% national green bonds";
    			t23 = space();
    			li2 = element("li");
    			li2.textContent = "25% municipal or provincial green bonds*";
    			t25 = space();
    			div18 = element("div");
    			div18.textContent = "*depending on availability and contribution size";
    			t27 = space();
    			create_component(planbtn0.$$.fragment);
    			t28 = space();
    			div45 = element("div");
    			div28 = element("div");
    			div24 = element("div");
    			img1 = element("img");
    			t29 = space();
    			div23 = element("div");
    			div23.textContent = "Select GREEN Adventure";
    			t31 = space();
    			div27 = element("div");
    			div25 = element("div");
    			svg3 = svg_element("svg");
    			path3 = svg_element("path");
    			defs1 = svg_element("defs");
    			linearGradient1 = svg_element("linearGradient");
    			stop2 = svg_element("stop");
    			stop3 = svg_element("stop");
    			t32 = space();
    			div26 = element("div");
    			svg4 = svg_element("svg");
    			path4 = svg_element("path");
    			t33 = space();
    			div44 = element("div");
    			div43 = element("div");
    			div36 = element("div");
    			div29 = element("div");
    			div29.textContent = "You contribute to Green Safe";
    			t35 = space();
    			div33 = element("div");
    			div32 = element("div");
    			svg5 = svg_element("svg");
    			path5 = svg_element("path");
    			t36 = space();
    			div30 = element("div");
    			t37 = text(t37_value);
    			t38 = text("% Total Contribution");
    			t39 = space();
    			div31 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t40 = space();
    			div35 = element("div");
    			div34 = element("div");
    			t41 = text(t41_value);
    			t42 = space();
    			div39 = element("div");
    			div37 = element("div");
    			div37.textContent = "Green Adventure";
    			t44 = space();
    			div38 = element("div");
    			div38.textContent = "A growth fund with more risks and more rewards. The Green Adventure\r\n            plan is for Green Savers who want to put their funds toward ventures\r\n            that have a significantly more direct impact on mitigating climate\r\n            change and are devoted to creating and developing green businesses\r\n            around the world. The plan also includes investments in green\r\n            equities to reward companies that already make a difference and an\r\n            activism investment fund for pressuring companies to become green.";
    			t46 = space();
    			div42 = element("div");
    			div40 = element("div");
    			div40.textContent = "Portfolio";
    			t48 = space();
    			ul1 = element("ul");
    			li3 = element("li");
    			li3.textContent = "50% venture investment";
    			t50 = space();
    			li4 = element("li");
    			li4.textContent = "25% green stock";
    			t52 = space();
    			li5 = element("li");
    			li5.textContent = "25% green activism investment";
    			t54 = space();
    			div41 = element("div");
    			t55 = space();
    			create_component(planbtn1.$$.fragment);
    			t56 = space();
    			div68 = element("div");
    			div51 = element("div");
    			div47 = element("div");
    			img2 = element("img");
    			t57 = space();
    			div46 = element("div");
    			div46.textContent = "Green Founder";
    			t59 = space();
    			div50 = element("div");
    			div48 = element("div");
    			svg6 = svg_element("svg");
    			path6 = svg_element("path");
    			defs2 = svg_element("defs");
    			linearGradient2 = svg_element("linearGradient");
    			stop4 = svg_element("stop");
    			stop5 = svg_element("stop");
    			t60 = space();
    			div49 = element("div");
    			svg7 = svg_element("svg");
    			path7 = svg_element("path");
    			t61 = space();
    			div67 = element("div");
    			div66 = element("div");
    			div59 = element("div");
    			div52 = element("div");
    			div52.textContent = "You contribute to Green Safe";
    			t63 = space();
    			div56 = element("div");
    			div55 = element("div");
    			svg8 = svg_element("svg");
    			path8 = svg_element("path");
    			t64 = space();
    			div53 = element("div");
    			t65 = text(t65_value);
    			t66 = text("% Total Contribution");
    			t67 = space();
    			div54 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t68 = space();
    			div58 = element("div");
    			div57 = element("div");
    			t69 = text(t69_value);
    			t70 = space();
    			div62 = element("div");
    			div60 = element("div");
    			div60.textContent = "Green Change";
    			t72 = space();
    			div61 = element("div");
    			div61.textContent = "The ESi future is green, and we want YOU to be part of it. Becoming\r\n            a founder Green Saver involves owning part of ESi. This option is\r\n            limited to a predetermined target, and you will own a portion of ESi\r\n            based on your contribution up to a collective 35% of ESi capital.\r\n            Our vision is to create a sustainable green finance ecosystem making\r\n            ethical green investing accessible. Collectively, we plan to become\r\n            the most prominent green investor and green financial product\r\n            provider.";
    			t74 = space();
    			div65 = element("div");
    			div63 = element("div");
    			div63.textContent = "Portfolio";
    			t76 = space();
    			ul2 = element("ul");
    			li6 = element("li");
    			li6.textContent = "100% invest in ESi capital";
    			t78 = space();
    			div64 = element("div");
    			div64.textContent = "*Limited offer of 150K shares at 20$ per share for 35% equity stake";
    			t80 = space();
    			create_component(planbtn2.$$.fragment);
    			attr_dev(img0, "class", "plan__icon svelte-w0dult");
    			if (!src_url_equal(img0.src, img0_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/627e4841370604453befc5d7_green.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			add_location(img0, file$p, 122, 8, 4832);
    			attr_dev(div0, "class", "item__head__name svelte-w0dult");
    			add_location(div0, file$p, 128, 8, 5017);
    			attr_dev(div1, "class", "column svelte-w0dult");
    			add_location(div1, file$p, 121, 6, 4802);
    			attr_dev(path0, "d", "M7.08286 13.8212L3.92203 10.6604C3.76486 10.5086 3.55436 10.4246 3.33586 10.4265C3.11736 10.4284 2.90835 10.516 2.75384 10.6705C2.59934 10.825 2.5117 11.034 2.5098 11.2525C2.5079 11.471 2.59189 11.6815 2.74369 11.8387L6.49369 15.5887C6.64997 15.7449 6.86189 15.8327 7.08286 15.8327C7.30383 15.8327 7.51575 15.7449 7.67203 15.5887L16.8387 6.42203C16.9905 6.26486 17.0745 6.05436 17.0726 5.83586C17.0707 5.61736 16.983 5.40835 16.8285 5.25384C16.674 5.09934 16.465 5.0117 16.2465 5.0098C16.028 5.0079 15.8175 5.09189 15.6604 5.24369L7.08286 13.8212Z");
    			attr_dev(path0, "fill", "url(#paint0_linear_2960_1067)");
    			add_location(path0, file$p, 140, 12, 5417);
    			attr_dev(stop0, "stop-color", "#FF2E00");
    			add_location(stop0, file$p, 153, 16, 6357);
    			attr_dev(stop1, "offset", "1");
    			attr_dev(stop1, "stop-color", "#FF6B00");
    			add_location(stop1, file$p, 154, 16, 6404);
    			attr_dev(linearGradient0, "id", "paint0_linear_2960_1067");
    			attr_dev(linearGradient0, "x1", "17.0726");
    			attr_dev(linearGradient0, "y1", "5.00977");
    			attr_dev(linearGradient0, "x2", "1.10357");
    			attr_dev(linearGradient0, "y2", "13.0343");
    			attr_dev(linearGradient0, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient0, file$p, 145, 14, 6093);
    			add_location(defs0, file$p, 144, 12, 6071);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "20");
    			attr_dev(svg0, "height", "20");
    			attr_dev(svg0, "viewBox", "0 0 20 20");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svelte-w0dult");
    			toggle_class(svg0, "visible", /*$allocatedContributions*/ ctx[1].safe != 0);
    			add_location(svg0, file$p, 132, 10, 5168);
    			attr_dev(div2, "class", "item__head__checkbox svelte-w0dult");
    			add_location(div2, file$p, 131, 8, 5122);
    			attr_dev(path1, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path1, "fill", "white");
    			add_location(path1, file$p, 167, 13, 6779);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "16");
    			attr_dev(svg1, "height", "16");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "arrow");
    			add_location(svg1, file$p, 160, 10, 6578);
    			attr_dev(div3, "class", "mob__arrow svelte-w0dult");
    			add_location(div3, file$p, 159, 8, 6542);
    			attr_dev(div4, "class", "column svelte-w0dult");
    			add_location(div4, file$p, 130, 6, 5092);
    			attr_dev(div5, "class", "item__head svelte-w0dult");
    			add_location(div5, file$p, 116, 4, 4663);
    			attr_dev(div6, "class", "item__top__head svelte-w0dult");
    			add_location(div6, file$p, 178, 10, 7721);
    			attr_dev(path2, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path2, "fill", "#032B01");
    			attr_dev(path2, "class", "svelte-w0dult");
    			add_location(path2, file$p, 193, 16, 8294);
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "width", "24");
    			attr_dev(svg2, "height", "24");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "class", "svelte-w0dult");
    			add_location(svg2, file$p, 186, 14, 8080);
    			attr_dev(div7, "class", "dropdown__item--current svelte-w0dult");
    			add_location(div7, file$p, 198, 14, 9140);
    			attr_dev(div8, "class", "dropdown__items svelte-w0dult");
    			add_location(div8, file$p, 201, 14, 9283);
    			attr_dev(div9, "class", "dropdown svelte-w0dult");
    			toggle_class(div9, "activeDropdownSave", /*activeDropdownSave*/ ctx[5]);
    			add_location(div9, file$p, 181, 12, 7898);
    			attr_dev(div10, "class", "dropdown__wrapper svelte-w0dult");
    			toggle_class(div10, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			add_location(div10, file$p, 179, 10, 7796);
    			attr_dev(div11, "class", "money svelte-w0dult");
    			add_location(div11, file$p, 218, 12, 9977);
    			attr_dev(div12, "class", "item__current__money safe svelte-w0dult");
    			add_location(div12, file$p, 217, 10, 9924);
    			attr_dev(div13, "class", "item__top svelte-w0dult");
    			add_location(div13, file$p, 177, 8, 7686);
    			attr_dev(div14, "class", "plan__info__head svelte-w0dult");
    			add_location(div14, file$p, 225, 10, 10177);
    			attr_dev(div15, "class", "plan__info__text svelte-w0dult");
    			add_location(div15, file$p, 226, 10, 10235);
    			attr_dev(div16, "class", "mob__plan__info svelte-w0dult");
    			add_location(div16, file$p, 224, 8, 10136);
    			attr_dev(div17, "class", "portfolio__head svelte-w0dult");
    			add_location(div17, file$p, 235, 10, 10717);
    			attr_dev(li0, "class", "svelte-w0dult");
    			add_location(li0, file$p, 237, 12, 10791);
    			attr_dev(li1, "class", "svelte-w0dult");
    			add_location(li1, file$p, 238, 12, 10843);
    			attr_dev(li2, "class", "svelte-w0dult");
    			add_location(li2, file$p, 239, 12, 10890);
    			attr_dev(ul0, "class", "svelte-w0dult");
    			add_location(ul0, file$p, 236, 10, 10773);
    			attr_dev(div18, "class", "portfolio__heler svelte-w0dult");
    			add_location(div18, file$p, 241, 10, 10968);
    			attr_dev(div19, "class", "portfolio svelte-w0dult");
    			add_location(div19, file$p, 234, 8, 10682);
    			add_location(div20, file$p, 176, 6, 7671);
    			attr_dev(div21, "class", "item__body svelte-w0dult");
    			add_location(div21, file$p, 175, 4, 7639);
    			attr_dev(div22, "class", "plans__item save svelte-w0dult");
    			toggle_class(div22, "active", /*current*/ ctx[8] === /*savePlan*/ ctx[12]);
    			add_location(div22, file$p, 115, 2, 4591);
    			if (!src_url_equal(img1.src, img1_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/627e4bde122aa36a24438411_tab-icon-02.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "class", "plan__icon svelte-w0dult");
    			add_location(img1, file$p, 260, 8, 11524);
    			attr_dev(div23, "class", "item__head__name svelte-w0dult");
    			add_location(div23, file$p, 265, 8, 11713);
    			attr_dev(div24, "class", "column svelte-w0dult");
    			add_location(div24, file$p, 259, 6, 11494);
    			attr_dev(path3, "d", "M7.08286 13.8212L3.92203 10.6604C3.76486 10.5086 3.55436 10.4246 3.33586 10.4265C3.11736 10.4284 2.90835 10.516 2.75384 10.6705C2.59934 10.825 2.5117 11.034 2.5098 11.2525C2.5079 11.471 2.59189 11.6815 2.74369 11.8387L6.49369 15.5887C6.64997 15.7449 6.86189 15.8327 7.08286 15.8327C7.30383 15.8327 7.51575 15.7449 7.67203 15.5887L16.8387 6.42203C16.9905 6.26486 17.0745 6.05436 17.0726 5.83586C17.0707 5.61736 16.983 5.40835 16.8285 5.25384C16.674 5.09934 16.465 5.0117 16.2465 5.0098C16.028 5.0079 15.8175 5.09189 15.6604 5.24369L7.08286 13.8212Z");
    			attr_dev(path3, "fill", "url(#paint0_linear_2960_1067)");
    			add_location(path3, file$p, 277, 12, 12123);
    			attr_dev(stop2, "stop-color", "#FF2E00");
    			add_location(stop2, file$p, 290, 16, 13063);
    			attr_dev(stop3, "offset", "1");
    			attr_dev(stop3, "stop-color", "#FF6B00");
    			add_location(stop3, file$p, 291, 16, 13110);
    			attr_dev(linearGradient1, "id", "paint0_linear_2960_1067");
    			attr_dev(linearGradient1, "x1", "17.0726");
    			attr_dev(linearGradient1, "y1", "5.00977");
    			attr_dev(linearGradient1, "x2", "1.10357");
    			attr_dev(linearGradient1, "y2", "13.0343");
    			attr_dev(linearGradient1, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient1, file$p, 282, 14, 12799);
    			add_location(defs1, file$p, 281, 12, 12777);
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "width", "20");
    			attr_dev(svg3, "height", "20");
    			attr_dev(svg3, "viewBox", "0 0 20 20");
    			attr_dev(svg3, "fill", "none");
    			attr_dev(svg3, "class", "svelte-w0dult");
    			toggle_class(svg3, "visible", /*$allocatedContributions*/ ctx[1].adventure != 0);
    			add_location(svg3, file$p, 269, 10, 11869);
    			attr_dev(div25, "class", "item__head__checkbox svelte-w0dult");
    			add_location(div25, file$p, 268, 8, 11823);
    			attr_dev(path4, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path4, "fill", "white");
    			add_location(path4, file$p, 304, 13, 13485);
    			attr_dev(svg4, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg4, "width", "16");
    			attr_dev(svg4, "height", "16");
    			attr_dev(svg4, "viewBox", "0 0 24 24");
    			attr_dev(svg4, "fill", "none");
    			attr_dev(svg4, "class", "arrow");
    			add_location(svg4, file$p, 297, 10, 13284);
    			attr_dev(div26, "class", "mob__arrow svelte-w0dult");
    			add_location(div26, file$p, 296, 8, 13248);
    			attr_dev(div27, "class", "column svelte-w0dult");
    			add_location(div27, file$p, 267, 6, 11793);
    			attr_dev(div28, "class", "item__head svelte-w0dult");
    			add_location(div28, file$p, 254, 4, 11357);
    			attr_dev(div29, "class", "item__top__head svelte-w0dult");
    			add_location(div29, file$p, 315, 10, 14427);
    			attr_dev(path5, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path5, "fill", "#032B01");
    			attr_dev(path5, "class", "svelte-w0dult");
    			add_location(path5, file$p, 330, 16, 14997);
    			attr_dev(svg5, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg5, "width", "24");
    			attr_dev(svg5, "height", "24");
    			attr_dev(svg5, "viewBox", "0 0 24 24");
    			attr_dev(svg5, "fill", "none");
    			attr_dev(svg5, "class", "svelte-w0dult");
    			add_location(svg5, file$p, 323, 14, 14783);
    			attr_dev(div30, "class", "dropdown__item--current svelte-w0dult");
    			add_location(div30, file$p, 335, 14, 15843);
    			attr_dev(div31, "class", "dropdown__items svelte-w0dult");
    			add_location(div31, file$p, 338, 14, 15991);
    			attr_dev(div32, "class", "dropdown svelte-w0dult");
    			toggle_class(div32, "activeDropdownAdv", /*activeDropdownAdv*/ ctx[6]);
    			add_location(div32, file$p, 318, 12, 14604);
    			attr_dev(div33, "class", "dropdown__wrapper svelte-w0dult");
    			toggle_class(div33, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			add_location(div33, file$p, 316, 10, 14502);
    			attr_dev(div34, "class", "money svelte-w0dult");
    			add_location(div34, file$p, 356, 12, 16698);
    			attr_dev(div35, "class", "item__current__money adventure svelte-w0dult");
    			add_location(div35, file$p, 354, 10, 16636);
    			attr_dev(div36, "class", "item__top svelte-w0dult");
    			add_location(div36, file$p, 314, 8, 14392);
    			attr_dev(div37, "class", "plan__info__head svelte-w0dult");
    			add_location(div37, file$p, 362, 10, 16901);
    			attr_dev(div38, "class", "plan__info__text svelte-w0dult");
    			add_location(div38, file$p, 363, 10, 16964);
    			attr_dev(div39, "class", "mob__plan__info svelte-w0dult");
    			add_location(div39, file$p, 361, 8, 16860);
    			attr_dev(div40, "class", "portfolio__head svelte-w0dult");
    			add_location(div40, file$p, 374, 10, 17631);
    			attr_dev(li3, "class", "svelte-w0dult");
    			add_location(li3, file$p, 376, 12, 17705);
    			attr_dev(li4, "class", "svelte-w0dult");
    			add_location(li4, file$p, 377, 12, 17750);
    			attr_dev(li5, "class", "svelte-w0dult");
    			add_location(li5, file$p, 378, 12, 17788);
    			attr_dev(ul1, "class", "svelte-w0dult");
    			add_location(ul1, file$p, 375, 10, 17687);
    			attr_dev(div41, "class", "portfolio__heler svelte-w0dult");
    			add_location(div41, file$p, 380, 10, 17855);
    			attr_dev(div42, "class", "portfolio svelte-w0dult");
    			add_location(div42, file$p, 373, 8, 17596);
    			add_location(div43, file$p, 313, 6, 14377);
    			attr_dev(div44, "class", "item__body svelte-w0dult");
    			add_location(div44, file$p, 312, 4, 14345);
    			attr_dev(div45, "class", "plans__item adventure svelte-w0dult");
    			toggle_class(div45, "active", /*current*/ ctx[8] === /*advPlan*/ ctx[13]);
    			add_location(div45, file$p, 253, 2, 11281);
    			if (!src_url_equal(img2.src, img2_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/627e4be882a78868831022d1_founder.svg")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "");
    			attr_dev(img2, "class", "plan__icon svelte-w0dult");
    			add_location(img2, file$p, 397, 8, 18342);
    			attr_dev(div46, "class", "item__head__name svelte-w0dult");
    			add_location(div46, file$p, 402, 8, 18527);
    			attr_dev(div47, "class", "column svelte-w0dult");
    			add_location(div47, file$p, 396, 6, 18312);
    			attr_dev(path6, "d", "M7.08286 13.8212L3.92203 10.6604C3.76486 10.5086 3.55436 10.4246 3.33586 10.4265C3.11736 10.4284 2.90835 10.516 2.75384 10.6705C2.59934 10.825 2.5117 11.034 2.5098 11.2525C2.5079 11.471 2.59189 11.6815 2.74369 11.8387L6.49369 15.5887C6.64997 15.7449 6.86189 15.8327 7.08286 15.8327C7.30383 15.8327 7.51575 15.7449 7.67203 15.5887L16.8387 6.42203C16.9905 6.26486 17.0745 6.05436 17.0726 5.83586C17.0707 5.61736 16.983 5.40835 16.8285 5.25384C16.674 5.09934 16.465 5.0117 16.2465 5.0098C16.028 5.0079 15.8175 5.09189 15.6604 5.24369L7.08286 13.8212Z");
    			attr_dev(path6, "fill", "url(#paint0_linear_2960_1067)");
    			add_location(path6, file$p, 414, 12, 18926);
    			attr_dev(stop4, "stop-color", "#FF2E00");
    			add_location(stop4, file$p, 427, 16, 19866);
    			attr_dev(stop5, "offset", "1");
    			attr_dev(stop5, "stop-color", "#FF6B00");
    			add_location(stop5, file$p, 428, 16, 19913);
    			attr_dev(linearGradient2, "id", "paint0_linear_2960_1067");
    			attr_dev(linearGradient2, "x1", "17.0726");
    			attr_dev(linearGradient2, "y1", "5.00977");
    			attr_dev(linearGradient2, "x2", "1.10357");
    			attr_dev(linearGradient2, "y2", "13.0343");
    			attr_dev(linearGradient2, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient2, file$p, 419, 14, 19602);
    			add_location(defs2, file$p, 418, 12, 19580);
    			attr_dev(svg6, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg6, "width", "20");
    			attr_dev(svg6, "height", "20");
    			attr_dev(svg6, "viewBox", "0 0 20 20");
    			attr_dev(svg6, "fill", "none");
    			attr_dev(svg6, "class", "svelte-w0dult");
    			toggle_class(svg6, "visible", /*$allocatedContributions*/ ctx[1].founder != 0);
    			add_location(svg6, file$p, 406, 10, 18674);
    			attr_dev(div48, "class", "item__head__checkbox svelte-w0dult");
    			add_location(div48, file$p, 405, 8, 18628);
    			attr_dev(path7, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path7, "fill", "white");
    			add_location(path7, file$p, 441, 13, 20288);
    			attr_dev(svg7, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg7, "width", "16");
    			attr_dev(svg7, "height", "16");
    			attr_dev(svg7, "viewBox", "0 0 24 24");
    			attr_dev(svg7, "fill", "none");
    			attr_dev(svg7, "class", "arrow");
    			add_location(svg7, file$p, 434, 10, 20087);
    			attr_dev(div49, "class", "mob__arrow svelte-w0dult");
    			add_location(div49, file$p, 433, 8, 20051);
    			attr_dev(div50, "class", "column svelte-w0dult");
    			add_location(div50, file$p, 404, 6, 18598);
    			attr_dev(div51, "class", "item__head svelte-w0dult");
    			add_location(div51, file$p, 391, 4, 18171);
    			attr_dev(div52, "class", "item__top__head svelte-w0dult");
    			add_location(div52, file$p, 452, 10, 21230);
    			attr_dev(path8, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path8, "fill", "#032B01");
    			attr_dev(path8, "class", "svelte-w0dult");
    			add_location(path8, file$p, 469, 16, 21833);
    			attr_dev(svg8, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg8, "width", "24");
    			attr_dev(svg8, "height", "24");
    			attr_dev(svg8, "viewBox", "0 0 24 24");
    			attr_dev(svg8, "fill", "none");
    			attr_dev(svg8, "class", "svelte-w0dult");
    			add_location(svg8, file$p, 462, 14, 21619);
    			attr_dev(div53, "class", "dropdown__item--current svelte-w0dult");
    			add_location(div53, file$p, 474, 14, 22679);
    			attr_dev(div54, "class", "dropdown__items svelte-w0dult");
    			add_location(div54, file$p, 477, 14, 22825);
    			attr_dev(div55, "class", "dropdown svelte-w0dult");
    			toggle_class(div55, "activeDropdownFound", /*activeDropdownFound*/ ctx[7]);
    			add_location(div55, file$p, 457, 12, 21434);
    			attr_dev(div56, "class", "dropdown__wrapper svelte-w0dult");
    			toggle_class(div56, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			add_location(div56, file$p, 453, 10, 21305);
    			attr_dev(div57, "class", "money svelte-w0dult");
    			add_location(div57, file$p, 497, 12, 23589);
    			attr_dev(div58, "class", "item__current__money founder svelte-w0dult");
    			add_location(div58, file$p, 495, 10, 23519);
    			attr_dev(div59, "class", "item__top svelte-w0dult");
    			add_location(div59, file$p, 451, 8, 21195);
    			attr_dev(div60, "class", "plan__info__head svelte-w0dult");
    			add_location(div60, file$p, 503, 10, 23790);
    			attr_dev(div61, "class", "plan__info__text svelte-w0dult");
    			add_location(div61, file$p, 504, 10, 23850);
    			attr_dev(div62, "class", "mob__plan__info svelte-w0dult");
    			add_location(div62, file$p, 502, 8, 23749);
    			attr_dev(div63, "class", "portfolio__head svelte-w0dult");
    			add_location(div63, file$p, 516, 10, 24541);
    			attr_dev(li6, "class", "svelte-w0dult");
    			add_location(li6, file$p, 518, 12, 24615);
    			attr_dev(ul2, "class", "svelte-w0dult");
    			add_location(ul2, file$p, 517, 10, 24597);
    			attr_dev(div64, "class", "portfolio__heler svelte-w0dult");
    			add_location(div64, file$p, 520, 10, 24679);
    			attr_dev(div65, "class", "portfolio svelte-w0dult");
    			add_location(div65, file$p, 515, 8, 24506);
    			add_location(div66, file$p, 450, 6, 21180);
    			attr_dev(div67, "class", "item__body svelte-w0dult");
    			add_location(div67, file$p, 449, 4, 21148);
    			attr_dev(div68, "class", "plans__item founder svelte-w0dult");
    			toggle_class(div68, "active", /*current*/ ctx[8] === /*foundPlan*/ ctx[14]);
    			add_location(div68, file$p, 390, 2, 18095);
    			attr_dev(div69, "class", "plans__items svelte-w0dult");
    			add_location(div69, file$p, 114, 0, 4561);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div69, anchor);
    			append_dev(div69, div22);
    			append_dev(div22, div5);
    			append_dev(div5, div1);
    			append_dev(div1, img0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div5, t2);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, defs0);
    			append_dev(defs0, linearGradient0);
    			append_dev(linearGradient0, stop0);
    			append_dev(linearGradient0, stop1);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, svg1);
    			append_dev(svg1, path1);
    			append_dev(div22, t4);
    			append_dev(div22, div21);
    			append_dev(div21, div20);
    			append_dev(div20, div13);
    			append_dev(div13, div6);
    			append_dev(div13, t6);
    			append_dev(div13, div10);
    			append_dev(div10, div9);
    			append_dev(div9, svg2);
    			append_dev(svg2, path2);
    			append_dev(div9, t7);
    			append_dev(div9, div7);
    			append_dev(div7, t8);
    			append_dev(div7, t9);
    			append_dev(div9, t10);
    			append_dev(div9, div8);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(div8, null);
    			}

    			append_dev(div13, t11);
    			append_dev(div13, div12);
    			append_dev(div12, div11);
    			append_dev(div11, t12);
    			append_dev(div20, t13);
    			append_dev(div20, div16);
    			append_dev(div16, div14);
    			append_dev(div16, t15);
    			append_dev(div16, div15);
    			append_dev(div20, t17);
    			append_dev(div20, div19);
    			append_dev(div19, div17);
    			append_dev(div19, t19);
    			append_dev(div19, ul0);
    			append_dev(ul0, li0);
    			append_dev(ul0, t21);
    			append_dev(ul0, li1);
    			append_dev(ul0, t23);
    			append_dev(ul0, li2);
    			append_dev(div19, t25);
    			append_dev(div19, div18);
    			append_dev(div20, t27);
    			mount_component(planbtn0, div20, null);
    			append_dev(div69, t28);
    			append_dev(div69, div45);
    			append_dev(div45, div28);
    			append_dev(div28, div24);
    			append_dev(div24, img1);
    			append_dev(div24, t29);
    			append_dev(div24, div23);
    			append_dev(div28, t31);
    			append_dev(div28, div27);
    			append_dev(div27, div25);
    			append_dev(div25, svg3);
    			append_dev(svg3, path3);
    			append_dev(svg3, defs1);
    			append_dev(defs1, linearGradient1);
    			append_dev(linearGradient1, stop2);
    			append_dev(linearGradient1, stop3);
    			append_dev(div27, t32);
    			append_dev(div27, div26);
    			append_dev(div26, svg4);
    			append_dev(svg4, path4);
    			append_dev(div45, t33);
    			append_dev(div45, div44);
    			append_dev(div44, div43);
    			append_dev(div43, div36);
    			append_dev(div36, div29);
    			append_dev(div36, t35);
    			append_dev(div36, div33);
    			append_dev(div33, div32);
    			append_dev(div32, svg5);
    			append_dev(svg5, path5);
    			append_dev(div32, t36);
    			append_dev(div32, div30);
    			append_dev(div30, t37);
    			append_dev(div30, t38);
    			append_dev(div32, t39);
    			append_dev(div32, div31);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div31, null);
    			}

    			append_dev(div36, t40);
    			append_dev(div36, div35);
    			append_dev(div35, div34);
    			append_dev(div34, t41);
    			append_dev(div43, t42);
    			append_dev(div43, div39);
    			append_dev(div39, div37);
    			append_dev(div39, t44);
    			append_dev(div39, div38);
    			append_dev(div43, t46);
    			append_dev(div43, div42);
    			append_dev(div42, div40);
    			append_dev(div42, t48);
    			append_dev(div42, ul1);
    			append_dev(ul1, li3);
    			append_dev(ul1, t50);
    			append_dev(ul1, li4);
    			append_dev(ul1, t52);
    			append_dev(ul1, li5);
    			append_dev(div42, t54);
    			append_dev(div42, div41);
    			append_dev(div43, t55);
    			mount_component(planbtn1, div43, null);
    			append_dev(div69, t56);
    			append_dev(div69, div68);
    			append_dev(div68, div51);
    			append_dev(div51, div47);
    			append_dev(div47, img2);
    			append_dev(div47, t57);
    			append_dev(div47, div46);
    			append_dev(div51, t59);
    			append_dev(div51, div50);
    			append_dev(div50, div48);
    			append_dev(div48, svg6);
    			append_dev(svg6, path6);
    			append_dev(svg6, defs2);
    			append_dev(defs2, linearGradient2);
    			append_dev(linearGradient2, stop4);
    			append_dev(linearGradient2, stop5);
    			append_dev(div50, t60);
    			append_dev(div50, div49);
    			append_dev(div49, svg7);
    			append_dev(svg7, path7);
    			append_dev(div68, t61);
    			append_dev(div68, div67);
    			append_dev(div67, div66);
    			append_dev(div66, div59);
    			append_dev(div59, div52);
    			append_dev(div59, t63);
    			append_dev(div59, div56);
    			append_dev(div56, div55);
    			append_dev(div55, svg8);
    			append_dev(svg8, path8);
    			append_dev(div55, t64);
    			append_dev(div55, div53);
    			append_dev(div53, t65);
    			append_dev(div53, t66);
    			append_dev(div55, t67);
    			append_dev(div55, div54);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div54, null);
    			}

    			append_dev(div59, t68);
    			append_dev(div59, div58);
    			append_dev(div58, div57);
    			append_dev(div57, t69);
    			append_dev(div66, t70);
    			append_dev(div66, div62);
    			append_dev(div62, div60);
    			append_dev(div62, t72);
    			append_dev(div62, div61);
    			append_dev(div66, t74);
    			append_dev(div66, div65);
    			append_dev(div65, div63);
    			append_dev(div65, t76);
    			append_dev(div65, ul2);
    			append_dev(ul2, li6);
    			append_dev(div65, t78);
    			append_dev(div65, div64);
    			append_dev(div66, t80);
    			mount_component(planbtn2, div66, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div5, "click", /*click_handler*/ ctx[17], false, false, false),
    					listen_dev(div9, "click", /*click_handler_2*/ ctx[19], false, false, false),
    					listen_dev(div28, "click", /*click_handler_4*/ ctx[21], false, false, false),
    					listen_dev(div32, "click", /*click_handler_6*/ ctx[23], false, false, false),
    					listen_dev(div51, "click", /*click_handler_8*/ ctx[25], false, false, false),
    					listen_dev(div55, "click", /*click_handler_10*/ ctx[27], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$allocatedContributions*/ 2) {
    				toggle_class(svg0, "visible", /*$allocatedContributions*/ ctx[1].safe != 0);
    			}

    			if ((!current || dirty[0] & /*$allocatedContributions*/ 2) && t8_value !== (t8_value = /*$allocatedContributions*/ ctx[1].safe + "")) set_data_dev(t8, t8_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions, setPercentage, savePlan*/ 37379) {
    				each_value_2 = /*savePercentages*/ ctx[0];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(div8, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty[0] & /*activeDropdownSave*/ 32) {
    				toggle_class(div9, "activeDropdownSave", /*activeDropdownSave*/ ctx[5]);
    			}

    			if (dirty[0] & /*$disableAllDropdown*/ 1024) {
    				toggle_class(div10, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			}

    			if ((!current || dirty[0] & /*$contributionData, safePrice*/ 2052) && t12_value !== (t12_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*safePrice*/ ctx[2]) + "")) set_data_dev(t12, t12_value);

    			if (dirty[0] & /*current, savePlan*/ 4352) {
    				toggle_class(div22, "active", /*current*/ ctx[8] === /*savePlan*/ ctx[12]);
    			}

    			if (dirty[0] & /*$allocatedContributions*/ 2) {
    				toggle_class(svg3, "visible", /*$allocatedContributions*/ ctx[1].adventure != 0);
    			}

    			if ((!current || dirty[0] & /*$allocatedContributions*/ 2) && t37_value !== (t37_value = /*$allocatedContributions*/ ctx[1].adventure + "")) set_data_dev(t37, t37_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions, setPercentage, advPlan*/ 41475) {
    				each_value_1 = /*savePercentages*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div31, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty[0] & /*activeDropdownAdv*/ 64) {
    				toggle_class(div32, "activeDropdownAdv", /*activeDropdownAdv*/ ctx[6]);
    			}

    			if (dirty[0] & /*$disableAllDropdown*/ 1024) {
    				toggle_class(div33, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			}

    			if ((!current || dirty[0] & /*$contributionData, adventurePrice*/ 2056) && t41_value !== (t41_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*adventurePrice*/ ctx[3]) + "")) set_data_dev(t41, t41_value);

    			if (dirty[0] & /*current, advPlan*/ 8448) {
    				toggle_class(div45, "active", /*current*/ ctx[8] === /*advPlan*/ ctx[13]);
    			}

    			if (dirty[0] & /*$allocatedContributions*/ 2) {
    				toggle_class(svg6, "visible", /*$allocatedContributions*/ ctx[1].founder != 0);
    			}

    			if ((!current || dirty[0] & /*$allocatedContributions*/ 2) && t65_value !== (t65_value = /*$allocatedContributions*/ ctx[1].founder + "")) set_data_dev(t65, t65_value);

    			if (dirty[0] & /*savePercentages, allowPercentageVal, $allocatedContributions, setPercentage, foundPlan*/ 49667) {
    				each_value = /*savePercentages*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div54, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*activeDropdownFound*/ 128) {
    				toggle_class(div55, "activeDropdownFound", /*activeDropdownFound*/ ctx[7]);
    			}

    			if (dirty[0] & /*$disableAllDropdown*/ 1024) {
    				toggle_class(div56, "disabled", /*$disableAllDropdown*/ ctx[10] === true);
    			}

    			if ((!current || dirty[0] & /*$contributionData, founderPrice*/ 2064) && t69_value !== (t69_value = /*$contributionData*/ ctx[11].currencySymbol + Math.round(/*founderPrice*/ ctx[4]) + "")) set_data_dev(t69, t69_value);

    			if (dirty[0] & /*current, foundPlan*/ 16640) {
    				toggle_class(div68, "active", /*current*/ ctx[8] === /*foundPlan*/ ctx[14]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(planbtn0.$$.fragment, local);
    			transition_in(planbtn1.$$.fragment, local);
    			transition_in(planbtn2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(planbtn0.$$.fragment, local);
    			transition_out(planbtn1.$$.fragment, local);
    			transition_out(planbtn2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div69);
    			destroy_each(each_blocks_2, detaching);
    			destroy_component(planbtn0);
    			destroy_each(each_blocks_1, detaching);
    			destroy_component(planbtn1);
    			destroy_each(each_blocks, detaching);
    			destroy_component(planbtn2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let allowPercentageVal;
    	let $plansModalState;
    	let $plansModalData;
    	let $allocatedContributions;
    	let $subscribeAllState;
    	let $sortPersantageVariable;
    	let $disableAllDropdown;
    	let $contributionData;
    	validate_store(plansModalState, 'plansModalState');
    	component_subscribe($$self, plansModalState, $$value => $$invalidate(29, $plansModalState = $$value));
    	validate_store(plansModalData, 'plansModalData');
    	component_subscribe($$self, plansModalData, $$value => $$invalidate(30, $plansModalData = $$value));
    	validate_store(allocatedContributions, 'allocatedContributions');
    	component_subscribe($$self, allocatedContributions, $$value => $$invalidate(1, $allocatedContributions = $$value));
    	validate_store(subscribeAllState, 'subscribeAllState');
    	component_subscribe($$self, subscribeAllState, $$value => $$invalidate(31, $subscribeAllState = $$value));
    	validate_store(sortPersantageVariable, 'sortPersantageVariable');
    	component_subscribe($$self, sortPersantageVariable, $$value => $$invalidate(32, $sortPersantageVariable = $$value));
    	validate_store(disableAllDropdown, 'disableAllDropdown');
    	component_subscribe($$self, disableAllDropdown, $$value => $$invalidate(10, $disableAllDropdown = $$value));
    	validate_store(contributionData, 'contributionData');
    	component_subscribe($$self, contributionData, $$value => $$invalidate(11, $contributionData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlanItems', slots, []);
    	let savePercentages;
    	savePercentages = [...planData];
    	let safePrice = 0, adventurePrice = 0, founderPrice = 0;
    	let savePlan = "safe", advPlan = "adv", foundPlan = "found";
    	let activeDropdownSave = false;
    	let activeDropdownAdv = false;
    	let activeDropdownFound = false;
    	let current = savePlan;

    	beforeUpdate(() => {
    		$$invalidate(2, safePrice = $allocatedContributions.safe * $contributionData.monthlyValue / 100);
    		$$invalidate(3, adventurePrice = $allocatedContributions.adventure * $contributionData.monthlyValue / 100);
    		$$invalidate(4, founderPrice = $allocatedContributions.founder * $contributionData.monthlyValue / 100);

    		if ($disableAllDropdown === true) {
    			$$invalidate(5, activeDropdownSave = false);
    			$$invalidate(6, activeDropdownAdv = false);
    			$$invalidate(7, activeDropdownFound = false);
    		}
    	});

    	afterUpdate(() => {
    		
    	});

    	function setPercentage(item, plan) {
    		if ($disableAllDropdown === false) {
    			set_store_value(sortPersantageVariable, $sortPersantageVariable = item.sortName, $sortPersantageVariable);
    			set_store_value(subscribeAllState, $subscribeAllState = false, $subscribeAllState);

    			switch (plan) {
    				case "safe":
    					set_store_value(allocatedContributions, $allocatedContributions.safe = item.persentage, $allocatedContributions);
    					set_store_value(allocatedContributions, $allocatedContributions.safeName = item.value, $allocatedContributions);
    					break;
    				case "adv":
    					set_store_value(allocatedContributions, $allocatedContributions.adventure = item.persentage, $allocatedContributions);
    					set_store_value(allocatedContributions, $allocatedContributions.adventureName = item.value, $allocatedContributions);
    					break;
    				case "found":
    					set_store_value(allocatedContributions, $allocatedContributions.founder = item.persentage, $allocatedContributions);
    					set_store_value(allocatedContributions, $allocatedContributions.founderName = item.value, $allocatedContributions);
    					break;
    				default:
    					console.log("Error");
    			}
    		}
    	}

    	function showModal(plan) {
    		switch (plan) {
    			case "safe":
    				set_store_value(plansModalData, $plansModalData.class = "safe", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.name = "Green Safe", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.desc = "Safe as a bank account. This fund invests exclusively in green bonds and is the perfect option for Green Savers who want to be sure their funds are secure. The Green Safe plan involves a commitment to institutional and governmental bonds and enables subscribers to have a global, national, and local impact.", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.lottie = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/6281f1b9694dfd538fae0ee3_Safe.json", $plansModalData);
    				break;
    			case "adv":
    				set_store_value(plansModalData, $plansModalData.class = "adventure", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.name = "Green Adventure", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.desc = "A growth fund with more risks and more rewards. The Green Adventure plan is for Green Savers who want to put their funds toward ventures that have a significantly more direct impact on mitigating climate change and are devoted to creating and developing green businesses around the world. The plan also includes investments in green equities to reward companies that already make a difference and an activism investment fund for pressuring companies to become green.", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.lottie = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/628203b9fca88d2dde5b697f_Adventure.json", $plansModalData);
    				break;
    			case "found":
    				set_store_value(plansModalData, $plansModalData.class = "founder", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.name = "Green Change", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.desc = "The ESi future is green, and we want YOU to be part of it. Becoming a founder Green Saver involves owning part of ESi. This option is limited to a predetermined target, and you will own a portion of ESi based on your contribution up to a collective 35% of ESi capital. Our vision is to create a sustainable green finance ecosystem making ethical green investing accessible. Collectively, we plan to become the most prominent green investor and green financial product provider.", $plansModalData);
    				set_store_value(plansModalData, $plansModalData.lottie = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/628203e11d51fd22eede66f3_Founder.json", $plansModalData);
    				break;
    			default:
    				console.log("Error");
    		}

    		set_store_value(plansModalState, $plansModalState = true, $plansModalState);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<PlanItems> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => current === savePlan
    	? $$invalidate(8, current = "")
    	: $$invalidate(8, current = savePlan);

    	const click_handler_1 = item => setPercentage(item, savePlan);
    	const click_handler_2 = () => $$invalidate(5, activeDropdownSave = !activeDropdownSave);
    	const click_handler_3 = () => showModal(savePlan);

    	const click_handler_4 = () => current === advPlan
    	? $$invalidate(8, current = "")
    	: $$invalidate(8, current = advPlan);

    	const click_handler_5 = item => setPercentage(item, advPlan);
    	const click_handler_6 = () => $$invalidate(6, activeDropdownAdv = !activeDropdownAdv);
    	const click_handler_7 = () => showModal(advPlan);

    	const click_handler_8 = () => current === foundPlan
    	? $$invalidate(8, current = "")
    	: $$invalidate(8, current = foundPlan);

    	const click_handler_9 = item => {
    		setPercentage(item, foundPlan);
    	};

    	const click_handler_10 = () => $$invalidate(7, activeDropdownFound = !activeDropdownFound);
    	const click_handler_11 = () => showModal(foundPlan);

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		afterUpdate,
    		subscribeAllState,
    		planData,
    		plansModalState,
    		plansModalData,
    		sortPersantageVariable,
    		disableAllDropdown,
    		contributionData,
    		allocatedContributions,
    		PlanBtn,
    		savePercentages,
    		safePrice,
    		adventurePrice,
    		founderPrice,
    		savePlan,
    		advPlan,
    		foundPlan,
    		activeDropdownSave,
    		activeDropdownAdv,
    		activeDropdownFound,
    		current,
    		setPercentage,
    		showModal,
    		allowPercentageVal,
    		$plansModalState,
    		$plansModalData,
    		$allocatedContributions,
    		$subscribeAllState,
    		$sortPersantageVariable,
    		$disableAllDropdown,
    		$contributionData
    	});

    	$$self.$inject_state = $$props => {
    		if ('savePercentages' in $$props) $$invalidate(0, savePercentages = $$props.savePercentages);
    		if ('safePrice' in $$props) $$invalidate(2, safePrice = $$props.safePrice);
    		if ('adventurePrice' in $$props) $$invalidate(3, adventurePrice = $$props.adventurePrice);
    		if ('founderPrice' in $$props) $$invalidate(4, founderPrice = $$props.founderPrice);
    		if ('savePlan' in $$props) $$invalidate(12, savePlan = $$props.savePlan);
    		if ('advPlan' in $$props) $$invalidate(13, advPlan = $$props.advPlan);
    		if ('foundPlan' in $$props) $$invalidate(14, foundPlan = $$props.foundPlan);
    		if ('activeDropdownSave' in $$props) $$invalidate(5, activeDropdownSave = $$props.activeDropdownSave);
    		if ('activeDropdownAdv' in $$props) $$invalidate(6, activeDropdownAdv = $$props.activeDropdownAdv);
    		if ('activeDropdownFound' in $$props) $$invalidate(7, activeDropdownFound = $$props.activeDropdownFound);
    		if ('current' in $$props) $$invalidate(8, current = $$props.current);
    		if ('allowPercentageVal' in $$props) $$invalidate(9, allowPercentageVal = $$props.allowPercentageVal);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*savePercentages*/ 1) ;

    		if ($$self.$$.dirty[0] & /*$allocatedContributions*/ 2) {
    			$$invalidate(9, allowPercentageVal = 100 - $allocatedContributions.safe - $allocatedContributions.adventure - $allocatedContributions.founder);
    		}
    	};

    	return [
    		savePercentages,
    		$allocatedContributions,
    		safePrice,
    		adventurePrice,
    		founderPrice,
    		activeDropdownSave,
    		activeDropdownAdv,
    		activeDropdownFound,
    		current,
    		allowPercentageVal,
    		$disableAllDropdown,
    		$contributionData,
    		savePlan,
    		advPlan,
    		foundPlan,
    		setPercentage,
    		showModal,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9,
    		click_handler_10,
    		click_handler_11
    	];
    }

    class PlanItems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$p, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlanItems",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var lottie = createCommonjsModule(function (module, exports) {
    (typeof navigator !== "undefined") && (function (global, factory) {
      module.exports = factory() ;
    })(commonjsGlobal, (function () {
      var svgNS = 'http://www.w3.org/2000/svg';
      var locationHref = '';
      var _useWebWorker = false;
      var initialDefaultFrame = -999999;

      var setWebWorker = function setWebWorker(flag) {
        _useWebWorker = !!flag;
      };

      var getWebWorker = function getWebWorker() {
        return _useWebWorker;
      };

      var setLocationHref = function setLocationHref(value) {
        locationHref = value;
      };

      var getLocationHref = function getLocationHref() {
        return locationHref;
      };

      function createTag(type) {
        // return {appendChild:function(){},setAttribute:function(){},style:{}}
        return document.createElement(type);
      }

      function extendPrototype(sources, destination) {
        var i;
        var len = sources.length;
        var sourcePrototype;

        for (i = 0; i < len; i += 1) {
          sourcePrototype = sources[i].prototype;

          for (var attr in sourcePrototype) {
            if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
          }
        }
      }

      function getDescriptor(object, prop) {
        return Object.getOwnPropertyDescriptor(object, prop);
      }

      function createProxyFunction(prototype) {
        function ProxyFunction() {}

        ProxyFunction.prototype = prototype;
        return ProxyFunction;
      }

      // import Howl from '../../3rd_party/howler';
      var audioControllerFactory = function () {
        function AudioController(audioFactory) {
          this.audios = [];
          this.audioFactory = audioFactory;
          this._volume = 1;
          this._isMuted = false;
        }

        AudioController.prototype = {
          addAudio: function addAudio(audio) {
            this.audios.push(audio);
          },
          pause: function pause() {
            var i;
            var len = this.audios.length;

            for (i = 0; i < len; i += 1) {
              this.audios[i].pause();
            }
          },
          resume: function resume() {
            var i;
            var len = this.audios.length;

            for (i = 0; i < len; i += 1) {
              this.audios[i].resume();
            }
          },
          setRate: function setRate(rateValue) {
            var i;
            var len = this.audios.length;

            for (i = 0; i < len; i += 1) {
              this.audios[i].setRate(rateValue);
            }
          },
          createAudio: function createAudio(assetPath) {
            if (this.audioFactory) {
              return this.audioFactory(assetPath);
            }

            if (window.Howl) {
              return new window.Howl({
                src: [assetPath]
              });
            }

            return {
              isPlaying: false,
              play: function play() {
                this.isPlaying = true;
              },
              seek: function seek() {
                this.isPlaying = false;
              },
              playing: function playing() {},
              rate: function rate() {},
              setVolume: function setVolume() {}
            };
          },
          setAudioFactory: function setAudioFactory(audioFactory) {
            this.audioFactory = audioFactory;
          },
          setVolume: function setVolume(value) {
            this._volume = value;

            this._updateVolume();
          },
          mute: function mute() {
            this._isMuted = true;

            this._updateVolume();
          },
          unmute: function unmute() {
            this._isMuted = false;

            this._updateVolume();
          },
          getVolume: function getVolume() {
            return this._volume;
          },
          _updateVolume: function _updateVolume() {
            var i;
            var len = this.audios.length;

            for (i = 0; i < len; i += 1) {
              this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
            }
          }
        };
        return function () {
          return new AudioController();
        };
      }();

      var createTypedArray = function () {
        function createRegularArray(type, len) {
          var i = 0;
          var arr = [];
          var value;

          switch (type) {
            case 'int16':
            case 'uint8c':
              value = 1;
              break;

            default:
              value = 1.1;
              break;
          }

          for (i = 0; i < len; i += 1) {
            arr.push(value);
          }

          return arr;
        }

        function createTypedArrayFactory(type, len) {
          if (type === 'float32') {
            return new Float32Array(len);
          }

          if (type === 'int16') {
            return new Int16Array(len);
          }

          if (type === 'uint8c') {
            return new Uint8ClampedArray(len);
          }

          return createRegularArray(type, len);
        }

        if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
          return createTypedArrayFactory;
        }

        return createRegularArray;
      }();

      function createSizedArray(len) {
        return Array.apply(null, {
          length: len
        });
      }

      function _typeof$6(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }
      var subframeEnabled = true;
      var expressionsPlugin = null;
      var idPrefix$1 = '';
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      var bmPow = Math.pow;
      var bmSqrt = Math.sqrt;
      var bmFloor = Math.floor;
      var bmMax = Math.max;
      var bmMin = Math.min;
      var BMMath = {};

      (function () {
        var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
        var i;
        var len = propertyNames.length;

        for (i = 0; i < len; i += 1) {
          BMMath[propertyNames[i]] = Math[propertyNames[i]];
        }
      })();

      BMMath.random = Math.random;

      BMMath.abs = function (val) {
        var tOfVal = _typeof$6(val);

        if (tOfVal === 'object' && val.length) {
          var absArr = createSizedArray(val.length);
          var i;
          var len = val.length;

          for (i = 0; i < len; i += 1) {
            absArr[i] = Math.abs(val[i]);
          }

          return absArr;
        }

        return Math.abs(val);
      };

      var defaultCurveSegments = 150;
      var degToRads = Math.PI / 180;
      var roundCorner = 0.5519;

      function styleDiv(element) {
        element.style.position = 'absolute';
        element.style.top = 0;
        element.style.left = 0;
        element.style.display = 'block';
        element.style.transformOrigin = '0 0';
        element.style.webkitTransformOrigin = '0 0';
        element.style.backfaceVisibility = 'visible';
        element.style.webkitBackfaceVisibility = 'visible';
        element.style.transformStyle = 'preserve-3d';
        element.style.webkitTransformStyle = 'preserve-3d';
        element.style.mozTransformStyle = 'preserve-3d';
      }

      function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
        this.type = type;
        this.currentTime = currentTime;
        this.totalTime = totalTime;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }

      function BMCompleteEvent(type, frameMultiplier) {
        this.type = type;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }

      function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
        this.type = type;
        this.currentLoop = currentLoop;
        this.totalLoops = totalLoops;
        this.direction = frameMultiplier < 0 ? -1 : 1;
      }

      function BMSegmentStartEvent(type, firstFrame, totalFrames) {
        this.type = type;
        this.firstFrame = firstFrame;
        this.totalFrames = totalFrames;
      }

      function BMDestroyEvent(type, target) {
        this.type = type;
        this.target = target;
      }

      function BMRenderFrameErrorEvent(nativeError, currentTime) {
        this.type = 'renderFrameError';
        this.nativeError = nativeError;
        this.currentTime = currentTime;
      }

      function BMConfigErrorEvent(nativeError) {
        this.type = 'configError';
        this.nativeError = nativeError;
      }

      var createElementID = function () {
        var _count = 0;
        return function createID() {
          _count += 1;
          return idPrefix$1 + '__lottie_element_' + _count;
        };
      }();

      function HSVtoRGB(h, s, v) {
        var r;
        var g;
        var b;
        var i;
        var f;
        var p;
        var q;
        var t;
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);

        switch (i % 6) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;

          case 1:
            r = q;
            g = v;
            b = p;
            break;

          case 2:
            r = p;
            g = v;
            b = t;
            break;

          case 3:
            r = p;
            g = q;
            b = v;
            break;

          case 4:
            r = t;
            g = p;
            b = v;
            break;

          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }

        return [r, g, b];
      }

      function RGBtoHSV(r, g, b) {
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var d = max - min;
        var h;
        var s = max === 0 ? 0 : d / max;
        var v = max / 255;

        switch (max) {
          case min:
            h = 0;
            break;

          case r:
            h = g - b + d * (g < b ? 6 : 0);
            h /= 6 * d;
            break;

          case g:
            h = b - r + d * 2;
            h /= 6 * d;
            break;

          case b:
            h = r - g + d * 4;
            h /= 6 * d;
            break;
        }

        return [h, s, v];
      }

      function addSaturationToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[1] += offset;

        if (hsv[1] > 1) {
          hsv[1] = 1;
        } else if (hsv[1] <= 0) {
          hsv[1] = 0;
        }

        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }

      function addBrightnessToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[2] += offset;

        if (hsv[2] > 1) {
          hsv[2] = 1;
        } else if (hsv[2] < 0) {
          hsv[2] = 0;
        }

        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }

      function addHueToRGB(color, offset) {
        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
        hsv[0] += offset / 360;

        if (hsv[0] > 1) {
          hsv[0] -= 1;
        } else if (hsv[0] < 0) {
          hsv[0] += 1;
        }

        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
      }

      var rgbToHex = function () {
        var colorMap = [];
        var i;
        var hex;

        for (i = 0; i < 256; i += 1) {
          hex = i.toString(16);
          colorMap[i] = hex.length === 1 ? '0' + hex : hex;
        }

        return function (r, g, b) {
          if (r < 0) {
            r = 0;
          }

          if (g < 0) {
            g = 0;
          }

          if (b < 0) {
            b = 0;
          }

          return '#' + colorMap[r] + colorMap[g] + colorMap[b];
        };
      }();

      var setSubframeEnabled = function setSubframeEnabled(flag) {
        subframeEnabled = !!flag;
      };

      var getSubframeEnabled = function getSubframeEnabled() {
        return subframeEnabled;
      };

      var setExpressionsPlugin = function setExpressionsPlugin(value) {
        expressionsPlugin = value;
      };

      var getExpressionsPlugin = function getExpressionsPlugin() {
        return expressionsPlugin;
      };

      var setDefaultCurveSegments = function setDefaultCurveSegments(value) {
        defaultCurveSegments = value;
      };

      var getDefaultCurveSegments = function getDefaultCurveSegments() {
        return defaultCurveSegments;
      };

      var setIdPrefix = function setIdPrefix(value) {
        idPrefix$1 = value;
      };

      function createNS(type) {
        // return {appendChild:function(){},setAttribute:function(){},style:{}}
        return document.createElementNS(svgNS, type);
      }

      function _typeof$5(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

      var dataManager = function () {
        var _counterId = 1;
        var processes = [];
        var workerFn;
        var workerInstance;
        var workerProxy = {
          onmessage: function onmessage() {},
          postMessage: function postMessage(path) {
            workerFn({
              data: path
            });
          }
        };
        var _workerSelf = {
          postMessage: function postMessage(data) {
            workerProxy.onmessage({
              data: data
            });
          }
        };

        function createWorker(fn) {
          if (window.Worker && window.Blob && getWebWorker()) {
            var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], {
              type: 'text/javascript'
            }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });

            var url = URL.createObjectURL(blob);
            return new Worker(url);
          }

          workerFn = fn;
          return workerProxy;
        }

        function setupWorker() {
          if (!workerInstance) {
            workerInstance = createWorker(function workerStart(e) {
              function dataFunctionManager() {
                function completeLayers(layers, comps) {
                  var layerData;
                  var i;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;

                  for (i = 0; i < len; i += 1) {
                    layerData = layers[i];

                    if ('ks' in layerData && !layerData.completed) {
                      layerData.completed = true;

                      if (layerData.tt) {
                        layers[i - 1].td = layerData.tt;
                      }

                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;

                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            convertPathsToAbsoluteValues(maskProps[j].pt.k);
                          } else {
                            kLen = maskProps[j].pt.k.length;

                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                              }

                              if (maskProps[j].pt.k[k].e) {
                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                              }
                            }
                          }
                        }
                      }

                      if (layerData.ty === 0) {
                        layerData.layers = findCompLayers(layerData.refId, comps);
                        completeLayers(layerData.layers, comps);
                      } else if (layerData.ty === 4) {
                        completeShapes(layerData.shapes);
                      } else if (layerData.ty === 5) {
                        completeText(layerData);
                      }
                    }
                  }
                }

                function completeChars(chars, assets) {
                  if (chars) {
                    var i = 0;
                    var len = chars.length;

                    for (i = 0; i < len; i += 1) {
                      if (chars[i].t === 1) {
                        // var compData = findComp(chars[i].data.refId, assets);
                        chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;
                        // chars[i].data.op = 99999;
                        // chars[i].data.st = 0;
                        // chars[i].data.sr = 1;
                        // chars[i].w = compData.w;
                        // chars[i].data.ks = {
                        //   a: { k: [0, 0, 0], a: 0 },
                        //   p: { k: [0, -compData.h, 0], a: 0 },
                        //   r: { k: 0, a: 0 },
                        //   s: { k: [100, 100], a: 0 },
                        //   o: { k: 100, a: 0 },
                        // };

                        completeLayers(chars[i].data.layers, assets);
                      }
                    }
                  }
                }

                function findComp(id, comps) {
                  var i = 0;
                  var len = comps.length;

                  while (i < len) {
                    if (comps[i].id === id) {
                      return comps[i];
                    }

                    i += 1;
                  }

                  return null;
                }

                function findCompLayers(id, comps) {
                  var comp = findComp(id, comps);

                  if (comp) {
                    if (!comp.layers.__used) {
                      comp.layers.__used = true;
                      return comp.layers;
                    }

                    return JSON.parse(JSON.stringify(comp.layers));
                  }

                  return null;
                }

                function completeShapes(arr) {
                  var i;
                  var len = arr.length;
                  var j;
                  var jLen;

                  for (i = len - 1; i >= 0; i -= 1) {
                    if (arr[i].ty === 'sh') {
                      if (arr[i].ks.k.i) {
                        convertPathsToAbsoluteValues(arr[i].ks.k);
                      } else {
                        jLen = arr[i].ks.k.length;

                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i].ks.k[j].s) {
                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                          }

                          if (arr[i].ks.k[j].e) {
                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                          }
                        }
                      }
                    } else if (arr[i].ty === 'gr') {
                      completeShapes(arr[i].it);
                    }
                  }
                }

                function convertPathsToAbsoluteValues(path) {
                  var i;
                  var len = path.i.length;

                  for (i = 0; i < len; i += 1) {
                    path.i[i][0] += path.v[i][0];
                    path.i[i][1] += path.v[i][1];
                    path.o[i][0] += path.v[i][0];
                    path.o[i][1] += path.v[i][1];
                  }
                }

                function checkVersion(minimum, animVersionString) {
                  var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];

                  if (minimum[0] > animVersion[0]) {
                    return true;
                  }

                  if (animVersion[0] > minimum[0]) {
                    return false;
                  }

                  if (minimum[1] > animVersion[1]) {
                    return true;
                  }

                  if (animVersion[1] > minimum[1]) {
                    return false;
                  }

                  if (minimum[2] > animVersion[2]) {
                    return true;
                  }

                  if (animVersion[2] > minimum[2]) {
                    return false;
                  }

                  return null;
                }

                var checkText = function () {
                  var minimumVersion = [4, 4, 14];

                  function updateTextLayer(textLayer) {
                    var documentData = textLayer.t.d;
                    textLayer.t.d = {
                      k: [{
                        s: documentData,
                        t: 0
                      }]
                    };
                  }

                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;

                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 5) {
                        updateTextLayer(layers[i]);
                      }
                    }
                  }

                  return function (animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);

                      if (animationData.assets) {
                        var i;
                        var len = animationData.assets.length;

                        for (i = 0; i < len; i += 1) {
                          if (animationData.assets[i].layers) {
                            iterateLayers(animationData.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();

                var checkChars = function () {
                  var minimumVersion = [4, 7, 99];
                  return function (animationData) {
                    if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                      var i;
                      var len = animationData.chars.length;

                      for (i = 0; i < len; i += 1) {
                        var charData = animationData.chars[i];

                        if (charData.data && charData.data.shapes) {
                          completeShapes(charData.data.shapes);
                          charData.data.ip = 0;
                          charData.data.op = 99999;
                          charData.data.st = 0;
                          charData.data.sr = 1;
                          charData.data.ks = {
                            p: {
                              k: [0, 0],
                              a: 0
                            },
                            s: {
                              k: [100, 100],
                              a: 0
                            },
                            a: {
                              k: [0, 0],
                              a: 0
                            },
                            r: {
                              k: 0,
                              a: 0
                            },
                            o: {
                              k: 100,
                              a: 0
                            }
                          };

                          if (!animationData.chars[i].t) {
                            charData.data.shapes.push({
                              ty: 'no'
                            });
                            charData.data.shapes[0].it.push({
                              p: {
                                k: [0, 0],
                                a: 0
                              },
                              s: {
                                k: [100, 100],
                                a: 0
                              },
                              a: {
                                k: [0, 0],
                                a: 0
                              },
                              r: {
                                k: 0,
                                a: 0
                              },
                              o: {
                                k: 100,
                                a: 0
                              },
                              sk: {
                                k: 0,
                                a: 0
                              },
                              sa: {
                                k: 0,
                                a: 0
                              },
                              ty: 'tr'
                            });
                          }
                        }
                      }
                    }
                  };
                }();

                var checkPathProperties = function () {
                  var minimumVersion = [5, 7, 15];

                  function updateTextLayer(textLayer) {
                    var pathData = textLayer.t.p;

                    if (typeof pathData.a === 'number') {
                      pathData.a = {
                        a: 0,
                        k: pathData.a
                      };
                    }

                    if (typeof pathData.p === 'number') {
                      pathData.p = {
                        a: 0,
                        k: pathData.p
                      };
                    }

                    if (typeof pathData.r === 'number') {
                      pathData.r = {
                        a: 0,
                        k: pathData.r
                      };
                    }
                  }

                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;

                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 5) {
                        updateTextLayer(layers[i]);
                      }
                    }
                  }

                  return function (animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);

                      if (animationData.assets) {
                        var i;
                        var len = animationData.assets.length;

                        for (i = 0; i < len; i += 1) {
                          if (animationData.assets[i].layers) {
                            iterateLayers(animationData.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();

                var checkColors = function () {
                  var minimumVersion = [4, 1, 9];

                  function iterateShapes(shapes) {
                    var i;
                    var len = shapes.length;
                    var j;
                    var jLen;

                    for (i = 0; i < len; i += 1) {
                      if (shapes[i].ty === 'gr') {
                        iterateShapes(shapes[i].it);
                      } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
                        if (shapes[i].c.k && shapes[i].c.k[0].i) {
                          jLen = shapes[i].c.k.length;

                          for (j = 0; j < jLen; j += 1) {
                            if (shapes[i].c.k[j].s) {
                              shapes[i].c.k[j].s[0] /= 255;
                              shapes[i].c.k[j].s[1] /= 255;
                              shapes[i].c.k[j].s[2] /= 255;
                              shapes[i].c.k[j].s[3] /= 255;
                            }

                            if (shapes[i].c.k[j].e) {
                              shapes[i].c.k[j].e[0] /= 255;
                              shapes[i].c.k[j].e[1] /= 255;
                              shapes[i].c.k[j].e[2] /= 255;
                              shapes[i].c.k[j].e[3] /= 255;
                            }
                          }
                        } else {
                          shapes[i].c.k[0] /= 255;
                          shapes[i].c.k[1] /= 255;
                          shapes[i].c.k[2] /= 255;
                          shapes[i].c.k[3] /= 255;
                        }
                      }
                    }
                  }

                  function iterateLayers(layers) {
                    var i;
                    var len = layers.length;

                    for (i = 0; i < len; i += 1) {
                      if (layers[i].ty === 4) {
                        iterateShapes(layers[i].shapes);
                      }
                    }
                  }

                  return function (animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);

                      if (animationData.assets) {
                        var i;
                        var len = animationData.assets.length;

                        for (i = 0; i < len; i += 1) {
                          if (animationData.assets[i].layers) {
                            iterateLayers(animationData.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();

                var checkShapes = function () {
                  var minimumVersion = [4, 4, 18];

                  function completeClosingShapes(arr) {
                    var i;
                    var len = arr.length;
                    var j;
                    var jLen;

                    for (i = len - 1; i >= 0; i -= 1) {
                      if (arr[i].ty === 'sh') {
                        if (arr[i].ks.k.i) {
                          arr[i].ks.k.c = arr[i].closed;
                        } else {
                          jLen = arr[i].ks.k.length;

                          for (j = 0; j < jLen; j += 1) {
                            if (arr[i].ks.k[j].s) {
                              arr[i].ks.k[j].s[0].c = arr[i].closed;
                            }

                            if (arr[i].ks.k[j].e) {
                              arr[i].ks.k[j].e[0].c = arr[i].closed;
                            }
                          }
                        }
                      } else if (arr[i].ty === 'gr') {
                        completeClosingShapes(arr[i].it);
                      }
                    }
                  }

                  function iterateLayers(layers) {
                    var layerData;
                    var i;
                    var len = layers.length;
                    var j;
                    var jLen;
                    var k;
                    var kLen;

                    for (i = 0; i < len; i += 1) {
                      layerData = layers[i];

                      if (layerData.hasMask) {
                        var maskProps = layerData.masksProperties;
                        jLen = maskProps.length;

                        for (j = 0; j < jLen; j += 1) {
                          if (maskProps[j].pt.k.i) {
                            maskProps[j].pt.k.c = maskProps[j].cl;
                          } else {
                            kLen = maskProps[j].pt.k.length;

                            for (k = 0; k < kLen; k += 1) {
                              if (maskProps[j].pt.k[k].s) {
                                maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                              }

                              if (maskProps[j].pt.k[k].e) {
                                maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                              }
                            }
                          }
                        }
                      }

                      if (layerData.ty === 4) {
                        completeClosingShapes(layerData.shapes);
                      }
                    }
                  }

                  return function (animationData) {
                    if (checkVersion(minimumVersion, animationData.v)) {
                      iterateLayers(animationData.layers);

                      if (animationData.assets) {
                        var i;
                        var len = animationData.assets.length;

                        for (i = 0; i < len; i += 1) {
                          if (animationData.assets[i].layers) {
                            iterateLayers(animationData.assets[i].layers);
                          }
                        }
                      }
                    }
                  };
                }();

                function completeData(animationData) {
                  if (animationData.__complete) {
                    return;
                  }

                  checkColors(animationData);
                  checkText(animationData);
                  checkChars(animationData);
                  checkPathProperties(animationData);
                  checkShapes(animationData);
                  completeLayers(animationData.layers, animationData.assets);
                  completeChars(animationData.chars, animationData.assets);
                  animationData.__complete = true;
                }

                function completeText(data) {
                  if (data.t.a.length === 0 && !('m' in data.t.p)) ;
                }

                var moduleOb = {};
                moduleOb.completeData = completeData;
                moduleOb.checkColors = checkColors;
                moduleOb.checkChars = checkChars;
                moduleOb.checkPathProperties = checkPathProperties;
                moduleOb.checkShapes = checkShapes;
                moduleOb.completeLayers = completeLayers;
                return moduleOb;
              }

              if (!_workerSelf.dataManager) {
                _workerSelf.dataManager = dataFunctionManager();
              }

              if (!_workerSelf.assetLoader) {
                _workerSelf.assetLoader = function () {
                  function formatResponse(xhr) {
                    // using typeof doubles the time of execution of this method,
                    // so if available, it's better to use the header to validate the type
                    var contentTypeHeader = xhr.getResponseHeader('content-type');

                    if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
                      return xhr.response;
                    }

                    if (xhr.response && _typeof$5(xhr.response) === 'object') {
                      return xhr.response;
                    }

                    if (xhr.response && typeof xhr.response === 'string') {
                      return JSON.parse(xhr.response);
                    }

                    if (xhr.responseText) {
                      return JSON.parse(xhr.responseText);
                    }

                    return null;
                  }

                  function loadAsset(path, fullPath, callback, errorCallback) {
                    var response;
                    var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.

                    try {
                      // This crashes on Android WebView prior to KitKat
                      xhr.responseType = 'json';
                    } catch (err) {} // eslint-disable-line no-empty


                    xhr.onreadystatechange = function () {
                      if (xhr.readyState === 4) {
                        if (xhr.status === 200) {
                          response = formatResponse(xhr);
                          callback(response);
                        } else {
                          try {
                            response = formatResponse(xhr);
                            callback(response);
                          } catch (err) {
                            if (errorCallback) {
                              errorCallback(err);
                            }
                          }
                        }
                      }
                    };

                    try {
                      xhr.open('GET', path, true);
                    } catch (error) {
                      xhr.open('GET', fullPath + '/' + path, true);
                    }

                    xhr.send();
                  }

                  return {
                    load: loadAsset
                  };
                }();
              }

              if (e.data.type === 'loadAnimation') {
                _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                  _workerSelf.dataManager.completeData(data);

                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data,
                    status: 'success'
                  });
                }, function () {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: 'error'
                  });
                });
              } else if (e.data.type === 'complete') {
                var animation = e.data.animation;

                _workerSelf.dataManager.completeData(animation);

                _workerSelf.postMessage({
                  id: e.data.id,
                  payload: animation,
                  status: 'success'
                });
              } else if (e.data.type === 'loadData') {
                _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function (data) {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data,
                    status: 'success'
                  });
                }, function () {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: 'error'
                  });
                });
              }
            });

            workerInstance.onmessage = function (event) {
              var data = event.data;
              var id = data.id;
              var process = processes[id];
              processes[id] = null;

              if (data.status === 'success') {
                process.onComplete(data.payload);
              } else if (process.onError) {
                process.onError();
              }
            };
          }
        }

        function createProcess(onComplete, onError) {
          _counterId += 1;
          var id = 'processId_' + _counterId;
          processes[id] = {
            onComplete: onComplete,
            onError: onError
          };
          return id;
        }

        function loadAnimation(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: 'loadAnimation',
            path: path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }

        function loadData(path, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: 'loadData',
            path: path,
            fullPath: window.location.origin + window.location.pathname,
            id: processId
          });
        }

        function completeAnimation(anim, onComplete, onError) {
          setupWorker();
          var processId = createProcess(onComplete, onError);
          workerInstance.postMessage({
            type: 'complete',
            animation: anim,
            id: processId
          });
        }

        return {
          loadAnimation: loadAnimation,
          loadData: loadData,
          completeAnimation: completeAnimation
        };
      }();

      var ImagePreloader = function () {
        var proxyImage = function () {
          var canvas = createTag('canvas');
          canvas.width = 1;
          canvas.height = 1;
          var ctx = canvas.getContext('2d');
          ctx.fillStyle = 'rgba(0,0,0,0)';
          ctx.fillRect(0, 0, 1, 1);
          return canvas;
        }();

        function imageLoaded() {
          this.loadedAssets += 1;

          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }

        function footageLoaded() {
          this.loadedFootagesCount += 1;

          if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
            if (this.imagesLoadedCb) {
              this.imagesLoadedCb(null);
            }
          }
        }

        function getAssetsPath(assetData, assetsPath, originalPath) {
          var path = '';

          if (assetData.e) {
            path = assetData.p;
          } else if (assetsPath) {
            var imagePath = assetData.p;

            if (imagePath.indexOf('images/') !== -1) {
              imagePath = imagePath.split('/')[1];
            }

            path = assetsPath + imagePath;
          } else {
            path = originalPath;
            path += assetData.u ? assetData.u : '';
            path += assetData.p;
          }

          return path;
        }

        function testImageLoaded(img) {
          var _count = 0;
          var intervalId = setInterval(function () {
            var box = img.getBBox();

            if (box.width || _count > 500) {
              this._imageLoaded();

              clearInterval(intervalId);
            }

            _count += 1;
          }.bind(this), 50);
        }

        function createImageData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createNS('image');

          if (isSafari) {
            this.testImageLoaded(img);
          } else {
            img.addEventListener('load', this._imageLoaded, false);
          }

          img.addEventListener('error', function () {
            ob.img = proxyImage;

            this._imageLoaded();
          }.bind(this), false);
          img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);

          if (this._elementHelper.append) {
            this._elementHelper.append(img);
          } else {
            this._elementHelper.appendChild(img);
          }

          var ob = {
            img: img,
            assetData: assetData
          };
          return ob;
        }

        function createImgData(assetData) {
          var path = getAssetsPath(assetData, this.assetsPath, this.path);
          var img = createTag('img');
          img.crossOrigin = 'anonymous';
          img.addEventListener('load', this._imageLoaded, false);
          img.addEventListener('error', function () {
            ob.img = proxyImage;

            this._imageLoaded();
          }.bind(this), false);
          img.src = path;
          var ob = {
            img: img,
            assetData: assetData
          };
          return ob;
        }

        function createFootageData(data) {
          var ob = {
            assetData: data
          };
          var path = getAssetsPath(data, this.assetsPath, this.path);
          dataManager.loadData(path, function (footageData) {
            ob.img = footageData;

            this._footageLoaded();
          }.bind(this), function () {
            ob.img = {};

            this._footageLoaded();
          }.bind(this));
          return ob;
        }

        function loadAssets(assets, cb) {
          this.imagesLoadedCb = cb;
          var i;
          var len = assets.length;

          for (i = 0; i < len; i += 1) {
            if (!assets[i].layers) {
              if (!assets[i].t || assets[i].t === 'seq') {
                this.totalImages += 1;
                this.images.push(this._createImageData(assets[i]));
              } else if (assets[i].t === 3) {
                this.totalFootages += 1;
                this.images.push(this.createFootageData(assets[i]));
              }
            }
          }
        }

        function setPath(path) {
          this.path = path || '';
        }

        function setAssetsPath(path) {
          this.assetsPath = path || '';
        }

        function getAsset(assetData) {
          var i = 0;
          var len = this.images.length;

          while (i < len) {
            if (this.images[i].assetData === assetData) {
              return this.images[i].img;
            }

            i += 1;
          }

          return null;
        }

        function destroy() {
          this.imagesLoadedCb = null;
          this.images.length = 0;
        }

        function loadedImages() {
          return this.totalImages === this.loadedAssets;
        }

        function loadedFootages() {
          return this.totalFootages === this.loadedFootagesCount;
        }

        function setCacheType(type, elementHelper) {
          if (type === 'svg') {
            this._elementHelper = elementHelper;
            this._createImageData = this.createImageData.bind(this);
          } else {
            this._createImageData = this.createImgData.bind(this);
          }
        }

        function ImagePreloaderFactory() {
          this._imageLoaded = imageLoaded.bind(this);
          this._footageLoaded = footageLoaded.bind(this);
          this.testImageLoaded = testImageLoaded.bind(this);
          this.createFootageData = createFootageData.bind(this);
          this.assetsPath = '';
          this.path = '';
          this.totalImages = 0;
          this.totalFootages = 0;
          this.loadedAssets = 0;
          this.loadedFootagesCount = 0;
          this.imagesLoadedCb = null;
          this.images = [];
        }

        ImagePreloaderFactory.prototype = {
          loadAssets: loadAssets,
          setAssetsPath: setAssetsPath,
          setPath: setPath,
          loadedImages: loadedImages,
          loadedFootages: loadedFootages,
          destroy: destroy,
          getAsset: getAsset,
          createImgData: createImgData,
          createImageData: createImageData,
          imageLoaded: imageLoaded,
          footageLoaded: footageLoaded,
          setCacheType: setCacheType
        };
        return ImagePreloaderFactory;
      }();

      function BaseEvent() {}

      BaseEvent.prototype = {
        triggerEvent: function triggerEvent(eventName, args) {
          if (this._cbs[eventName]) {
            var callbacks = this._cbs[eventName];

            for (var i = 0; i < callbacks.length; i += 1) {
              callbacks[i](args);
            }
          }
        },
        addEventListener: function addEventListener(eventName, callback) {
          if (!this._cbs[eventName]) {
            this._cbs[eventName] = [];
          }

          this._cbs[eventName].push(callback);

          return function () {
            this.removeEventListener(eventName, callback);
          }.bind(this);
        },
        removeEventListener: function removeEventListener(eventName, callback) {
          if (!callback) {
            this._cbs[eventName] = null;
          } else if (this._cbs[eventName]) {
            var i = 0;
            var len = this._cbs[eventName].length;

            while (i < len) {
              if (this._cbs[eventName][i] === callback) {
                this._cbs[eventName].splice(i, 1);

                i -= 1;
                len -= 1;
              }

              i += 1;
            }

            if (!this._cbs[eventName].length) {
              this._cbs[eventName] = null;
            }
          }
        }
      };

      var markerParser = function () {
        function parsePayloadLines(payload) {
          var lines = payload.split('\r\n');
          var keys = {};
          var line;
          var keysCount = 0;

          for (var i = 0; i < lines.length; i += 1) {
            line = lines[i].split(':');

            if (line.length === 2) {
              keys[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }

          if (keysCount === 0) {
            throw new Error();
          }

          return keys;
        }

        return function (_markers) {
          var markers = [];

          for (var i = 0; i < _markers.length; i += 1) {
            var _marker = _markers[i];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr
            };

            try {
              markerData.payload = JSON.parse(_markers[i].cm);
            } catch (_) {
              try {
                markerData.payload = parsePayloadLines(_markers[i].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i].cm
                };
              }
            }

            markers.push(markerData);
          }

          return markers;
        };
      }();

      var ProjectInterface = function () {
        function registerComposition(comp) {
          this.compositions.push(comp);
        }

        return function () {
          function _thisProjectFunction(name) {
            var i = 0;
            var len = this.compositions.length;

            while (i < len) {
              if (this.compositions[i].data && this.compositions[i].data.nm === name) {
                if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                  this.compositions[i].prepareFrame(this.currentFrame);
                }

                return this.compositions[i].compInterface;
              }

              i += 1;
            }

            return null;
          }

          _thisProjectFunction.compositions = [];
          _thisProjectFunction.currentFrame = 0;
          _thisProjectFunction.registerComposition = registerComposition;
          return _thisProjectFunction;
        };
      }();

      var renderers = {};

      var registerRenderer = function registerRenderer(key, value) {
        renderers[key] = value;
      };

      function getRenderer(key) {
        return renderers[key];
      }

      function _typeof$4(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

      var AnimationItem = function AnimationItem() {
        this._cbs = [];
        this.name = '';
        this.path = '';
        this.isLoaded = false;
        this.currentFrame = 0;
        this.currentRawFrame = 0;
        this.firstFrame = 0;
        this.totalFrames = 0;
        this.frameRate = 0;
        this.frameMult = 0;
        this.playSpeed = 1;
        this.playDirection = 1;
        this.playCount = 0;
        this.animationData = {};
        this.assets = [];
        this.isPaused = true;
        this.autoplay = false;
        this.loop = true;
        this.renderer = null;
        this.animationID = createElementID();
        this.assetsPath = '';
        this.timeCompleted = 0;
        this.segmentPos = 0;
        this.isSubframeEnabled = getSubframeEnabled();
        this.segments = [];
        this._idle = true;
        this._completedLoop = false;
        this.projectInterface = ProjectInterface();
        this.imagePreloader = new ImagePreloader();
        this.audioController = audioControllerFactory();
        this.markers = [];
        this.configAnimation = this.configAnimation.bind(this);
        this.onSetupError = this.onSetupError.bind(this);
        this.onSegmentComplete = this.onSegmentComplete.bind(this);
        this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);
      };

      extendPrototype([BaseEvent], AnimationItem);

      AnimationItem.prototype.setParams = function (params) {
        if (params.wrapper || params.container) {
          this.wrapper = params.wrapper || params.container;
        }

        var animType = 'svg';

        if (params.animType) {
          animType = params.animType;
        } else if (params.renderer) {
          animType = params.renderer;
        }

        var RendererClass = getRenderer(animType);
        this.renderer = new RendererClass(this, params.rendererSettings);
        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
        this.renderer.setProjectInterface(this.projectInterface);
        this.animType = animType;

        if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {
          this.loop = true;
        } else if (params.loop === false) {
          this.loop = false;
        } else {
          this.loop = parseInt(params.loop, 10);
        }

        this.autoplay = 'autoplay' in params ? params.autoplay : true;
        this.name = params.name ? params.name : '';
        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
        this.assetsPath = params.assetsPath;
        this.initialSegment = params.initialSegment;

        if (params.audioFactory) {
          this.audioController.setAudioFactory(params.audioFactory);
        }

        if (params.animationData) {
          this.setupAnimation(params.animationData);
        } else if (params.path) {
          if (params.path.lastIndexOf('\\') !== -1) {
            this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
          } else {
            this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
          }

          this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
          this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
          dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);
        }
      };

      AnimationItem.prototype.onSetupError = function () {
        this.trigger('data_failed');
      };

      AnimationItem.prototype.setupAnimation = function (data) {
        dataManager.completeAnimation(data, this.configAnimation);
      };

      AnimationItem.prototype.setData = function (wrapper, animationData) {
        if (animationData) {
          if (_typeof$4(animationData) !== 'object') {
            animationData = JSON.parse(animationData);
          }
        }

        var params = {
          wrapper: wrapper,
          animationData: animationData
        };
        var wrapperAttributes = wrapper.attributes;
        params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';
        params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';
        var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';

        if (loop === 'false') {
          params.loop = false;
        } else if (loop === 'true') {
          params.loop = true;
        } else if (loop !== '') {
          params.loop = parseInt(loop, 10);
        }

        var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;
        params.autoplay = autoplay !== 'false';
        params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';
        var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';

        if (prerender === 'false') {
          params.prerender = false;
        }

        this.setParams(params);
      };

      AnimationItem.prototype.includeLayers = function (data) {
        if (data.op > this.animationData.op) {
          this.animationData.op = data.op;
          this.totalFrames = Math.floor(data.op - this.animationData.ip);
        }

        var layers = this.animationData.layers;
        var i;
        var len = layers.length;
        var newLayers = data.layers;
        var j;
        var jLen = newLayers.length;

        for (j = 0; j < jLen; j += 1) {
          i = 0;

          while (i < len) {
            if (layers[i].id === newLayers[j].id) {
              layers[i] = newLayers[j];
              break;
            }

            i += 1;
          }
        }

        if (data.chars || data.fonts) {
          this.renderer.globalData.fontManager.addChars(data.chars);
          this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
        }

        if (data.assets) {
          len = data.assets.length;

          for (i = 0; i < len; i += 1) {
            this.animationData.assets.push(data.assets[i]);
          }
        }

        this.animationData.__complete = false;
        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
      };

      AnimationItem.prototype.onSegmentComplete = function (data) {
        this.animationData = data;
        var expressionsPlugin = getExpressionsPlugin();

        if (expressionsPlugin) {
          expressionsPlugin.initExpressions(this);
        }

        this.loadNextSegment();
      };

      AnimationItem.prototype.loadNextSegment = function () {
        var segments = this.animationData.segments;

        if (!segments || segments.length === 0 || !this.autoloadSegments) {
          this.trigger('data_ready');
          this.timeCompleted = this.totalFrames;
          return;
        }

        var segment = segments.shift();
        this.timeCompleted = segment.time * this.frameRate;
        var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
        this.segmentPos += 1;
        dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
          this.trigger('data_failed');
        }.bind(this));
      };

      AnimationItem.prototype.loadSegments = function () {
        var segments = this.animationData.segments;

        if (!segments) {
          this.timeCompleted = this.totalFrames;
        }

        this.loadNextSegment();
      };

      AnimationItem.prototype.imagesLoaded = function () {
        this.trigger('loaded_images');
        this.checkLoaded();
      };

      AnimationItem.prototype.preloadImages = function () {
        this.imagePreloader.setAssetsPath(this.assetsPath);
        this.imagePreloader.setPath(this.path);
        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
      };

      AnimationItem.prototype.configAnimation = function (animData) {
        if (!this.renderer) {
          return;
        }

        try {
          this.animationData = animData;

          if (this.initialSegment) {
            this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
            this.firstFrame = Math.round(this.initialSegment[0]);
          } else {
            this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
            this.firstFrame = Math.round(this.animationData.ip);
          }

          this.renderer.configAnimation(animData);

          if (!animData.assets) {
            animData.assets = [];
          }

          this.assets = this.animationData.assets;
          this.frameRate = this.animationData.fr;
          this.frameMult = this.animationData.fr / 1000;
          this.renderer.searchExtraCompositions(animData.assets);
          this.markers = markerParser(animData.markers || []);
          this.trigger('config_ready');
          this.preloadImages();
          this.loadSegments();
          this.updaFrameModifier();
          this.waitForFontsLoaded();

          if (this.isPaused) {
            this.audioController.pause();
          }
        } catch (error) {
          this.triggerConfigError(error);
        }
      };

      AnimationItem.prototype.waitForFontsLoaded = function () {
        if (!this.renderer) {
          return;
        }

        if (this.renderer.globalData.fontManager.isLoaded) {
          this.checkLoaded();
        } else {
          setTimeout(this.waitForFontsLoaded.bind(this), 20);
        }
      };

      AnimationItem.prototype.checkLoaded = function () {
        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {
          this.isLoaded = true;
          var expressionsPlugin = getExpressionsPlugin();

          if (expressionsPlugin) {
            expressionsPlugin.initExpressions(this);
          }

          this.renderer.initItems();
          setTimeout(function () {
            this.trigger('DOMLoaded');
          }.bind(this), 0);
          this.gotoFrame();

          if (this.autoplay) {
            this.play();
          }
        }
      };

      AnimationItem.prototype.resize = function () {
        this.renderer.updateContainerSize();
      };

      AnimationItem.prototype.setSubframe = function (flag) {
        this.isSubframeEnabled = !!flag;
      };

      AnimationItem.prototype.gotoFrame = function () {
        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
          this.currentFrame = this.timeCompleted;
        }

        this.trigger('enterFrame');
        this.renderFrame();
        this.trigger('drawnFrame');
      };

      AnimationItem.prototype.renderFrame = function () {
        if (this.isLoaded === false || !this.renderer) {
          return;
        }

        try {
          this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (error) {
          this.triggerRenderFrameError(error);
        }
      };

      AnimationItem.prototype.play = function (name) {
        if (name && this.name !== name) {
          return;
        }

        if (this.isPaused === true) {
          this.isPaused = false;
          this.trigger('_pause');
          this.audioController.resume();

          if (this._idle) {
            this._idle = false;
            this.trigger('_active');
          }
        }
      };

      AnimationItem.prototype.pause = function (name) {
        if (name && this.name !== name) {
          return;
        }

        if (this.isPaused === false) {
          this.isPaused = true;
          this.trigger('_play');
          this._idle = true;
          this.trigger('_idle');
          this.audioController.pause();
        }
      };

      AnimationItem.prototype.togglePause = function (name) {
        if (name && this.name !== name) {
          return;
        }

        if (this.isPaused === true) {
          this.play();
        } else {
          this.pause();
        }
      };

      AnimationItem.prototype.stop = function (name) {
        if (name && this.name !== name) {
          return;
        }

        this.pause();
        this.playCount = 0;
        this._completedLoop = false;
        this.setCurrentRawFrameValue(0);
      };

      AnimationItem.prototype.getMarkerData = function (markerName) {
        var marker;

        for (var i = 0; i < this.markers.length; i += 1) {
          marker = this.markers[i];

          if (marker.payload && marker.payload.name === markerName) {
            return marker;
          }
        }

        return null;
      };

      AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
        if (name && this.name !== name) {
          return;
        }

        var numValue = Number(value);

        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value);

          if (marker) {
            this.goToAndStop(marker.time, true);
          }
        } else if (isFrame) {
          this.setCurrentRawFrameValue(value);
        } else {
          this.setCurrentRawFrameValue(value * this.frameModifier);
        }

        this.pause();
      };

      AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
        if (name && this.name !== name) {
          return;
        }

        var numValue = Number(value);

        if (isNaN(numValue)) {
          var marker = this.getMarkerData(value);

          if (marker) {
            if (!marker.duration) {
              this.goToAndStop(marker.time, true);
            } else {
              this.playSegments([marker.time, marker.time + marker.duration], true);
            }
          }
        } else {
          this.goToAndStop(numValue, isFrame, name);
        }

        this.play();
      };

      AnimationItem.prototype.advanceTime = function (value) {
        if (this.isPaused === true || this.isLoaded === false) {
          return;
        }

        var nextValue = this.currentRawFrame + value * this.frameModifier;
        var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.

        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
          if (!this.loop || this.playCount === this.loop) {
            if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
              _isComplete = true;
              nextValue = this.totalFrames - 1;
            }
          } else if (nextValue >= this.totalFrames) {
            this.playCount += 1;

            if (!this.checkSegments(nextValue % this.totalFrames)) {
              this.setCurrentRawFrameValue(nextValue % this.totalFrames);
              this._completedLoop = true;
              this.trigger('loopComplete');
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
        } else if (nextValue < 0) {
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
              // eslint-disable-line no-plusplus
              this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);

              if (!this._completedLoop) {
                this._completedLoop = true;
              } else {
                this.trigger('loopComplete');
              }
            } else {
              _isComplete = true;
              nextValue = 0;
            }
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }

        if (_isComplete) {
          this.setCurrentRawFrameValue(nextValue);
          this.pause();
          this.trigger('complete');
        }
      };

      AnimationItem.prototype.adjustSegment = function (arr, offset) {
        this.playCount = 0;

        if (arr[1] < arr[0]) {
          if (this.frameModifier > 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(-1);
            }
          }

          this.totalFrames = arr[0] - arr[1];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[1];
          this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
        } else if (arr[1] > arr[0]) {
          if (this.frameModifier < 0) {
            if (this.playSpeed < 0) {
              this.setSpeed(-this.playSpeed);
            } else {
              this.setDirection(1);
            }
          }

          this.totalFrames = arr[1] - arr[0];
          this.timeCompleted = this.totalFrames;
          this.firstFrame = arr[0];
          this.setCurrentRawFrameValue(0.001 + offset);
        }

        this.trigger('segmentStart');
      };

      AnimationItem.prototype.setSegment = function (init, end) {
        var pendingFrame = -1;

        if (this.isPaused) {
          if (this.currentRawFrame + this.firstFrame < init) {
            pendingFrame = init;
          } else if (this.currentRawFrame + this.firstFrame > end) {
            pendingFrame = end - init;
          }
        }

        this.firstFrame = init;
        this.totalFrames = end - init;
        this.timeCompleted = this.totalFrames;

        if (pendingFrame !== -1) {
          this.goToAndStop(pendingFrame, true);
        }
      };

      AnimationItem.prototype.playSegments = function (arr, forceFlag) {
        if (forceFlag) {
          this.segments.length = 0;
        }

        if (_typeof$4(arr[0]) === 'object') {
          var i;
          var len = arr.length;

          for (i = 0; i < len; i += 1) {
            this.segments.push(arr[i]);
          }
        } else {
          this.segments.push(arr);
        }

        if (this.segments.length && forceFlag) {
          this.adjustSegment(this.segments.shift(), 0);
        }

        if (this.isPaused) {
          this.play();
        }
      };

      AnimationItem.prototype.resetSegments = function (forceFlag) {
        this.segments.length = 0;
        this.segments.push([this.animationData.ip, this.animationData.op]);

        if (forceFlag) {
          this.checkSegments(0);
        }
      };

      AnimationItem.prototype.checkSegments = function (offset) {
        if (this.segments.length) {
          this.adjustSegment(this.segments.shift(), offset);
          return true;
        }

        return false;
      };

      AnimationItem.prototype.destroy = function (name) {
        if (name && this.name !== name || !this.renderer) {
          return;
        }

        this.renderer.destroy();
        this.imagePreloader.destroy();
        this.trigger('destroy');
        this._cbs = null;
        this.onEnterFrame = null;
        this.onLoopComplete = null;
        this.onComplete = null;
        this.onSegmentStart = null;
        this.onDestroy = null;
        this.renderer = null;
        this.renderer = null;
        this.imagePreloader = null;
        this.projectInterface = null;
      };

      AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
        this.currentRawFrame = value;
        this.gotoFrame();
      };

      AnimationItem.prototype.setSpeed = function (val) {
        this.playSpeed = val;
        this.updaFrameModifier();
      };

      AnimationItem.prototype.setDirection = function (val) {
        this.playDirection = val < 0 ? -1 : 1;
        this.updaFrameModifier();
      };

      AnimationItem.prototype.setVolume = function (val, name) {
        if (name && this.name !== name) {
          return;
        }

        this.audioController.setVolume(val);
      };

      AnimationItem.prototype.getVolume = function () {
        return this.audioController.getVolume();
      };

      AnimationItem.prototype.mute = function (name) {
        if (name && this.name !== name) {
          return;
        }

        this.audioController.mute();
      };

      AnimationItem.prototype.unmute = function (name) {
        if (name && this.name !== name) {
          return;
        }

        this.audioController.unmute();
      };

      AnimationItem.prototype.updaFrameModifier = function () {
        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
        this.audioController.setRate(this.playSpeed * this.playDirection);
      };

      AnimationItem.prototype.getPath = function () {
        return this.path;
      };

      AnimationItem.prototype.getAssetsPath = function (assetData) {
        var path = '';

        if (assetData.e) {
          path = assetData.p;
        } else if (this.assetsPath) {
          var imagePath = assetData.p;

          if (imagePath.indexOf('images/') !== -1) {
            imagePath = imagePath.split('/')[1];
          }

          path = this.assetsPath + imagePath;
        } else {
          path = this.path;
          path += assetData.u ? assetData.u : '';
          path += assetData.p;
        }

        return path;
      };

      AnimationItem.prototype.getAssetData = function (id) {
        var i = 0;
        var len = this.assets.length;

        while (i < len) {
          if (id === this.assets[i].id) {
            return this.assets[i];
          }

          i += 1;
        }

        return null;
      };

      AnimationItem.prototype.hide = function () {
        this.renderer.hide();
      };

      AnimationItem.prototype.show = function () {
        this.renderer.show();
      };

      AnimationItem.prototype.getDuration = function (isFrame) {
        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
      };

      AnimationItem.prototype.updateDocumentData = function (path, documentData, index) {
        try {
          var element = this.renderer.getElementByPath(path);
          element.updateDocumentData(documentData, index);
        } catch (error) {// TODO: decide how to handle catch case
        }
      };

      AnimationItem.prototype.trigger = function (name) {
        if (this._cbs && this._cbs[name]) {
          switch (name) {
            case 'enterFrame':
              this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
              break;

            case 'drawnFrame':
              this.drawnFrameEvent.currentTime = this.currentFrame;
              this.drawnFrameEvent.totalTime = this.totalFrames;
              this.drawnFrameEvent.direction = this.frameModifier;
              this.triggerEvent(name, this.drawnFrameEvent);
              break;

            case 'loopComplete':
              this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
              break;

            case 'complete':
              this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
              break;

            case 'segmentStart':
              this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
              break;

            case 'destroy':
              this.triggerEvent(name, new BMDestroyEvent(name, this));
              break;

            default:
              this.triggerEvent(name);
          }
        }

        if (name === 'enterFrame' && this.onEnterFrame) {
          this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
        }

        if (name === 'loopComplete' && this.onLoopComplete) {
          this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
        }

        if (name === 'complete' && this.onComplete) {
          this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
        }

        if (name === 'segmentStart' && this.onSegmentStart) {
          this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
        }

        if (name === 'destroy' && this.onDestroy) {
          this.onDestroy.call(this, new BMDestroyEvent(name, this));
        }
      };

      AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent('error', error);

        if (this.onError) {
          this.onError.call(this, error);
        }
      };

      AnimationItem.prototype.triggerConfigError = function (nativeError) {
        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
        this.triggerEvent('error', error);

        if (this.onError) {
          this.onError.call(this, error);
        }
      };

      var animationManager = function () {
        var moduleOb = {};
        var registeredAnimations = [];
        var initTime = 0;
        var len = 0;
        var playingAnimationsNum = 0;
        var _stopped = true;
        var _isFrozen = false;

        function removeElement(ev) {
          var i = 0;
          var animItem = ev.target;

          while (i < len) {
            if (registeredAnimations[i].animation === animItem) {
              registeredAnimations.splice(i, 1);
              i -= 1;
              len -= 1;

              if (!animItem.isPaused) {
                subtractPlayingCount();
              }
            }

            i += 1;
          }
        }

        function registerAnimation(element, animationData) {
          if (!element) {
            return null;
          }

          var i = 0;

          while (i < len) {
            if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
              return registeredAnimations[i].animation;
            }

            i += 1;
          }

          var animItem = new AnimationItem();
          setupAnimation(animItem, element);
          animItem.setData(element, animationData);
          return animItem;
        }

        function getRegisteredAnimations() {
          var i;
          var lenAnims = registeredAnimations.length;
          var animations = [];

          for (i = 0; i < lenAnims; i += 1) {
            animations.push(registeredAnimations[i].animation);
          }

          return animations;
        }

        function addPlayingCount() {
          playingAnimationsNum += 1;
          activate();
        }

        function subtractPlayingCount() {
          playingAnimationsNum -= 1;
        }

        function setupAnimation(animItem, element) {
          animItem.addEventListener('destroy', removeElement);
          animItem.addEventListener('_active', addPlayingCount);
          animItem.addEventListener('_idle', subtractPlayingCount);
          registeredAnimations.push({
            elem: element,
            animation: animItem
          });
          len += 1;
        }

        function loadAnimation(params) {
          var animItem = new AnimationItem();
          setupAnimation(animItem, null);
          animItem.setParams(params);
          return animItem;
        }

        function setSpeed(val, animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setSpeed(val, animation);
          }
        }

        function setDirection(val, animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setDirection(val, animation);
          }
        }

        function play(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.play(animation);
          }
        }

        function resume(nowTime) {
          var elapsedTime = nowTime - initTime;
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.advanceTime(elapsedTime);
          }

          initTime = nowTime;

          if (playingAnimationsNum && !_isFrozen) {
            window.requestAnimationFrame(resume);
          } else {
            _stopped = true;
          }
        }

        function first(nowTime) {
          initTime = nowTime;
          window.requestAnimationFrame(resume);
        }

        function pause(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.pause(animation);
          }
        }

        function goToAndStop(value, isFrame, animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
          }
        }

        function stop(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.stop(animation);
          }
        }

        function togglePause(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.togglePause(animation);
          }
        }

        function destroy(animation) {
          var i;

          for (i = len - 1; i >= 0; i -= 1) {
            registeredAnimations[i].animation.destroy(animation);
          }
        }

        function searchAnimations(animationData, standalone, renderer) {
          var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));
          var i;
          var lenAnims = animElements.length;

          for (i = 0; i < lenAnims; i += 1) {
            if (renderer) {
              animElements[i].setAttribute('data-bm-type', renderer);
            }

            registerAnimation(animElements[i], animationData);
          }

          if (standalone && lenAnims === 0) {
            if (!renderer) {
              renderer = 'svg';
            }

            var body = document.getElementsByTagName('body')[0];
            body.innerText = '';
            var div = createTag('div');
            div.style.width = '100%';
            div.style.height = '100%';
            div.setAttribute('data-bm-type', renderer);
            body.appendChild(div);
            registerAnimation(div, animationData);
          }
        }

        function resize() {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.resize();
          }
        }

        function activate() {
          if (!_isFrozen && playingAnimationsNum) {
            if (_stopped) {
              window.requestAnimationFrame(first);
              _stopped = false;
            }
          }
        }

        function freeze() {
          _isFrozen = true;
        }

        function unfreeze() {
          _isFrozen = false;
          activate();
        }

        function setVolume(val, animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.setVolume(val, animation);
          }
        }

        function mute(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.mute(animation);
          }
        }

        function unmute(animation) {
          var i;

          for (i = 0; i < len; i += 1) {
            registeredAnimations[i].animation.unmute(animation);
          }
        }

        moduleOb.registerAnimation = registerAnimation;
        moduleOb.loadAnimation = loadAnimation;
        moduleOb.setSpeed = setSpeed;
        moduleOb.setDirection = setDirection;
        moduleOb.play = play;
        moduleOb.pause = pause;
        moduleOb.stop = stop;
        moduleOb.togglePause = togglePause;
        moduleOb.searchAnimations = searchAnimations;
        moduleOb.resize = resize; // moduleOb.start = start;

        moduleOb.goToAndStop = goToAndStop;
        moduleOb.destroy = destroy;
        moduleOb.freeze = freeze;
        moduleOb.unfreeze = unfreeze;
        moduleOb.setVolume = setVolume;
        moduleOb.mute = mute;
        moduleOb.unmute = unmute;
        moduleOb.getRegisteredAnimations = getRegisteredAnimations;
        return moduleOb;
      }();

      /* eslint-disable */
      var BezierFactory = function () {
        /**
           * BezierEasing - use bezier curve for transition easing function
           * by Gaëtan Renaudeau 2014 - 2015 – MIT License
           *
           * Credits: is based on Firefox's nsSMILKeySpline.cpp
           * Usage:
           * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
           * spline.get(x) => returns the easing value | x must be in [0, 1] range
           *
           */
        var ob = {};
        ob.getBezierEasing = getBezierEasing;
        var beziers = {};

        function getBezierEasing(a, b, c, d, nm) {
          var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');

          if (beziers[str]) {
            return beziers[str];
          }

          var bezEasing = new BezierEasing([a, b, c, d]);
          beziers[str] = bezEasing;
          return bezEasing;
        } // These values are established by empiricism with tests (tradeoff: performance VS precision)


        var NEWTON_ITERATIONS = 4;
        var NEWTON_MIN_SLOPE = 0.001;
        var SUBDIVISION_PRECISION = 0.0000001;
        var SUBDIVISION_MAX_ITERATIONS = 10;
        var kSplineTableSize = 11;
        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
        var float32ArraySupported = typeof Float32Array === 'function';

        function A(aA1, aA2) {
          return 1.0 - 3.0 * aA2 + 3.0 * aA1;
        }

        function B(aA1, aA2) {
          return 3.0 * aA2 - 6.0 * aA1;
        }

        function C(aA1) {
          return 3.0 * aA1;
        } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


        function calcBezier(aT, aA1, aA2) {
          return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
        } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


        function getSlope(aT, aA1, aA2) {
          return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
        }

        function binarySubdivide(aX, aA, aB, mX1, mX2) {
          var currentX,
              currentT,
              i = 0;

          do {
            currentT = aA + (aB - aA) / 2.0;
            currentX = calcBezier(currentT, mX1, mX2) - aX;

            if (currentX > 0.0) {
              aB = currentT;
            } else {
              aA = currentT;
            }
          } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

          return currentT;
        }

        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
          for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
            var currentSlope = getSlope(aGuessT, mX1, mX2);
            if (currentSlope === 0.0) return aGuessT;
            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
            aGuessT -= currentX / currentSlope;
          }

          return aGuessT;
        }
        /**
           * points is an array of [ mX1, mY1, mX2, mY2 ]
           */


        function BezierEasing(points) {
          this._p = points;
          this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
          this._precomputed = false;
          this.get = this.get.bind(this);
        }

        BezierEasing.prototype = {
          get: function get(x) {
            var mX1 = this._p[0],
                mY1 = this._p[1],
                mX2 = this._p[2],
                mY2 = this._p[3];
            if (!this._precomputed) this._precompute();
            if (mX1 === mY1 && mX2 === mY2) return x; // linear
            // Because JavaScript number are imprecise, we should guarantee the extremes are right.

            if (x === 0) return 0;
            if (x === 1) return 1;
            return calcBezier(this._getTForX(x), mY1, mY2);
          },
          // Private part
          _precompute: function _precompute() {
            var mX1 = this._p[0],
                mY1 = this._p[1],
                mX2 = this._p[2],
                mY2 = this._p[3];
            this._precomputed = true;

            if (mX1 !== mY1 || mX2 !== mY2) {
              this._calcSampleValues();
            }
          },
          _calcSampleValues: function _calcSampleValues() {
            var mX1 = this._p[0],
                mX2 = this._p[2];

            for (var i = 0; i < kSplineTableSize; ++i) {
              this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
            }
          },

          /**
               * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
               */
          _getTForX: function _getTForX(aX) {
            var mX1 = this._p[0],
                mX2 = this._p[2],
                mSampleValues = this._mSampleValues;
            var intervalStart = 0.0;
            var currentSample = 1;
            var lastSample = kSplineTableSize - 1;

            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
              intervalStart += kSampleStepSize;
            }

            --currentSample; // Interpolate to provide an initial guess for t

            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
            var guessForT = intervalStart + dist * kSampleStepSize;
            var initialSlope = getSlope(guessForT, mX1, mX2);

            if (initialSlope >= NEWTON_MIN_SLOPE) {
              return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
            }

            if (initialSlope === 0.0) {
              return guessForT;
            }

            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }
        };
        return ob;
      }();

      var pooling = function () {
        function _double(arr) {
          return arr.concat(createSizedArray(arr.length));
        }

        return {
          "double": _double
        };
      }();

      var poolFactory = function () {
        return function (initialLength, _create, _release) {
          var _length = 0;
          var _maxLength = initialLength;
          var pool = createSizedArray(_maxLength);
          var ob = {
            newElement: newElement,
            release: release
          };

          function newElement() {
            var element;

            if (_length) {
              _length -= 1;
              element = pool[_length];
            } else {
              element = _create();
            }

            return element;
          }

          function release(element) {
            if (_length === _maxLength) {
              pool = pooling["double"](pool);
              _maxLength *= 2;
            }

            if (_release) {
              _release(element);
            }

            pool[_length] = element;
            _length += 1;
          }

          return ob;
        };
      }();

      var bezierLengthPool = function () {
        function create() {
          return {
            addedLength: 0,
            percents: createTypedArray('float32', getDefaultCurveSegments()),
            lengths: createTypedArray('float32', getDefaultCurveSegments())
          };
        }

        return poolFactory(8, create);
      }();

      var segmentsLengthPool = function () {
        function create() {
          return {
            lengths: [],
            totalLength: 0
          };
        }

        function release(element) {
          var i;
          var len = element.lengths.length;

          for (i = 0; i < len; i += 1) {
            bezierLengthPool.release(element.lengths[i]);
          }

          element.lengths.length = 0;
        }

        return poolFactory(8, create, release);
      }();

      function bezFunction() {
        var math = Math;

        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
          var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;
          return det1 > -0.001 && det1 < 0.001;
        }

        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
          if (z1 === 0 && z2 === 0 && z3 === 0) {
            return pointOnLine2D(x1, y1, x2, y2, x3, y3);
          }

          var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
          var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
          var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
          var diffDist;

          if (dist1 > dist2) {
            if (dist1 > dist3) {
              diffDist = dist1 - dist2 - dist3;
            } else {
              diffDist = dist3 - dist2 - dist1;
            }
          } else if (dist3 > dist2) {
            diffDist = dist3 - dist2 - dist1;
          } else {
            diffDist = dist2 - dist1 - dist3;
          }

          return diffDist > -0.0001 && diffDist < 0.0001;
        }

        var getBezierLength = function () {
          return function (pt1, pt2, pt3, pt4) {
            var curveSegments = getDefaultCurveSegments();
            var k;
            var i;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point = [];
            var lastPoint = [];
            var lengthData = bezierLengthPool.newElement();
            len = pt3.length;

            for (k = 0; k < curveSegments; k += 1) {
              perc = k / (curveSegments - 1);
              ptDistance = 0;

              for (i = 0; i < len; i += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
                point[i] = ptCoord;

                if (lastPoint[i] !== null) {
                  ptDistance += bmPow(point[i] - lastPoint[i], 2);
                }

                lastPoint[i] = point[i];
              }

              if (ptDistance) {
                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
              }

              lengthData.percents[k] = perc;
              lengthData.lengths[k] = addedLength;
            }

            lengthData.addedLength = addedLength;
            return lengthData;
          };
        }();

        function getSegmentsLength(shapeData) {
          var segmentsLength = segmentsLengthPool.newElement();
          var closed = shapeData.c;
          var pathV = shapeData.v;
          var pathO = shapeData.o;
          var pathI = shapeData.i;
          var i;
          var len = shapeData._length;
          var lengths = segmentsLength.lengths;
          var totalLength = 0;

          for (i = 0; i < len - 1; i += 1) {
            lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
            totalLength += lengths[i].addedLength;
          }

          if (closed && len) {
            lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
            totalLength += lengths[i].addedLength;
          }

          segmentsLength.totalLength = totalLength;
          return segmentsLength;
        }

        function BezierData(length) {
          this.segmentLength = 0;
          this.points = new Array(length);
        }

        function PointData(partial, point) {
          this.partialLength = partial;
          this.point = point;
        }

        var buildBezierData = function () {
          var storedData = {};
          return function (pt1, pt2, pt3, pt4) {
            var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');

            if (!storedData[bezierName]) {
              var curveSegments = getDefaultCurveSegments();
              var k;
              var i;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point;
              var lastPoint = null;

              if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                curveSegments = 2;
              }

              var bezierData = new BezierData(curveSegments);
              len = pt3.length;

              for (k = 0; k < curveSegments; k += 1) {
                point = createSizedArray(len);
                perc = k / (curveSegments - 1);
                ptDistance = 0;

                for (i = 0; i < len; i += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                  point[i] = ptCoord;

                  if (lastPoint !== null) {
                    ptDistance += bmPow(point[i] - lastPoint[i], 2);
                  }
                }

                ptDistance = bmSqrt(ptDistance);
                addedLength += ptDistance;
                bezierData.points[k] = new PointData(ptDistance, point);
                lastPoint = point;
              }

              bezierData.segmentLength = addedLength;
              storedData[bezierName] = bezierData;
            }

            return storedData[bezierName];
          };
        }();

        function getDistancePerc(perc, bezierData) {
          var percents = bezierData.percents;
          var lengths = bezierData.lengths;
          var len = percents.length;
          var initPos = bmFloor((len - 1) * perc);
          var lengthPos = perc * bezierData.addedLength;
          var lPerc = 0;

          if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
            return percents[initPos];
          }

          var dir = lengths[initPos] > lengthPos ? -1 : 1;
          var flag = true;

          while (flag) {
            if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
              lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
              flag = false;
            } else {
              initPos += dir;
            }

            if (initPos < 0 || initPos >= len - 1) {
              // FIX for TypedArrays that don't store floating point values with enough accuracy
              if (initPos === len - 1) {
                return percents[initPos];
              }

              flag = false;
            }
          }

          return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
        }

        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
          var t1 = getDistancePerc(percent, bezierData);
          var u1 = 1 - t1;
          var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
          var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
          return [ptX, ptY];
        }

        var bezierSegmentPoints = createTypedArray('float32', 8);

        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
          if (startPerc < 0) {
            startPerc = 0;
          } else if (startPerc > 1) {
            startPerc = 1;
          }

          var t0 = getDistancePerc(startPerc, bezierData);
          endPerc = endPerc > 1 ? 1 : endPerc;
          var t1 = getDistancePerc(endPerc, bezierData);
          var i;
          var len = pt1.length;
          var u0 = 1 - t0;
          var u1 = 1 - t1;
          var u0u0u0 = u0 * u0 * u0;
          var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase

          var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase

          var t0t0t0 = t0 * t0 * t0; //

          var u0u0u1 = u0 * u0 * u1;
          var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase

          var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase

          var t0t0t1 = t0 * t0 * t1; //

          var u0u1u1 = u0 * u1 * u1;
          var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase

          var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase

          var t0t1t1 = t0 * t1 * t1; //

          var u1u1u1 = u1 * u1 * u1;
          var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase

          var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase

          var t1t1t1 = t1 * t1 * t1;

          for (i = 0; i < len; i += 1) {
            bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

            bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

            bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase

            bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
          }

          return bezierSegmentPoints;
        }

        return {
          getSegmentsLength: getSegmentsLength,
          getNewSegment: getNewSegment,
          getPointInSegment: getPointInSegment,
          buildBezierData: buildBezierData,
          pointOnLine2D: pointOnLine2D,
          pointOnLine3D: pointOnLine3D
        };
      }

      var bez = bezFunction();

      var PropertyFactory = function () {
        var initFrame = initialDefaultFrame;
        var mathAbs = Math.abs;

        function interpolateValue(frameNum, caching) {
          var offsetTime = this.offsetTime;
          var newValue;

          if (this.propType === 'multidimensional') {
            newValue = createTypedArray('float32', this.pv.length);
          }

          var iterationIndex = caching.lastIndex;
          var i = iterationIndex;
          var len = this.keyframes.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;

          while (flag) {
            keyData = this.keyframes[i];
            nextKeyData = this.keyframes[i + 1];

            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
              if (keyData.h) {
                keyData = nextKeyData;
              }

              iterationIndex = 0;
              break;
            }

            if (nextKeyData.t - offsetTime > frameNum) {
              iterationIndex = i;
              break;
            }

            if (i < len - 1) {
              i += 1;
            } else {
              iterationIndex = 0;
              flag = false;
            }
          }

          keyframeMetadata = this.keyframesMetadata[i] || {};
          var k;
          var kLen;
          var perc;
          var jLen;
          var j;
          var fnc;
          var nextKeyTime = nextKeyData.t - offsetTime;
          var keyTime = keyData.t - offsetTime;
          var endValue;

          if (keyData.to) {
            if (!keyframeMetadata.bezierData) {
              keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
            }

            var bezierData = keyframeMetadata.bezierData;

            if (frameNum >= nextKeyTime || frameNum < keyTime) {
              var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
              kLen = bezierData.points[ind].point.length;

              for (k = 0; k < kLen; k += 1) {
                newValue[k] = bezierData.points[ind].point[k];
              } // caching._lastKeyframeIndex = -1;

            } else {
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                keyframeMetadata.__fnct = fnc;
              }

              perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
              var distanceInLine = bezierData.segmentLength * perc;
              var segmentPerc;
              var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;
              j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;
              flag = true;
              jLen = bezierData.points.length;

              while (flag) {
                addedLength += bezierData.points[j].partialLength;

                if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                  kLen = bezierData.points[j].point.length;

                  for (k = 0; k < kLen; k += 1) {
                    newValue[k] = bezierData.points[j].point[k];
                  }

                  break;
                } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                  segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                  kLen = bezierData.points[j].point.length;

                  for (k = 0; k < kLen; k += 1) {
                    newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                  }

                  break;
                }

                if (j < jLen - 1) {
                  j += 1;
                } else {
                  flag = false;
                }
              }

              caching._lastPoint = j;
              caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
              caching._lastKeyframeIndex = i;
            }
          } else {
            var outX;
            var outY;
            var inX;
            var inY;
            var keyValue;
            len = keyData.s.length;
            endValue = nextKeyData.s || keyData.e;

            if (this.sh && keyData.h !== 1) {
              if (frameNum >= nextKeyTime) {
                newValue[0] = endValue[0];
                newValue[1] = endValue[1];
                newValue[2] = endValue[2];
              } else if (frameNum <= keyTime) {
                newValue[0] = keyData.s[0];
                newValue[1] = keyData.s[1];
                newValue[2] = keyData.s[2];
              } else {
                var quatStart = createQuaternion(keyData.s);
                var quatEnd = createQuaternion(endValue);
                var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
              }
            } else {
              for (i = 0; i < len; i += 1) {
                if (keyData.h !== 1) {
                  if (frameNum >= nextKeyTime) {
                    perc = 1;
                  } else if (frameNum < keyTime) {
                    perc = 0;
                  } else {
                    if (keyData.o.x.constructor === Array) {
                      if (!keyframeMetadata.__fnct) {
                        keyframeMetadata.__fnct = [];
                      }

                      if (!keyframeMetadata.__fnct[i]) {
                        outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
                        outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
                        inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
                        inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                        keyframeMetadata.__fnct[i] = fnc;
                      } else {
                        fnc = keyframeMetadata.__fnct[i];
                      }
                    } else if (!keyframeMetadata.__fnct) {
                      outX = keyData.o.x;
                      outY = keyData.o.y;
                      inX = keyData.i.x;
                      inY = keyData.i.y;
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyData.keyframeMetadata = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct;
                    }

                    perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                  }
                }

                endValue = nextKeyData.s || keyData.e;
                keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

                if (this.propType === 'multidimensional') {
                  newValue[i] = keyValue;
                } else {
                  newValue = keyValue;
                }
              }
            }
          }

          caching.lastIndex = iterationIndex;
          return newValue;
        } // based on @Toji's https://github.com/toji/gl-matrix/


        function slerp(a, b, t) {
          var out = [];
          var ax = a[0];
          var ay = a[1];
          var az = a[2];
          var aw = a[3];
          var bx = b[0];
          var by = b[1];
          var bz = b[2];
          var bw = b[3];
          var omega;
          var cosom;
          var sinom;
          var scale0;
          var scale1;
          cosom = ax * bx + ay * by + az * bz + aw * bw;

          if (cosom < 0.0) {
            cosom = -cosom;
            bx = -bx;
            by = -by;
            bz = -bz;
            bw = -bw;
          }

          if (1.0 - cosom > 0.000001) {
            omega = Math.acos(cosom);
            sinom = Math.sin(omega);
            scale0 = Math.sin((1.0 - t) * omega) / sinom;
            scale1 = Math.sin(t * omega) / sinom;
          } else {
            scale0 = 1.0 - t;
            scale1 = t;
          }

          out[0] = scale0 * ax + scale1 * bx;
          out[1] = scale0 * ay + scale1 * by;
          out[2] = scale0 * az + scale1 * bz;
          out[3] = scale0 * aw + scale1 * bw;
          return out;
        }

        function quaternionToEuler(out, quat) {
          var qx = quat[0];
          var qy = quat[1];
          var qz = quat[2];
          var qw = quat[3];
          var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
          var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
          var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
          out[0] = heading / degToRads;
          out[1] = attitude / degToRads;
          out[2] = bank / degToRads;
        }

        function createQuaternion(values) {
          var heading = values[0] * degToRads;
          var attitude = values[1] * degToRads;
          var bank = values[2] * degToRads;
          var c1 = Math.cos(heading / 2);
          var c2 = Math.cos(attitude / 2);
          var c3 = Math.cos(bank / 2);
          var s1 = Math.sin(heading / 2);
          var s2 = Math.sin(attitude / 2);
          var s3 = Math.sin(bank / 2);
          var w = c1 * c2 * c3 - s1 * s2 * s3;
          var x = s1 * s2 * c3 + c1 * c2 * s3;
          var y = s1 * c2 * c3 + c1 * s2 * s3;
          var z = c1 * s2 * c3 - s1 * c2 * s3;
          return [x, y, z, w];
        }

        function getValueAtCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;

          if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
            if (this._caching.lastFrame >= frameNum) {
              this._caching._lastKeyframeIndex = -1;
              this._caching.lastIndex = 0;
            }

            var renderResult = this.interpolateValue(frameNum, this._caching);
            this.pv = renderResult;
          }

          this._caching.lastFrame = frameNum;
          return this.pv;
        }

        function setVValue(val) {
          var multipliedValue;

          if (this.propType === 'unidimensional') {
            multipliedValue = val * this.mult;

            if (mathAbs(this.v - multipliedValue) > 0.00001) {
              this.v = multipliedValue;
              this._mdf = true;
            }
          } else {
            var i = 0;
            var len = this.v.length;

            while (i < len) {
              multipliedValue = val[i] * this.mult;

              if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
                this.v[i] = multipliedValue;
                this._mdf = true;
              }

              i += 1;
            }
          }
        }

        function processEffectsSequence() {
          if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
            return;
          }

          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }

          this.lock = true;
          this._mdf = this._isFirstFrame;
          var i;
          var len = this.effectsSequence.length;
          var finalValue = this.kf ? this.pv : this.data.k;

          for (i = 0; i < len; i += 1) {
            finalValue = this.effectsSequence[i](finalValue);
          }

          this.setVValue(finalValue);
          this._isFirstFrame = false;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }

        function addEffect(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }

        function ValueProperty(elem, data, mult, container) {
          this.propType = 'unidimensional';
          this.mult = mult || 1;
          this.data = data;
          this.v = mult ? data.k * mult : data.k;
          this.pv = data.k;
          this._mdf = false;
          this.elem = elem;
          this.container = container;
          this.comp = elem.comp;
          this.k = false;
          this.kf = false;
          this.vel = 0;
          this.effectsSequence = [];
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }

        function MultiDimensionalProperty(elem, data, mult, container) {
          this.propType = 'multidimensional';
          this.mult = mult || 1;
          this.data = data;
          this._mdf = false;
          this.elem = elem;
          this.container = container;
          this.comp = elem.comp;
          this.k = false;
          this.kf = false;
          this.frameId = -1;
          var i;
          var len = data.k.length;
          this.v = createTypedArray('float32', len);
          this.pv = createTypedArray('float32', len);
          this.vel = createTypedArray('float32', len);

          for (i = 0; i < len; i += 1) {
            this.v[i] = data.k[i] * this.mult;
            this.pv[i] = data.k[i];
          }

          this._isFirstFrame = true;
          this.effectsSequence = [];
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.addEffect = addEffect;
        }

        function KeyframedValueProperty(elem, data, mult, container) {
          this.propType = 'unidimensional';
          this.keyframes = data.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem.data.st;
          this.frameId = -1;
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1
          };
          this.k = true;
          this.kf = true;
          this.data = data;
          this.mult = mult || 1;
          this.elem = elem;
          this.container = container;
          this.comp = elem.comp;
          this.v = initFrame;
          this.pv = initFrame;
          this._isFirstFrame = true;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.addEffect = addEffect;
        }

        function KeyframedMultidimensionalProperty(elem, data, mult, container) {
          this.propType = 'multidimensional';
          var i;
          var len = data.k.length;
          var s;
          var e;
          var to;
          var ti;

          for (i = 0; i < len - 1; i += 1) {
            if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
              s = data.k[i].s;
              e = data.k[i + 1].s;
              to = data.k[i].to;
              ti = data.k[i].ti;

              if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {
                data.k[i].to = null;
                data.k[i].ti = null;
              }

              if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {
                  data.k[i].to = null;
                  data.k[i].ti = null;
                }
              }
            }
          }

          this.effectsSequence = [getValueAtCurrentTime.bind(this)];
          this.data = data;
          this.keyframes = data.k;
          this.keyframesMetadata = [];
          this.offsetTime = elem.data.st;
          this.k = true;
          this.kf = true;
          this._isFirstFrame = true;
          this.mult = mult || 1;
          this.elem = elem;
          this.container = container;
          this.comp = elem.comp;
          this.getValue = processEffectsSequence;
          this.setVValue = setVValue;
          this.interpolateValue = interpolateValue;
          this.frameId = -1;
          var arrLen = data.k[0].s.length;
          this.v = createTypedArray('float32', arrLen);
          this.pv = createTypedArray('float32', arrLen);

          for (i = 0; i < arrLen; i += 1) {
            this.v[i] = initFrame;
            this.pv[i] = initFrame;
          }

          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: createTypedArray('float32', arrLen)
          };
          this.addEffect = addEffect;
        }

        function getProp(elem, data, type, mult, container) {
          var p;

          if (!data.k.length) {
            p = new ValueProperty(elem, data, mult, container);
          } else if (typeof data.k[0] === 'number') {
            p = new MultiDimensionalProperty(elem, data, mult, container);
          } else {
            switch (type) {
              case 0:
                p = new KeyframedValueProperty(elem, data, mult, container);
                break;

              case 1:
                p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                break;
            }
          }

          if (p.effectsSequence.length) {
            container.addDynamicProperty(p);
          }

          return p;
        }

        var ob = {
          getProp: getProp
        };
        return ob;
      }();

      function DynamicPropertyContainer() {}

      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
            this.container.addDynamicProperty(this);
            this._isAnimated = true;
          }
        },
        iterateDynamicProperties: function iterateDynamicProperties() {
          this._mdf = false;
          var i;
          var len = this.dynamicProperties.length;

          for (i = 0; i < len; i += 1) {
            this.dynamicProperties[i].getValue();

            if (this.dynamicProperties[i]._mdf) {
              this._mdf = true;
            }
          }
        },
        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {
          this.container = container;
          this.dynamicProperties = [];
          this._mdf = false;
          this._isAnimated = false;
        }
      };

      var pointPool = function () {
        function create() {
          return createTypedArray('float32', 2);
        }

        return poolFactory(8, create);
      }();

      function ShapePath() {
        this.c = false;
        this._length = 0;
        this._maxLength = 8;
        this.v = createSizedArray(this._maxLength);
        this.o = createSizedArray(this._maxLength);
        this.i = createSizedArray(this._maxLength);
      }

      ShapePath.prototype.setPathData = function (closed, len) {
        this.c = closed;
        this.setLength(len);
        var i = 0;

        while (i < len) {
          this.v[i] = pointPool.newElement();
          this.o[i] = pointPool.newElement();
          this.i[i] = pointPool.newElement();
          i += 1;
        }
      };

      ShapePath.prototype.setLength = function (len) {
        while (this._maxLength < len) {
          this.doubleArrayLength();
        }

        this._length = len;
      };

      ShapePath.prototype.doubleArrayLength = function () {
        this.v = this.v.concat(createSizedArray(this._maxLength));
        this.i = this.i.concat(createSizedArray(this._maxLength));
        this.o = this.o.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      };

      ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
        var arr;
        this._length = Math.max(this._length, pos + 1);

        if (this._length >= this._maxLength) {
          this.doubleArrayLength();
        }

        switch (type) {
          case 'v':
            arr = this.v;
            break;

          case 'i':
            arr = this.i;
            break;

          case 'o':
            arr = this.o;
            break;

          default:
            arr = [];
            break;
        }

        if (!arr[pos] || arr[pos] && !replace) {
          arr[pos] = pointPool.newElement();
        }

        arr[pos][0] = x;
        arr[pos][1] = y;
      };

      ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
        this.setXYAt(vX, vY, 'v', pos, replace);
        this.setXYAt(oX, oY, 'o', pos, replace);
        this.setXYAt(iX, iY, 'i', pos, replace);
      };

      ShapePath.prototype.reverse = function () {
        var newPath = new ShapePath();
        newPath.setPathData(this.c, this._length);
        var vertices = this.v;
        var outPoints = this.o;
        var inPoints = this.i;
        var init = 0;

        if (this.c) {
          newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
          init = 1;
        }

        var cnt = this._length - 1;
        var len = this._length;
        var i;

        for (i = init; i < len; i += 1) {
          newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
          cnt -= 1;
        }

        return newPath;
      };

      var shapePool = function () {
        function create() {
          return new ShapePath();
        }

        function release(shapePath) {
          var len = shapePath._length;
          var i;

          for (i = 0; i < len; i += 1) {
            pointPool.release(shapePath.v[i]);
            pointPool.release(shapePath.i[i]);
            pointPool.release(shapePath.o[i]);
            shapePath.v[i] = null;
            shapePath.i[i] = null;
            shapePath.o[i] = null;
          }

          shapePath._length = 0;
          shapePath.c = false;
        }

        function clone(shape) {
          var cloned = factory.newElement();
          var i;
          var len = shape._length === undefined ? shape.v.length : shape._length;
          cloned.setLength(len);
          cloned.c = shape.c;

          for (i = 0; i < len; i += 1) {
            cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
          }

          return cloned;
        }

        var factory = poolFactory(4, create, release);
        factory.clone = clone;
        return factory;
      }();

      function ShapeCollection() {
        this._length = 0;
        this._maxLength = 4;
        this.shapes = createSizedArray(this._maxLength);
      }

      ShapeCollection.prototype.addShape = function (shapeData) {
        if (this._length === this._maxLength) {
          this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        }

        this.shapes[this._length] = shapeData;
        this._length += 1;
      };

      ShapeCollection.prototype.releaseShapes = function () {
        var i;

        for (i = 0; i < this._length; i += 1) {
          shapePool.release(this.shapes[i]);
        }

        this._length = 0;
      };

      var shapeCollectionPool = function () {
        var ob = {
          newShapeCollection: newShapeCollection,
          release: release
        };
        var _length = 0;
        var _maxLength = 4;
        var pool = createSizedArray(_maxLength);

        function newShapeCollection() {
          var shapeCollection;

          if (_length) {
            _length -= 1;
            shapeCollection = pool[_length];
          } else {
            shapeCollection = new ShapeCollection();
          }

          return shapeCollection;
        }

        function release(shapeCollection) {
          var i;
          var len = shapeCollection._length;

          for (i = 0; i < len; i += 1) {
            shapePool.release(shapeCollection.shapes[i]);
          }

          shapeCollection._length = 0;

          if (_length === _maxLength) {
            pool = pooling["double"](pool);
            _maxLength *= 2;
          }

          pool[_length] = shapeCollection;
          _length += 1;
        }

        return ob;
      }();

      var ShapePropertyFactory = function () {
        var initFrame = -999999;

        function interpolateShape(frameNum, previousValue, caching) {
          var iterationIndex = caching.lastIndex;
          var keyPropS;
          var keyPropE;
          var isHold;
          var j;
          var k;
          var jLen;
          var kLen;
          var perc;
          var vertexValue;
          var kf = this.keyframes;

          if (frameNum < kf[0].t - this.offsetTime) {
            keyPropS = kf[0].s[0];
            isHold = true;
            iterationIndex = 0;
          } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
            keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
            /* if(kf[kf.length - 1].s){
                      keyPropS = kf[kf.length - 1].s[0];
                  }else{
                      keyPropS = kf[kf.length - 2].e[0];
                  } */

            isHold = true;
          } else {
            var i = iterationIndex;
            var len = kf.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;

            while (flag) {
              keyData = kf[i];
              nextKeyData = kf[i + 1];

              if (nextKeyData.t - this.offsetTime > frameNum) {
                break;
              }

              if (i < len - 1) {
                i += 1;
              } else {
                flag = false;
              }
            }

            keyframeMetadata = this.keyframesMetadata[i] || {};
            isHold = keyData.h === 1;
            iterationIndex = i;

            if (!isHold) {
              if (frameNum >= nextKeyData.t - this.offsetTime) {
                perc = 1;
              } else if (frameNum < keyData.t - this.offsetTime) {
                perc = 0;
              } else {
                var fnc;

                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                  keyframeMetadata.__fnct = fnc;
                }

                perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
              }

              keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
            }

            keyPropS = keyData.s[0];
          }

          jLen = previousValue._length;
          kLen = keyPropS.i[0].length;
          caching.lastIndex = iterationIndex;

          for (j = 0; j < jLen; j += 1) {
            for (k = 0; k < kLen; k += 1) {
              vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
              previousValue.i[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
              previousValue.o[j][k] = vertexValue;
              vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
              previousValue.v[j][k] = vertexValue;
            }
          }
        }

        function interpolateShapeCurrentTime() {
          var frameNum = this.comp.renderedFrame - this.offsetTime;
          var initTime = this.keyframes[0].t - this.offsetTime;
          var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
          var lastFrame = this._caching.lastFrame;

          if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
            /// /
            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
            this.interpolateShape(frameNum, this.pv, this._caching); /// /
          }

          this._caching.lastFrame = frameNum;
          return this.pv;
        }

        function resetShape() {
          this.paths = this.localShapeCollection;
        }

        function shapesEqual(shape1, shape2) {
          if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
            return false;
          }

          var i;
          var len = shape1._length;

          for (i = 0; i < len; i += 1) {
            if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {
              return false;
            }
          }

          return true;
        }

        function setVValue(newPath) {
          if (!shapesEqual(this.v, newPath)) {
            this.v = shapePool.clone(newPath);
            this.localShapeCollection.releaseShapes();
            this.localShapeCollection.addShape(this.v);
            this._mdf = true;
            this.paths = this.localShapeCollection;
          }
        }

        function processEffectsSequence() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }

          if (!this.effectsSequence.length) {
            this._mdf = false;
            return;
          }

          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }

          this.lock = true;
          this._mdf = false;
          var finalValue;

          if (this.kf) {
            finalValue = this.pv;
          } else if (this.data.ks) {
            finalValue = this.data.ks.k;
          } else {
            finalValue = this.data.pt.k;
          }

          var i;
          var len = this.effectsSequence.length;

          for (i = 0; i < len; i += 1) {
            finalValue = this.effectsSequence[i](finalValue);
          }

          this.setVValue(finalValue);
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        }

        function ShapeProperty(elem, data, type) {
          this.propType = 'shape';
          this.comp = elem.comp;
          this.container = elem;
          this.elem = elem;
          this.data = data;
          this.k = false;
          this.kf = false;
          this._mdf = false;
          var pathData = type === 3 ? data.pt.k : data.ks.k;
          this.v = shapePool.clone(pathData);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.reset = resetShape;
          this.effectsSequence = [];
        }

        function addEffect(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.container.addDynamicProperty(this);
        }

        ShapeProperty.prototype.interpolateShape = interpolateShape;
        ShapeProperty.prototype.getValue = processEffectsSequence;
        ShapeProperty.prototype.setVValue = setVValue;
        ShapeProperty.prototype.addEffect = addEffect;

        function KeyframedShapeProperty(elem, data, type) {
          this.propType = 'shape';
          this.comp = elem.comp;
          this.elem = elem;
          this.container = elem;
          this.offsetTime = elem.data.st;
          this.keyframes = type === 3 ? data.pt.k : data.ks.k;
          this.keyframesMetadata = [];
          this.k = true;
          this.kf = true;
          var len = this.keyframes[0].s[0].i.length;
          this.v = shapePool.newElement();
          this.v.setPathData(this.keyframes[0].s[0].c, len);
          this.pv = shapePool.clone(this.v);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.paths.addShape(this.v);
          this.lastFrame = initFrame;
          this.reset = resetShape;
          this._caching = {
            lastFrame: initFrame,
            lastIndex: 0
          };
          this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
        }

        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
        KeyframedShapeProperty.prototype.setVValue = setVValue;
        KeyframedShapeProperty.prototype.addEffect = addEffect;

        var EllShapeProperty = function () {
          var cPoint = roundCorner;

          function EllShapePropertyFactory(elem, data) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 4);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.localShapeCollection.addShape(this.v);
            this.d = data.d;
            this.elem = elem;
            this.comp = elem.comp;
            this.frameId = -1;
            this.initDynamicPropertyContainer(elem);
            this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);

            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertEllToPath();
            }
          }

          EllShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }

              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();

              if (this._mdf) {
                this.convertEllToPath();
              }
            },
            convertEllToPath: function convertEllToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var s0 = this.s.v[0] / 2;
              var s1 = this.s.v[1] / 2;

              var _cw = this.d !== 3;

              var _v = this.v;
              _v.v[0][0] = p0;
              _v.v[0][1] = p1 - s1;
              _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.v[1][1] = p1;
              _v.v[2][0] = p0;
              _v.v[2][1] = p1 + s1;
              _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.v[3][1] = p1;
              _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.i[0][1] = p1 - s1;
              _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.i[1][1] = p1 - s1 * cPoint;
              _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.i[2][1] = p1 + s1;
              _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.i[3][1] = p1 + s1 * cPoint;
              _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
              _v.o[0][1] = p1 - s1;
              _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
              _v.o[1][1] = p1 + s1 * cPoint;
              _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
              _v.o[2][1] = p1 + s1;
              _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
              _v.o[3][1] = p1 - s1 * cPoint;
            }
          };
          extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
          return EllShapePropertyFactory;
        }();

        var StarShapeProperty = function () {
          function StarShapePropertyFactory(elem, data) {
            this.v = shapePool.newElement();
            this.v.setPathData(true, 0);
            this.elem = elem;
            this.comp = elem.comp;
            this.data = data;
            this.frameId = -1;
            this.d = data.d;
            this.initDynamicPropertyContainer(elem);

            if (data.sy === 1) {
              this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
              this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
              this.convertToPath = this.convertStarToPath;
            } else {
              this.convertToPath = this.convertPolygonToPath;
            }

            this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
            this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
            this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
            this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
            this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;

            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertToPath();
            }
          }

          StarShapePropertyFactory.prototype = {
            reset: resetShape,
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }

              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();

              if (this._mdf) {
                this.convertToPath();
              }
            },
            convertStarToPath: function convertStarToPath() {
              var numPts = Math.floor(this.pt.v) * 2;
              var angle = Math.PI * 2 / numPts;
              /* this.v.v.length = numPts;
                      this.v.i.length = numPts;
                      this.v.o.length = numPts; */

              var longFlag = true;
              var longRad = this.or.v;
              var shortRad = this.ir.v;
              var longRound = this.os.v;
              var shortRound = this.is.v;
              var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
              var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
              var i;
              var rad;
              var roundness;
              var perimSegment;
              var currentAng = -Math.PI / 2;
              currentAng += this.r.v;
              var dir = this.data.d === 3 ? -1 : 1;
              this.v._length = 0;

              for (i = 0; i < numPts; i += 1) {
                rad = longFlag ? longRad : shortRad;
                roundness = longFlag ? longRound : shortRound;
                perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                /* this.v.v[i] = [x,y];
                          this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                          this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                          this.v._length = numPts; */

                longFlag = !longFlag;
                currentAng += angle * dir;
              }
            },
            convertPolygonToPath: function convertPolygonToPath() {
              var numPts = Math.floor(this.pt.v);
              var angle = Math.PI * 2 / numPts;
              var rad = this.or.v;
              var roundness = this.os.v;
              var perimSegment = 2 * Math.PI * rad / (numPts * 4);
              var i;
              var currentAng = -Math.PI * 0.5;
              var dir = this.data.d === 3 ? -1 : 1;
              currentAng += this.r.v;
              this.v._length = 0;

              for (i = 0; i < numPts; i += 1) {
                var x = rad * Math.cos(currentAng);
                var y = rad * Math.sin(currentAng);
                var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
                var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
                x += +this.p.v[0];
                y += +this.p.v[1];
                this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
                currentAng += angle * dir;
              }

              this.paths.length = 0;
              this.paths[0] = this.v;
            }
          };
          extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
          return StarShapePropertyFactory;
        }();

        var RectShapeProperty = function () {
          function RectShapePropertyFactory(elem, data) {
            this.v = shapePool.newElement();
            this.v.c = true;
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.localShapeCollection.addShape(this.v);
            this.paths = this.localShapeCollection;
            this.elem = elem;
            this.comp = elem.comp;
            this.frameId = -1;
            this.d = data.d;
            this.initDynamicPropertyContainer(elem);
            this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
            this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
            this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);

            if (this.dynamicProperties.length) {
              this.k = true;
            } else {
              this.k = false;
              this.convertRectToPath();
            }
          }

          RectShapePropertyFactory.prototype = {
            convertRectToPath: function convertRectToPath() {
              var p0 = this.p.v[0];
              var p1 = this.p.v[1];
              var v0 = this.s.v[0] / 2;
              var v1 = this.s.v[1] / 2;
              var round = bmMin(v0, v1, this.r.v);
              var cPoint = round * (1 - roundCorner);
              this.v._length = 0;

              if (this.d === 2 || this.d === 1) {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);

                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                }
              } else {
                this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);

                if (round !== 0) {
                  this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                  this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                  this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                  this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                } else {
                  this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                  this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                }
              }
            },
            getValue: function getValue() {
              if (this.elem.globalData.frameId === this.frameId) {
                return;
              }

              this.frameId = this.elem.globalData.frameId;
              this.iterateDynamicProperties();

              if (this._mdf) {
                this.convertRectToPath();
              }
            },
            reset: resetShape
          };
          extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
          return RectShapePropertyFactory;
        }();

        function getShapeProp(elem, data, type) {
          var prop;

          if (type === 3 || type === 4) {
            var dataProp = type === 3 ? data.pt : data.ks;
            var keys = dataProp.k;

            if (keys.length) {
              prop = new KeyframedShapeProperty(elem, data, type);
            } else {
              prop = new ShapeProperty(elem, data, type);
            }
          } else if (type === 5) {
            prop = new RectShapeProperty(elem, data);
          } else if (type === 6) {
            prop = new EllShapeProperty(elem, data);
          } else if (type === 7) {
            prop = new StarShapeProperty(elem, data);
          }

          if (prop.k) {
            elem.addDynamicProperty(prop);
          }

          return prop;
        }

        function getConstructorFunction() {
          return ShapeProperty;
        }

        function getKeyframedConstructorFunction() {
          return KeyframedShapeProperty;
        }

        var ob = {};
        ob.getShapeProp = getShapeProp;
        ob.getConstructorFunction = getConstructorFunction;
        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
        return ob;
      }();

      /*!
       Transformation Matrix v2.0
       (c) Epistemex 2014-2015
       www.epistemex.com
       By Ken Fyrstenberg
       Contributions by leeoniya.
       License: MIT, header required.
       */

      /**
       * 2D transformation matrix object initialized with identity matrix.
       *
       * The matrix can synchronize a canvas context by supplying the context
       * as an argument, or later apply current absolute transform to an
       * existing context.
       *
       * All values are handled as floating point values.
       *
       * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
       * @prop {number} a - scale x
       * @prop {number} b - shear y
       * @prop {number} c - shear x
       * @prop {number} d - scale y
       * @prop {number} e - translate x
       * @prop {number} f - translate y
       * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
       * @constructor
       */

      var Matrix = function () {
        var _cos = Math.cos;
        var _sin = Math.sin;
        var _tan = Math.tan;
        var _rnd = Math.round;

        function reset() {
          this.props[0] = 1;
          this.props[1] = 0;
          this.props[2] = 0;
          this.props[3] = 0;
          this.props[4] = 0;
          this.props[5] = 1;
          this.props[6] = 0;
          this.props[7] = 0;
          this.props[8] = 0;
          this.props[9] = 0;
          this.props[10] = 1;
          this.props[11] = 0;
          this.props[12] = 0;
          this.props[13] = 0;
          this.props[14] = 0;
          this.props[15] = 1;
          return this;
        }

        function rotate(angle) {
          if (angle === 0) {
            return this;
          }

          var mCos = _cos(angle);

          var mSin = _sin(angle);

          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        function rotateX(angle) {
          if (angle === 0) {
            return this;
          }

          var mCos = _cos(angle);

          var mSin = _sin(angle);

          return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
        }

        function rotateY(angle) {
          if (angle === 0) {
            return this;
          }

          var mCos = _cos(angle);

          var mSin = _sin(angle);

          return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
        }

        function rotateZ(angle) {
          if (angle === 0) {
            return this;
          }

          var mCos = _cos(angle);

          var mSin = _sin(angle);

          return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        }

        function shear(sx, sy) {
          return this._t(1, sy, sx, 1, 0, 0);
        }

        function skew(ax, ay) {
          return this.shear(_tan(ax), _tan(ay));
        }

        function skewFromAxis(ax, angle) {
          var mCos = _cos(angle);

          var mSin = _sin(angle);

          return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
        }

        function scale(sx, sy, sz) {
          if (!sz && sz !== 0) {
            sz = 1;
          }

          if (sx === 1 && sy === 1 && sz === 1) {
            return this;
          }

          return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
        }

        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
          this.props[0] = a;
          this.props[1] = b;
          this.props[2] = c;
          this.props[3] = d;
          this.props[4] = e;
          this.props[5] = f;
          this.props[6] = g;
          this.props[7] = h;
          this.props[8] = i;
          this.props[9] = j;
          this.props[10] = k;
          this.props[11] = l;
          this.props[12] = m;
          this.props[13] = n;
          this.props[14] = o;
          this.props[15] = p;
          return this;
        }

        function translate(tx, ty, tz) {
          tz = tz || 0;

          if (tx !== 0 || ty !== 0 || tz !== 0) {
            return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
          }

          return this;
        }

        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
          var _p = this.props;

          if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
            // NOTE: commenting this condition because TurboFan deoptimizes code when present
            // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
            _p[12] = _p[12] * a2 + _p[15] * m2;
            _p[13] = _p[13] * f2 + _p[15] * n2;
            _p[14] = _p[14] * k2 + _p[15] * o2;
            _p[15] *= p2; // }

            this._identityCalculated = false;
            return this;
          }

          var a1 = _p[0];
          var b1 = _p[1];
          var c1 = _p[2];
          var d1 = _p[3];
          var e1 = _p[4];
          var f1 = _p[5];
          var g1 = _p[6];
          var h1 = _p[7];
          var i1 = _p[8];
          var j1 = _p[9];
          var k1 = _p[10];
          var l1 = _p[11];
          var m1 = _p[12];
          var n1 = _p[13];
          var o1 = _p[14];
          var p1 = _p[15];
          /* matrix order (canvas compatible):
               * ace
               * bdf
               * 001
               */

          _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
          _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
          _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
          _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;
          _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
          _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
          _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
          _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;
          _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
          _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
          _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
          _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;
          _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
          _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
          _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
          _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;
          this._identityCalculated = false;
          return this;
        }

        function isIdentity() {
          if (!this._identityCalculated) {
            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
            this._identityCalculated = true;
          }

          return this._identity;
        }

        function equals(matr) {
          var i = 0;

          while (i < 16) {
            if (matr.props[i] !== this.props[i]) {
              return false;
            }

            i += 1;
          }

          return true;
        }

        function clone(matr) {
          var i;

          for (i = 0; i < 16; i += 1) {
            matr.props[i] = this.props[i];
          }

          return matr;
        }

        function cloneFromProps(props) {
          var i;

          for (i = 0; i < 16; i += 1) {
            this.props[i] = props[i];
          }
        }

        function applyToPoint(x, y, z) {
          return {
            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]
          };
          /* return {
               x: x * me.a + y * me.c + me.e,
               y: x * me.b + y * me.d + me.f
               }; */
        }

        function applyToX(x, y, z) {
          return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
        }

        function applyToY(x, y, z) {
          return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
        }

        function applyToZ(x, y, z) {
          return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
        }

        function getInverseMatrix() {
          var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
          var a = this.props[5] / determinant;
          var b = -this.props[1] / determinant;
          var c = -this.props[4] / determinant;
          var d = this.props[0] / determinant;
          var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
          var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
          var inverseMatrix = new Matrix();
          inverseMatrix.props[0] = a;
          inverseMatrix.props[1] = b;
          inverseMatrix.props[4] = c;
          inverseMatrix.props[5] = d;
          inverseMatrix.props[12] = e;
          inverseMatrix.props[13] = f;
          return inverseMatrix;
        }

        function inversePoint(pt) {
          var inverseMatrix = this.getInverseMatrix();
          return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
        }

        function inversePoints(pts) {
          var i;
          var len = pts.length;
          var retPts = [];

          for (i = 0; i < len; i += 1) {
            retPts[i] = inversePoint(pts[i]);
          }

          return retPts;
        }

        function applyToTriplePoints(pt1, pt2, pt3) {
          var arr = createTypedArray('float32', 6);

          if (this.isIdentity()) {
            arr[0] = pt1[0];
            arr[1] = pt1[1];
            arr[2] = pt2[0];
            arr[3] = pt2[1];
            arr[4] = pt3[0];
            arr[5] = pt3[1];
          } else {
            var p0 = this.props[0];
            var p1 = this.props[1];
            var p4 = this.props[4];
            var p5 = this.props[5];
            var p12 = this.props[12];
            var p13 = this.props[13];
            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
          }

          return arr;
        }

        function applyToPointArray(x, y, z) {
          var arr;

          if (this.isIdentity()) {
            arr = [x, y, z];
          } else {
            arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12], x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13], x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];
          }

          return arr;
        }

        function applyToPointStringified(x, y) {
          if (this.isIdentity()) {
            return x + ',' + y;
          }

          var _p = this.props;
          return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
        }

        function toCSS() {
          // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

          /* if(this.isIdentity()) {
                  return '';
              } */
          var i = 0;
          var props = this.props;
          var cssValue = 'matrix3d(';
          var v = 10000;

          while (i < 16) {
            cssValue += _rnd(props[i] * v) / v;
            cssValue += i === 15 ? ')' : ',';
            i += 1;
          }

          return cssValue;
        }

        function roundMatrixProperty(val) {
          var v = 10000;

          if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {
            return _rnd(val * v) / v;
          }

          return val;
        }

        function to2dCSS() {
          // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.

          /* if(this.isIdentity()) {
                  return '';
              } */
          var props = this.props;

          var _a = roundMatrixProperty(props[0]);

          var _b = roundMatrixProperty(props[1]);

          var _c = roundMatrixProperty(props[4]);

          var _d = roundMatrixProperty(props[5]);

          var _e = roundMatrixProperty(props[12]);

          var _f = roundMatrixProperty(props[13]);

          return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
        }

        return function () {
          this.reset = reset;
          this.rotate = rotate;
          this.rotateX = rotateX;
          this.rotateY = rotateY;
          this.rotateZ = rotateZ;
          this.skew = skew;
          this.skewFromAxis = skewFromAxis;
          this.shear = shear;
          this.scale = scale;
          this.setTransform = setTransform;
          this.translate = translate;
          this.transform = transform;
          this.applyToPoint = applyToPoint;
          this.applyToX = applyToX;
          this.applyToY = applyToY;
          this.applyToZ = applyToZ;
          this.applyToPointArray = applyToPointArray;
          this.applyToTriplePoints = applyToTriplePoints;
          this.applyToPointStringified = applyToPointStringified;
          this.toCSS = toCSS;
          this.to2dCSS = to2dCSS;
          this.clone = clone;
          this.cloneFromProps = cloneFromProps;
          this.equals = equals;
          this.inversePoints = inversePoints;
          this.inversePoint = inversePoint;
          this.getInverseMatrix = getInverseMatrix;
          this._t = this.transform;
          this.isIdentity = isIdentity;
          this._identity = true;
          this._identityCalculated = false;
          this.props = createTypedArray('float32', 16);
          this.reset();
        };
      }();

      function _typeof$3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }
      var lottie = {};

      function setLocation(href) {
        setLocationHref(href);
      }

      function searchAnimations() {
        {
          animationManager.searchAnimations();
        }
      }

      function setSubframeRendering(flag) {
        setSubframeEnabled(flag);
      }

      function setPrefix(prefix) {
        setIdPrefix(prefix);
      }

      function loadAnimation(params) {

        return animationManager.loadAnimation(params);
      }

      function setQuality(value) {
        if (typeof value === 'string') {
          switch (value) {
            case 'high':
              setDefaultCurveSegments(200);
              break;

            default:
            case 'medium':
              setDefaultCurveSegments(50);
              break;

            case 'low':
              setDefaultCurveSegments(10);
              break;
          }
        } else if (!isNaN(value) && value > 1) {
          setDefaultCurveSegments(value);
        }
      }

      function inBrowser() {
        return typeof navigator !== 'undefined';
      }

      function installPlugin(type, plugin) {
        if (type === 'expressions') {
          setExpressionsPlugin(plugin);
        }
      }

      function getFactory(name) {
        switch (name) {
          case 'propertyFactory':
            return PropertyFactory;

          case 'shapePropertyFactory':
            return ShapePropertyFactory;

          case 'matrix':
            return Matrix;

          default:
            return null;
        }
      }

      lottie.play = animationManager.play;
      lottie.pause = animationManager.pause;
      lottie.setLocationHref = setLocation;
      lottie.togglePause = animationManager.togglePause;
      lottie.setSpeed = animationManager.setSpeed;
      lottie.setDirection = animationManager.setDirection;
      lottie.stop = animationManager.stop;
      lottie.searchAnimations = searchAnimations;
      lottie.registerAnimation = animationManager.registerAnimation;
      lottie.loadAnimation = loadAnimation;
      lottie.setSubframeRendering = setSubframeRendering;
      lottie.resize = animationManager.resize; // lottie.start = start;

      lottie.goToAndStop = animationManager.goToAndStop;
      lottie.destroy = animationManager.destroy;
      lottie.setQuality = setQuality;
      lottie.inBrowser = inBrowser;
      lottie.installPlugin = installPlugin;
      lottie.freeze = animationManager.freeze;
      lottie.unfreeze = animationManager.unfreeze;
      lottie.setVolume = animationManager.setVolume;
      lottie.mute = animationManager.mute;
      lottie.unmute = animationManager.unmute;
      lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
      lottie.useWebWorker = setWebWorker;
      lottie.setIDPrefix = setPrefix;
      lottie.__getFactory = getFactory;
      lottie.version = '5.9.4';

      function checkReady() {
        if (document.readyState === 'complete') {
          clearInterval(readyStateCheckInterval);
          searchAnimations();
        }
      }

      function getQueryVariable(variable) {
        var vars = queryString.split('&');

        for (var i = 0; i < vars.length; i += 1) {
          var pair = vars[i].split('=');

          if (decodeURIComponent(pair[0]) == variable) {
            // eslint-disable-line eqeqeq
            return decodeURIComponent(pair[1]);
          }
        }

        return null;
      }

      var queryString = '';

      {
        var scripts = document.getElementsByTagName('script');
        var index = scripts.length - 1;
        var myScript = scripts[index] || {
          src: ''
        };
        queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, '') : ''; // eslint-disable-line no-useless-escape

        getQueryVariable('renderer');
      }

      var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility

      try {
        if (!(('object' === "undefined" ? "undefined" : _typeof$3(exports)) === 'object' && 'object' !== 'undefined') && !(typeof undefined === 'function' && undefined.amd) // eslint-disable-line no-undef
        ) {
          window.bodymovin = lottie;
        }
      } catch (err) {//
      }

      var ShapeModifiers = function () {
        var ob = {};
        var modifiers = {};
        ob.registerModifier = registerModifier;
        ob.getModifier = getModifier;

        function registerModifier(nm, factory) {
          if (!modifiers[nm]) {
            modifiers[nm] = factory;
          }
        }

        function getModifier(nm, elem, data) {
          return new modifiers[nm](elem, data);
        }

        return ob;
      }();

      function ShapeModifier() {}

      ShapeModifier.prototype.initModifierProperties = function () {};

      ShapeModifier.prototype.addShapeToModifier = function () {};

      ShapeModifier.prototype.addShape = function (data) {
        if (!this.closed) {
          // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
          data.sh.container.addDynamicProperty(data.sh);
          var shapeData = {
            shape: data.sh,
            data: data,
            localShapeCollection: shapeCollectionPool.newShapeCollection()
          };
          this.shapes.push(shapeData);
          this.addShapeToModifier(shapeData);

          if (this._isAnimated) {
            data.setAsAnimated();
          }
        }
      };

      ShapeModifier.prototype.init = function (elem, data) {
        this.shapes = [];
        this.elem = elem;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem, data);
        this.frameId = initialDefaultFrame;
        this.closed = false;
        this.k = false;

        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };

      ShapeModifier.prototype.processKeys = function () {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }

        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
      };

      extendPrototype([DynamicPropertyContainer], ShapeModifier);

      function TrimModifier() {}

      extendPrototype([ShapeModifier], TrimModifier);

      TrimModifier.prototype.initModifierProperties = function (elem, data) {
        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
        this.sValue = 0;
        this.eValue = 0;
        this.getValue = this.processKeys;
        this.m = data.m;
        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
      };

      TrimModifier.prototype.addShapeToModifier = function (shapeData) {
        shapeData.pathsData = [];
      };

      TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
        var segments = [];

        if (e <= 1) {
          segments.push({
            s: s,
            e: e
          });
        } else if (s >= 1) {
          segments.push({
            s: s - 1,
            e: e - 1
          });
        } else {
          segments.push({
            s: s,
            e: 1
          });
          segments.push({
            s: 0,
            e: e - 1
          });
        }

        var shapeSegments = [];
        var i;
        var len = segments.length;
        var segmentOb;

        for (i = 0; i < len; i += 1) {
          segmentOb = segments[i];

          if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
            var shapeS;
            var shapeE;

            if (segmentOb.s * totalModifierLength <= addedLength) {
              shapeS = 0;
            } else {
              shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
            }

            if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
              shapeE = 1;
            } else {
              shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
            }

            shapeSegments.push([shapeS, shapeE]);
          }
        }

        if (!shapeSegments.length) {
          shapeSegments.push([0, 0]);
        }

        return shapeSegments;
      };

      TrimModifier.prototype.releasePathsData = function (pathsData) {
        var i;
        var len = pathsData.length;

        for (i = 0; i < len; i += 1) {
          segmentsLengthPool.release(pathsData[i]);
        }

        pathsData.length = 0;
        return pathsData;
      };

      TrimModifier.prototype.processShapes = function (_isFirstFrame) {
        var s;
        var e;

        if (this._mdf || _isFirstFrame) {
          var o = this.o.v % 360 / 360;

          if (o < 0) {
            o += 1;
          }

          if (this.s.v > 1) {
            s = 1 + o;
          } else if (this.s.v < 0) {
            s = 0 + o;
          } else {
            s = this.s.v + o;
          }

          if (this.e.v > 1) {
            e = 1 + o;
          } else if (this.e.v < 0) {
            e = 0 + o;
          } else {
            e = this.e.v + o;
          }

          if (s > e) {
            var _s = s;
            s = e;
            e = _s;
          }

          s = Math.round(s * 10000) * 0.0001;
          e = Math.round(e * 10000) * 0.0001;
          this.sValue = s;
          this.eValue = e;
        } else {
          s = this.sValue;
          e = this.eValue;
        }

        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var pathsData;
        var pathData;
        var totalShapeLength;
        var totalModifierLength = 0;

        if (e === s) {
          for (i = 0; i < len; i += 1) {
            this.shapes[i].localShapeCollection.releaseShapes();
            this.shapes[i].shape._mdf = true;
            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;

            if (this._mdf) {
              this.shapes[i].pathsData.length = 0;
            }
          }
        } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {
          var segments = [];
          var shapeData;
          var localShapeCollection;

          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used

            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
              shapeData.shape.paths = shapeData.localShapeCollection;
            } else {
              shapePaths = shapeData.shape.paths;
              jLen = shapePaths._length;
              totalShapeLength = 0;

              if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                totalShapeLength = shapeData.totalShapeLength;
              } else {
                pathsData = this.releasePathsData(shapeData.pathsData);

                for (j = 0; j < jLen; j += 1) {
                  pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                  pathsData.push(pathData);
                  totalShapeLength += pathData.totalLength;
                }

                shapeData.totalShapeLength = totalShapeLength;
                shapeData.pathsData = pathsData;
              }

              totalModifierLength += totalShapeLength;
              shapeData.shape._mdf = true;
            }
          }

          var shapeS = s;
          var shapeE = e;
          var addedLength = 0;
          var edges;

          for (i = len - 1; i >= 0; i -= 1) {
            shapeData = this.shapes[i];

            if (shapeData.shape._mdf) {
              localShapeCollection = shapeData.localShapeCollection;
              localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group

              if (this.m === 2 && len > 1) {
                edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
                addedLength += shapeData.totalShapeLength;
              } else {
                edges = [[shapeS, shapeE]];
              }

              jLen = edges.length;

              for (j = 0; j < jLen; j += 1) {
                shapeS = edges[j][0];
                shapeE = edges[j][1];
                segments.length = 0;

                if (shapeE <= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength * shapeE
                  });
                } else if (shapeS >= 1) {
                  segments.push({
                    s: shapeData.totalShapeLength * (shapeS - 1),
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                } else {
                  segments.push({
                    s: shapeData.totalShapeLength * shapeS,
                    e: shapeData.totalShapeLength
                  });
                  segments.push({
                    s: 0,
                    e: shapeData.totalShapeLength * (shapeE - 1)
                  });
                }

                var newShapesData = this.addShapes(shapeData, segments[0]);

                if (segments[0].s !== segments[0].e) {
                  if (segments.length > 1) {
                    var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];

                    if (lastShapeInCollection.c) {
                      var lastShape = newShapesData.pop();
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                    } else {
                      this.addPaths(newShapesData, localShapeCollection);
                      newShapesData = this.addShapes(shapeData, segments[1]);
                    }
                  }

                  this.addPaths(newShapesData, localShapeCollection);
                }
              }

              shapeData.shape.paths = localShapeCollection;
            }
          }
        } else if (this._mdf) {
          for (i = 0; i < len; i += 1) {
            // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
            // Don't remove this even if it's losing cached info.
            this.shapes[i].pathsData.length = 0;
            this.shapes[i].shape._mdf = true;
          }
        }
      };

      TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
        var i;
        var len = newPaths.length;

        for (i = 0; i < len; i += 1) {
          localShapeCollection.addShape(newPaths[i]);
        }
      };

      TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
        shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
        shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);

        if (newShape) {
          shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
        }

        shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
      };

      TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
        shapePath.setXYAt(points[1], points[5], 'o', pos);
        shapePath.setXYAt(points[2], points[6], 'i', pos + 1);

        if (newShape) {
          shapePath.setXYAt(points[0], points[4], 'v', pos);
        }

        shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
      };

      TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
        var pathsData = shapeData.pathsData;
        var shapePaths = shapeData.shape.paths.shapes;
        var i;
        var len = shapeData.shape.paths._length;
        var j;
        var jLen;
        var addedLength = 0;
        var currentLengthData;
        var segmentCount;
        var lengths;
        var segment;
        var shapes = [];
        var initPos;
        var newShape = true;

        if (!shapePath) {
          shapePath = shapePool.newElement();
          segmentCount = 0;
          initPos = 0;
        } else {
          segmentCount = shapePath._length;
          initPos = shapePath._length;
        }

        shapes.push(shapePath);

        for (i = 0; i < len; i += 1) {
          lengths = pathsData[i].lengths;
          shapePath.c = shapePaths[i].c;
          jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;

          for (j = 1; j < jLen; j += 1) {
            currentLengthData = lengths[j - 1];

            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
              addedLength += currentLengthData.addedLength;
              shapePath.c = false;
            } else if (addedLength > shapeSegment.e) {
              shapePath.c = false;
              break;
            } else {
              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                newShape = false;
                shapePath.c = false;
              }

              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
          }

          if (shapePaths[i].c && lengths.length) {
            currentLengthData = lengths[j - 1];

            if (addedLength <= shapeSegment.e) {
              var segmentLength = lengths[j - 1].addedLength;

              if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
                newShape = false;
              } else {
                segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
                this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);

                newShape = false;
                shapePath.c = false;
              }
            } else {
              shapePath.c = false;
            }

            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }

          if (shapePath._length) {
            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
          }

          if (addedLength > shapeSegment.e) {
            break;
          }

          if (i < len - 1) {
            shapePath = shapePool.newElement();
            newShape = true;
            shapes.push(shapePath);
            segmentCount = 0;
          }
        }

        return shapes;
      };

      function PuckerAndBloatModifier() {}

      extendPrototype([ShapeModifier], PuckerAndBloatModifier);

      PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
        this.getValue = this.processKeys;
        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
        this._isAnimated = !!this.amount.effectsSequence.length;
      };

      PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
        var percent = amount / 100;
        var centerPoint = [0, 0];
        var pathLength = path._length;
        var i = 0;

        for (i = 0; i < pathLength; i += 1) {
          centerPoint[0] += path.v[i][0];
          centerPoint[1] += path.v[i][1];
        }

        centerPoint[0] /= pathLength;
        centerPoint[1] /= pathLength;
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;

        for (i = 0; i < pathLength; i += 1) {
          vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
          vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
          oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
          oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
          iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
          iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
          clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
        }

        return clonedPath;
      };

      PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var amount = this.amount.v;

        if (amount !== 0) {
          var shapeData;
          var localShapeCollection;

          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;

            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;

              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
              }
            }

            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }

        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };

      var TransformPropertyFactory = function () {
        var defaultVector = [0, 0];

        function applyToMatrix(mat) {
          var _mdf = this._mdf;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || _mdf;

          if (this.a) {
            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }

          if (this.s) {
            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }

          if (this.sk) {
            mat.skewFromAxis(-this.sk.v, this.sa.v);
          }

          if (this.r) {
            mat.rotate(-this.r.v);
          } else {
            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
          }

          if (this.data.p.s) {
            if (this.data.p.z) {
              mat.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              mat.translate(this.px.v, this.py.v, 0);
            }
          } else {
            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }

        function processKeys(forceRender) {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }

          if (this._isDirty) {
            this.precalculateMatrix();
            this._isDirty = false;
          }

          this.iterateDynamicProperties();

          if (this._mdf || forceRender) {
            var frameRate;
            this.v.cloneFromProps(this.pre.props);

            if (this.appliedTransformations < 1) {
              this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }

            if (this.appliedTransformations < 2) {
              this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }

            if (this.sk && this.appliedTransformations < 3) {
              this.v.skewFromAxis(-this.sk.v, this.sa.v);
            }

            if (this.r && this.appliedTransformations < 4) {
              this.v.rotate(-this.r.v);
            } else if (!this.r && this.appliedTransformations < 4) {
              this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }

            if (this.autoOriented) {
              var v1;
              var v2;
              frameRate = this.elem.globalData.frameRate;

              if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                  v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                  v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                  v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                  v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                } else {
                  v1 = this.p.pv;
                  v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                }
              } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                v1 = [];
                v2 = [];
                var px = this.px;
                var py = this.py;

                if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                  v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                  v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                  v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                  v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                  v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                  v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                  v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                } else {
                  v1 = [px.pv, py.pv];
                  v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                  v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                }
              } else {
                v2 = defaultVector;
                v1 = v2;
              }

              this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
            }

            if (this.data.p && this.data.p.s) {
              if (this.data.p.z) {
                this.v.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                this.v.translate(this.px.v, this.py.v, 0);
              }
            } else {
              this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }

          this.frameId = this.elem.globalData.frameId;
        }

        function precalculateMatrix() {
          if (!this.a.k) {
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            this.appliedTransformations = 1;
          } else {
            return;
          }

          if (!this.s.effectsSequence.length) {
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            this.appliedTransformations = 2;
          } else {
            return;
          }

          if (this.sk) {
            if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
              this.pre.skewFromAxis(-this.sk.v, this.sa.v);
              this.appliedTransformations = 3;
            } else {
              return;
            }
          }

          if (this.r) {
            if (!this.r.effectsSequence.length) {
              this.pre.rotate(-this.r.v);
              this.appliedTransformations = 4;
            }
          } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            this.appliedTransformations = 4;
          }
        }

        function autoOrient() {//
          // var prevP = this.getValueAtTime();
        }

        function addDynamicProperty(prop) {
          this._addDynamicProperty(prop);

          this.elem.addDynamicProperty(prop);
          this._isDirty = true;
        }

        function TransformProperty(elem, data, container) {
          this.elem = elem;
          this.frameId = -1;
          this.propType = 'transform';
          this.data = data;
          this.v = new Matrix(); // Precalculated matrix with non animated properties

          this.pre = new Matrix();
          this.appliedTransformations = 0;
          this.initDynamicPropertyContainer(container || elem);

          if (data.p && data.p.s) {
            this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
            this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);

            if (data.p.z) {
              this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
            }
          } else {
            this.p = PropertyFactory.getProp(elem, data.p || {
              k: [0, 0, 0]
            }, 1, 0, this);
          }

          if (data.rx) {
            this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
            this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
            this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);

            if (data.or.k[0].ti) {
              var i;
              var len = data.or.k.length;

              for (i = 0; i < len; i += 1) {
                data.or.k[i].to = null;
                data.or.k[i].ti = null;
              }
            }

            this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180

            this.or.sh = true;
          } else {
            this.r = PropertyFactory.getProp(elem, data.r || {
              k: 0
            }, 0, degToRads, this);
          }

          if (data.sk) {
            this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
            this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
          }

          this.a = PropertyFactory.getProp(elem, data.a || {
            k: [0, 0, 0]
          }, 1, 0, this);
          this.s = PropertyFactory.getProp(elem, data.s || {
            k: [100, 100, 100]
          }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.

          if (data.o) {
            this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
          } else {
            this.o = {
              _mdf: false,
              v: 1
            };
          }

          this._isDirty = true;

          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
        }

        TransformProperty.prototype = {
          applyToMatrix: applyToMatrix,
          getValue: processKeys,
          precalculateMatrix: precalculateMatrix,
          autoOrient: autoOrient
        };
        extendPrototype([DynamicPropertyContainer], TransformProperty);
        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

        function getTransformProperty(elem, data, container) {
          return new TransformProperty(elem, data, container);
        }

        return {
          getTransformProperty: getTransformProperty
        };
      }();

      function RepeaterModifier() {}

      extendPrototype([ShapeModifier], RepeaterModifier);

      RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
        this.getValue = this.processKeys;
        this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
        this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
        this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
        this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
        this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
        this.data = data;

        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }

        this._isAnimated = !!this.dynamicProperties.length;
        this.pMatrix = new Matrix();
        this.rMatrix = new Matrix();
        this.sMatrix = new Matrix();
        this.tMatrix = new Matrix();
        this.matrix = new Matrix();
      };

      RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
        var dir = inv ? -1 : 1;
        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        rMatrix.rotate(-transform.r.v * dir * perc);
        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
      };

      RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
        this.elem = elem;
        this.arr = arr;
        this.pos = pos;
        this.elemsData = elemsData;
        this._currentCopies = 0;
        this._elements = [];
        this._groups = [];
        this.frameId = -1;
        this.initDynamicPropertyContainer(elem);
        this.initModifierProperties(elem, arr[pos]);

        while (pos > 0) {
          pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);

          this._elements.unshift(arr[pos]);
        }

        if (this.dynamicProperties.length) {
          this.k = true;
        } else {
          this.getValue(true);
        }
      };

      RepeaterModifier.prototype.resetElements = function (elements) {
        var i;
        var len = elements.length;

        for (i = 0; i < len; i += 1) {
          elements[i]._processed = false;

          if (elements[i].ty === 'gr') {
            this.resetElements(elements[i].it);
          }
        }
      };

      RepeaterModifier.prototype.cloneElements = function (elements) {
        var newElements = JSON.parse(JSON.stringify(elements));
        this.resetElements(newElements);
        return newElements;
      };

      RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
        var i;
        var len = elements.length;

        for (i = 0; i < len; i += 1) {
          elements[i]._render = renderFlag;

          if (elements[i].ty === 'gr') {
            this.changeGroupRender(elements[i].it, renderFlag);
          }
        }
      };

      RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
        var items;
        var itemsTransform;
        var i;
        var dir;
        var cont;
        var hasReloaded = false;

        if (this._mdf || _isFirstFrame) {
          var copies = Math.ceil(this.c.v);

          if (this._groups.length < copies) {
            while (this._groups.length < copies) {
              var group = {
                it: this.cloneElements(this._elements),
                ty: 'gr'
              };
              group.it.push({
                a: {
                  a: 0,
                  ix: 1,
                  k: [0, 0]
                },
                nm: 'Transform',
                o: {
                  a: 0,
                  ix: 7,
                  k: 100
                },
                p: {
                  a: 0,
                  ix: 2,
                  k: [0, 0]
                },
                r: {
                  a: 1,
                  ix: 6,
                  k: [{
                    s: 0,
                    e: 0,
                    t: 0
                  }, {
                    s: 0,
                    e: 0,
                    t: 1
                  }]
                },
                s: {
                  a: 0,
                  ix: 3,
                  k: [100, 100]
                },
                sa: {
                  a: 0,
                  ix: 5,
                  k: 0
                },
                sk: {
                  a: 0,
                  ix: 4,
                  k: 0
                },
                ty: 'tr'
              });
              this.arr.splice(0, 0, group);

              this._groups.splice(0, 0, group);

              this._currentCopies += 1;
            }

            this.elem.reloadShapes();
            hasReloaded = true;
          }

          cont = 0;
          var renderFlag;

          for (i = 0; i <= this._groups.length - 1; i += 1) {
            renderFlag = cont < copies;
            this._groups[i]._render = renderFlag;
            this.changeGroupRender(this._groups[i].it, renderFlag);

            if (!renderFlag) {
              var elems = this.elemsData[i].it;
              var transformData = elems[elems.length - 1];

              if (transformData.transform.op.v !== 0) {
                transformData.transform.op._mdf = true;
                transformData.transform.op.v = 0;
              } else {
                transformData.transform.op._mdf = false;
              }
            }

            cont += 1;
          }

          this._currentCopies = copies; /// /

          var offset = this.o.v;
          var offsetModulo = offset % 1;
          var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
          var pProps = this.pMatrix.props;
          var rProps = this.rMatrix.props;
          var sProps = this.sMatrix.props;
          this.pMatrix.reset();
          this.rMatrix.reset();
          this.sMatrix.reset();
          this.tMatrix.reset();
          this.matrix.reset();
          var iteration = 0;

          if (offset > 0) {
            while (iteration < roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              iteration += 1;
            }

            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
              iteration += offsetModulo;
            }
          } else if (offset < 0) {
            while (iteration > roundOffset) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
              iteration -= 1;
            }

            if (offsetModulo) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
              iteration -= offsetModulo;
            }
          }

          i = this.data.m === 1 ? 0 : this._currentCopies - 1;
          dir = this.data.m === 1 ? 1 : -1;
          cont = this._currentCopies;
          var j;
          var jLen;

          while (cont) {
            items = this.elemsData[i].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            jLen = itemsTransform.length;
            items[items.length - 1].transform.mProps._mdf = true;
            items[items.length - 1].transform.op._mdf = true;
            items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

            if (iteration !== 0) {
              if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
              }

              this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
              this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
              this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }

              this.matrix.reset();
            } else {
              this.matrix.reset();

              for (j = 0; j < jLen; j += 1) {
                itemsTransform[j] = this.matrix.props[j];
              }
            }

            iteration += 1;
            cont -= 1;
            i += dir;
          }
        } else {
          cont = this._currentCopies;
          i = 0;
          dir = 1;

          while (cont) {
            items = this.elemsData[i].it;
            itemsTransform = items[items.length - 1].transform.mProps.v.props;
            items[items.length - 1].transform.mProps._mdf = false;
            items[items.length - 1].transform.op._mdf = false;
            cont -= 1;
            i += dir;
          }
        }

        return hasReloaded;
      };

      RepeaterModifier.prototype.addShape = function () {};

      function RoundCornersModifier() {}

      extendPrototype([ShapeModifier], RoundCornersModifier);

      RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
        this.getValue = this.processKeys;
        this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
        this._isAnimated = !!this.rd.effectsSequence.length;
      };

      RoundCornersModifier.prototype.processPath = function (path, round) {
        var clonedPath = shapePool.newElement();
        clonedPath.c = path.c;
        var i;
        var len = path._length;
        var currentV;
        var currentI;
        var currentO;
        var closerV;
        var distance;
        var newPosPerc;
        var index = 0;
        var vX;
        var vY;
        var oX;
        var oY;
        var iX;
        var iY;

        for (i = 0; i < len; i += 1) {
          currentV = path.v[i];
          currentO = path.o[i];
          currentI = path.i[i];

          if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
            if ((i === 0 || i === len - 1) && !path.c) {
              clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
              /* clonedPath.v[index] = currentV;
                      clonedPath.o[index] = currentO;
                      clonedPath.i[index] = currentI; */

              index += 1;
            } else {
              if (i === 0) {
                closerV = path.v[len - 1];
              } else {
                closerV = path.v[i - 1];
              }

              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = iX;
              iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
              vY = iY;
              oX = vX - (vX - currentV[0]) * roundCorner;
              oY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
              index += 1;

              if (i === len - 1) {
                closerV = path.v[0];
              } else {
                closerV = path.v[i + 1];
              }

              distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
              newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
              oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
              vX = oX;
              oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
              vY = oY;
              iX = vX - (vX - currentV[0]) * roundCorner;
              iY = vY - (vY - currentV[1]) * roundCorner;
              clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
              index += 1;
            }
          } else {
            clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
            index += 1;
          }
        }

        return clonedPath;
      };

      RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
        var shapePaths;
        var i;
        var len = this.shapes.length;
        var j;
        var jLen;
        var rd = this.rd.v;

        if (rd !== 0) {
          var shapeData;
          var localShapeCollection;

          for (i = 0; i < len; i += 1) {
            shapeData = this.shapes[i];
            localShapeCollection = shapeData.localShapeCollection;

            if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
              localShapeCollection.releaseShapes();
              shapeData.shape._mdf = true;
              shapePaths = shapeData.shape.paths.shapes;
              jLen = shapeData.shape.paths._length;

              for (j = 0; j < jLen; j += 1) {
                localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
              }
            }

            shapeData.shape.paths = shapeData.localShapeCollection;
          }
        }

        if (!this.dynamicProperties.length) {
          this._mdf = false;
        }
      };

      function getFontProperties(fontData) {
        var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];
        var fWeight = 'normal';
        var fStyle = 'normal';
        var len = styles.length;
        var styleName;

        for (var i = 0; i < len; i += 1) {
          styleName = styles[i].toLowerCase();

          switch (styleName) {
            case 'italic':
              fStyle = 'italic';
              break;

            case 'bold':
              fWeight = '700';
              break;

            case 'black':
              fWeight = '900';
              break;

            case 'medium':
              fWeight = '500';
              break;

            case 'regular':
            case 'normal':
              fWeight = '400';
              break;

            case 'light':
            case 'thin':
              fWeight = '200';
              break;
          }
        }

        return {
          style: fStyle,
          weight: fontData.fWeight || fWeight
        };
      }

      var FontManager = function () {
        var maxWaitingTime = 5000;
        var emptyChar = {
          w: 0,
          size: 0,
          shapes: [],
          data: {
            shapes: []
          }
        };
        var combinedCharacters = []; // Hindi characters

        combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
        var surrogateModifiers = ['d83cdffb', 'd83cdffc', 'd83cdffd', 'd83cdffe', 'd83cdfff'];
        var zeroWidthJoiner = [65039, 8205];

        function trimFontOptions(font) {
          var familyArray = font.split(',');
          var i;
          var len = familyArray.length;
          var enabledFamilies = [];

          for (i = 0; i < len; i += 1) {
            if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
              enabledFamilies.push(familyArray[i]);
            }
          }

          return enabledFamilies.join(',');
        }

        function setUpNode(font, family) {
          var parentNode = createTag('span'); // Node is invisible to screen readers.

          parentNode.setAttribute('aria-hidden', true);
          parentNode.style.fontFamily = family;
          var node = createTag('span'); // Characters that vary significantly among different fonts

          node.innerText = 'giItT1WQy@!-/#'; // Visible - so we can measure it - but not on the screen

          parentNode.style.position = 'absolute';
          parentNode.style.left = '-10000px';
          parentNode.style.top = '-10000px'; // Large font size makes even subtle changes obvious

          parentNode.style.fontSize = '300px'; // Reset any font properties

          parentNode.style.fontVariant = 'normal';
          parentNode.style.fontStyle = 'normal';
          parentNode.style.fontWeight = 'normal';
          parentNode.style.letterSpacing = '0';
          parentNode.appendChild(node);
          document.body.appendChild(parentNode); // Remember width with no applied web font

          var width = node.offsetWidth;
          node.style.fontFamily = trimFontOptions(font) + ', ' + family;
          return {
            node: node,
            w: width,
            parent: parentNode
          };
        }

        function checkLoadedFonts() {
          var i;
          var len = this.fonts.length;
          var node;
          var w;
          var loadedCount = len;

          for (i = 0; i < len; i += 1) {
            if (this.fonts[i].loaded) {
              loadedCount -= 1;
            } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
              this.fonts[i].loaded = true;
            } else {
              node = this.fonts[i].monoCase.node;
              w = this.fonts[i].monoCase.w;

              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i].loaded = true;
              } else {
                node = this.fonts[i].sansCase.node;
                w = this.fonts[i].sansCase.w;

                if (node.offsetWidth !== w) {
                  loadedCount -= 1;
                  this.fonts[i].loaded = true;
                }
              }

              if (this.fonts[i].loaded) {
                this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
                this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
              }
            }
          }

          if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
            setTimeout(this.checkLoadedFontsBinded, 20);
          } else {
            setTimeout(this.setIsLoadedBinded, 10);
          }
        }

        function createHelper(fontData, def) {
          var engine = document.body && def ? 'svg' : 'canvas';
          var helper;
          var fontProps = getFontProperties(fontData);

          if (engine === 'svg') {
            var tHelper = createNS('text');
            tHelper.style.fontSize = '100px'; // tHelper.style.fontFamily = fontData.fFamily;

            tHelper.setAttribute('font-family', fontData.fFamily);
            tHelper.setAttribute('font-style', fontProps.style);
            tHelper.setAttribute('font-weight', fontProps.weight);
            tHelper.textContent = '1';

            if (fontData.fClass) {
              tHelper.style.fontFamily = 'inherit';
              tHelper.setAttribute('class', fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }

            def.appendChild(tHelper);
            helper = tHelper;
          } else {
            var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');
            tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;
            helper = tCanvasHelper;
          }

          function measure(text) {
            if (engine === 'svg') {
              helper.textContent = text;
              return helper.getComputedTextLength();
            }

            return helper.measureText(text).width;
          }

          return {
            measureText: measure
          };
        }

        function addFonts(fontData, defs) {
          if (!fontData) {
            this.isLoaded = true;
            return;
          }

          if (this.chars) {
            this.isLoaded = true;
            this.fonts = fontData.list;
            return;
          }

          if (!document.body) {
            this.isLoaded = true;
            fontData.list.forEach(function (data) {
              data.helper = createHelper(data);
              data.cache = {};
            });
            this.fonts = fontData.list;
            return;
          }

          var fontArr = fontData.list;
          var i;
          var len = fontArr.length;
          var _pendingFonts = len;

          for (i = 0; i < len; i += 1) {
            var shouldLoadFont = true;
            var loadedSelector;
            var j;
            fontArr[i].loaded = false;
            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');

            if (!fontArr[i].fPath) {
              fontArr[i].loaded = true;
              _pendingFonts -= 1;
            } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
              loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

              if (loadedSelector.length > 0) {
                shouldLoadFont = false;
              }

              if (shouldLoadFont) {
                var s = createTag('style');
                s.setAttribute('f-forigin', fontArr[i].fOrigin);
                s.setAttribute('f-origin', fontArr[i].origin);
                s.setAttribute('f-family', fontArr[i].fFamily);
                s.type = 'text/css';
                s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
                defs.appendChild(s);
              }
            } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
              loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

              for (j = 0; j < loadedSelector.length; j += 1) {
                if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                  // Font is already loaded
                  shouldLoadFont = false;
                }
              }

              if (shouldLoadFont) {
                var l = createTag('link');
                l.setAttribute('f-forigin', fontArr[i].fOrigin);
                l.setAttribute('f-origin', fontArr[i].origin);
                l.type = 'text/css';
                l.rel = 'stylesheet';
                l.href = fontArr[i].fPath;
                document.body.appendChild(l);
              }
            } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
              loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

              for (j = 0; j < loadedSelector.length; j += 1) {
                if (fontArr[i].fPath === loadedSelector[j].src) {
                  // Font is already loaded
                  shouldLoadFont = false;
                }
              }

              if (shouldLoadFont) {
                var sc = createTag('link');
                sc.setAttribute('f-forigin', fontArr[i].fOrigin);
                sc.setAttribute('f-origin', fontArr[i].origin);
                sc.setAttribute('rel', 'stylesheet');
                sc.setAttribute('href', fontArr[i].fPath);
                defs.appendChild(sc);
              }
            }

            fontArr[i].helper = createHelper(fontArr[i], defs);
            fontArr[i].cache = {};
            this.fonts.push(fontArr[i]);
          }

          if (_pendingFonts === 0) {
            this.isLoaded = true;
          } else {
            // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
            // Adding this timeout seems to fix it
            setTimeout(this.checkLoadedFonts.bind(this), 100);
          }
        }

        function addChars(chars) {
          if (!chars) {
            return;
          }

          if (!this.chars) {
            this.chars = [];
          }

          var i;
          var len = chars.length;
          var j;
          var jLen = this.chars.length;
          var found;

          for (i = 0; i < len; i += 1) {
            j = 0;
            found = false;

            while (j < jLen) {
              if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
                found = true;
              }

              j += 1;
            }

            if (!found) {
              this.chars.push(chars[i]);
              jLen += 1;
            }
          }
        }

        function getCharData(_char, style, font) {
          var i = 0;
          var len = this.chars.length;

          while (i < len) {
            if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {
              return this.chars[i];
            }

            i += 1;
          }

          if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console
          && !this._warned) {
            this._warned = true;
            console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console
          }

          return emptyChar;
        }

        function measureText(_char2, fontName, size) {
          var fontData = this.getFontByName(fontName);

          var index = _char2.charCodeAt(0);

          if (!fontData.cache[index + 1]) {
            var tHelper = fontData.helper;

            if (_char2 === ' ') {
              var doubleSize = tHelper.measureText('|' + _char2 + '|');
              var singleSize = tHelper.measureText('||');
              fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
            } else {
              fontData.cache[index + 1] = tHelper.measureText(_char2) / 100;
            }
          }

          return fontData.cache[index + 1] * size;
        }

        function getFontByName(name) {
          var i = 0;
          var len = this.fonts.length;

          while (i < len) {
            if (this.fonts[i].fName === name) {
              return this.fonts[i];
            }

            i += 1;
          }

          return this.fonts[0];
        }

        function isModifier(firstCharCode, secondCharCode) {
          var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
          return surrogateModifiers.indexOf(sum) !== -1;
        }

        function isZeroWidthJoiner(firstCharCode, secondCharCode) {
          if (!secondCharCode) {
            return firstCharCode === zeroWidthJoiner[1];
          }

          return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
        }

        function isCombinedCharacter(_char3) {
          return combinedCharacters.indexOf(_char3) !== -1;
        }

        function setIsLoaded() {
          this.isLoaded = true;
        }

        var Font = function Font() {
          this.fonts = [];
          this.chars = null;
          this.typekitLoaded = 0;
          this.isLoaded = false;
          this._warned = false;
          this.initTime = Date.now();
          this.setIsLoadedBinded = this.setIsLoaded.bind(this);
          this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
        };

        Font.isModifier = isModifier;
        Font.isZeroWidthJoiner = isZeroWidthJoiner;
        Font.isCombinedCharacter = isCombinedCharacter;
        var fontPrototype = {
          addChars: addChars,
          addFonts: addFonts,
          getCharData: getCharData,
          getFontByName: getFontByName,
          measureText: measureText,
          checkLoadedFonts: checkLoadedFonts,
          setIsLoaded: setIsLoaded
        };
        Font.prototype = fontPrototype;
        return Font;
      }();

      function RenderableElement() {}

      RenderableElement.prototype = {
        initRenderable: function initRenderable() {
          // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
          this.isInRange = false; // layer's display state

          this.hidden = false; // If layer's transparency equals 0, it can be hidden

          this.isTransparent = false; // list of animated components

          this.renderableComponents = [];
        },
        addRenderableComponent: function addRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) === -1) {
            this.renderableComponents.push(component);
          }
        },
        removeRenderableComponent: function removeRenderableComponent(component) {
          if (this.renderableComponents.indexOf(component) !== -1) {
            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
          }
        },
        prepareRenderableFrame: function prepareRenderableFrame(num) {
          this.checkLayerLimits(num);
        },
        checkTransparency: function checkTransparency() {
          if (this.finalTransform.mProp.o.v <= 0) {
            if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
              this.isTransparent = true;
              this.hide();
            }
          } else if (this.isTransparent) {
            this.isTransparent = false;
            this.show();
          }
        },

        /**
           * @function
           * Initializes frame related properties.
           *
           * @param {number} num
           * current frame number in Layer's time
           *
           */
        checkLayerLimits: function checkLayerLimits(num) {
          if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
            if (this.isInRange !== true) {
              this.globalData._mdf = true;
              this._mdf = true;
              this.isInRange = true;
              this.show();
            }
          } else if (this.isInRange !== false) {
            this.globalData._mdf = true;
            this.isInRange = false;
            this.hide();
          }
        },
        renderRenderable: function renderRenderable() {
          var i;
          var len = this.renderableComponents.length;

          for (i = 0; i < len; i += 1) {
            this.renderableComponents[i].renderFrame(this._isFirstFrame);
          }
          /* this.maskManager.renderFrame(this.finalTransform.mat);
              this.renderableEffectsManager.renderFrame(this._isFirstFrame); */

        },
        sourceRectAtTime: function sourceRectAtTime() {
          return {
            top: 0,
            left: 0,
            width: 100,
            height: 100
          };
        },
        getLayerSize: function getLayerSize() {
          if (this.data.ty === 5) {
            return {
              w: this.data.textData.width,
              h: this.data.textData.height
            };
          }

          return {
            w: this.data.width,
            h: this.data.height
          };
        }
      };

      var MaskManagerInterface = function () {
        function MaskInterface(mask, data) {
          this._mask = mask;
          this._data = data;
        }

        Object.defineProperty(MaskInterface.prototype, 'maskPath', {
          get: function get() {
            if (this._mask.prop.k) {
              this._mask.prop.getValue();
            }

            return this._mask.prop;
          }
        });
        Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
          get: function get() {
            if (this._mask.op.k) {
              this._mask.op.getValue();
            }

            return this._mask.op.v * 100;
          }
        });

        var MaskManager = function MaskManager(maskManager) {
          var _masksInterfaces = createSizedArray(maskManager.viewData.length);

          var i;
          var len = maskManager.viewData.length;

          for (i = 0; i < len; i += 1) {
            _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
          }

          var maskFunction = function maskFunction(name) {
            i = 0;

            while (i < len) {
              if (maskManager.masksProperties[i].nm === name) {
                return _masksInterfaces[i];
              }

              i += 1;
            }

            return null;
          };

          return maskFunction;
        };

        return MaskManager;
      }();

      var ExpressionPropertyInterface = function () {
        var defaultUnidimensionalValue = {
          pv: 0,
          v: 0,
          mult: 1
        };
        var defaultMultidimensionalValue = {
          pv: [0, 0, 0],
          v: [0, 0, 0],
          mult: 1
        };

        function completeProperty(expressionValue, property, type) {
          Object.defineProperty(expressionValue, 'velocity', {
            get: function get() {
              return property.getVelocityAtTime(property.comp.currentFrame);
            }
          });
          expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;

          expressionValue.key = function (pos) {
            if (!expressionValue.numKeys) {
              return 0;
            }

            var value = '';

            if ('s' in property.keyframes[pos - 1]) {
              value = property.keyframes[pos - 1].s;
            } else if ('e' in property.keyframes[pos - 2]) {
              value = property.keyframes[pos - 2].e;
            } else {
              value = property.keyframes[pos - 2].s;
            }

            var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers

            valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
            valueProp.value = type === 'unidimensional' ? value[0] : value;
            return valueProp;
          };

          expressionValue.valueAtTime = property.getValueAtTime;
          expressionValue.speedAtTime = property.getSpeedAtTime;
          expressionValue.velocityAtTime = property.getVelocityAtTime;
          expressionValue.propertyGroup = property.propertyGroup;
        }

        function UnidimensionalPropertyInterface(property) {
          if (!property || !('pv' in property)) {
            property = defaultUnidimensionalValue;
          }

          var mult = 1 / property.mult;
          var val = property.pv * mult;
          var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

          expressionValue.value = val;
          completeProperty(expressionValue, property, 'unidimensional');
          return function () {
            if (property.k) {
              property.getValue();
            }

            val = property.v * mult;

            if (expressionValue.value !== val) {
              expressionValue = new Number(val); // eslint-disable-line no-new-wrappers

              expressionValue.value = val;
              completeProperty(expressionValue, property, 'unidimensional');
            }

            return expressionValue;
          };
        }

        function MultidimensionalPropertyInterface(property) {
          if (!property || !('pv' in property)) {
            property = defaultMultidimensionalValue;
          }

          var mult = 1 / property.mult;
          var len = property.data && property.data.l || property.pv.length;
          var expressionValue = createTypedArray('float32', len);
          var arrValue = createTypedArray('float32', len);
          expressionValue.value = arrValue;
          completeProperty(expressionValue, property, 'multidimensional');
          return function () {
            if (property.k) {
              property.getValue();
            }

            for (var i = 0; i < len; i += 1) {
              arrValue[i] = property.v[i] * mult;
              expressionValue[i] = arrValue[i];
            }

            return expressionValue;
          };
        } // TODO: try to avoid using this getter


        function defaultGetter() {
          return defaultUnidimensionalValue;
        }

        return function (property) {
          if (!property) {
            return defaultGetter;
          }

          if (property.propType === 'unidimensional') {
            return UnidimensionalPropertyInterface(property);
          }

          return MultidimensionalPropertyInterface(property);
        };
      }();

      var TransformExpressionInterface = function () {
        return function (transform) {
          function _thisFunction(name) {
            switch (name) {
              case 'scale':
              case 'Scale':
              case 'ADBE Scale':
              case 6:
                return _thisFunction.scale;

              case 'rotation':
              case 'Rotation':
              case 'ADBE Rotation':
              case 'ADBE Rotate Z':
              case 10:
                return _thisFunction.rotation;

              case 'ADBE Rotate X':
                return _thisFunction.xRotation;

              case 'ADBE Rotate Y':
                return _thisFunction.yRotation;

              case 'position':
              case 'Position':
              case 'ADBE Position':
              case 2:
                return _thisFunction.position;

              case 'ADBE Position_0':
                return _thisFunction.xPosition;

              case 'ADBE Position_1':
                return _thisFunction.yPosition;

              case 'ADBE Position_2':
                return _thisFunction.zPosition;

              case 'anchorPoint':
              case 'AnchorPoint':
              case 'Anchor Point':
              case 'ADBE AnchorPoint':
              case 1:
                return _thisFunction.anchorPoint;

              case 'opacity':
              case 'Opacity':
              case 11:
                return _thisFunction.opacity;

              default:
                return null;
            }
          }

          Object.defineProperty(_thisFunction, 'rotation', {
            get: ExpressionPropertyInterface(transform.r || transform.rz)
          });
          Object.defineProperty(_thisFunction, 'zRotation', {
            get: ExpressionPropertyInterface(transform.rz || transform.r)
          });
          Object.defineProperty(_thisFunction, 'xRotation', {
            get: ExpressionPropertyInterface(transform.rx)
          });
          Object.defineProperty(_thisFunction, 'yRotation', {
            get: ExpressionPropertyInterface(transform.ry)
          });
          Object.defineProperty(_thisFunction, 'scale', {
            get: ExpressionPropertyInterface(transform.s)
          });

          var _px;

          var _py;

          var _pz;

          var _transformFactory;

          if (transform.p) {
            _transformFactory = ExpressionPropertyInterface(transform.p);
          } else {
            _px = ExpressionPropertyInterface(transform.px);
            _py = ExpressionPropertyInterface(transform.py);

            if (transform.pz) {
              _pz = ExpressionPropertyInterface(transform.pz);
            }
          }

          Object.defineProperty(_thisFunction, 'position', {
            get: function get() {
              if (transform.p) {
                return _transformFactory();
              }

              return [_px(), _py(), _pz ? _pz() : 0];
            }
          });
          Object.defineProperty(_thisFunction, 'xPosition', {
            get: ExpressionPropertyInterface(transform.px)
          });
          Object.defineProperty(_thisFunction, 'yPosition', {
            get: ExpressionPropertyInterface(transform.py)
          });
          Object.defineProperty(_thisFunction, 'zPosition', {
            get: ExpressionPropertyInterface(transform.pz)
          });
          Object.defineProperty(_thisFunction, 'anchorPoint', {
            get: ExpressionPropertyInterface(transform.a)
          });
          Object.defineProperty(_thisFunction, 'opacity', {
            get: ExpressionPropertyInterface(transform.o)
          });
          Object.defineProperty(_thisFunction, 'skew', {
            get: ExpressionPropertyInterface(transform.sk)
          });
          Object.defineProperty(_thisFunction, 'skewAxis', {
            get: ExpressionPropertyInterface(transform.sa)
          });
          Object.defineProperty(_thisFunction, 'orientation', {
            get: ExpressionPropertyInterface(transform.or)
          });
          return _thisFunction;
        };
      }();

      var LayerExpressionInterface = function () {
        function getMatrix(time) {
          var toWorldMat = new Matrix();

          if (time !== undefined) {
            var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);

            propMatrix.clone(toWorldMat);
          } else {
            var transformMat = this._elem.finalTransform.mProp;
            transformMat.applyToMatrix(toWorldMat);
          }

          return toWorldMat;
        }

        function toWorldVec(arr, time) {
          var toWorldMat = this.getMatrix(time);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.applyPoint(toWorldMat, arr);
        }

        function toWorld(arr, time) {
          var toWorldMat = this.getMatrix(time);
          return this.applyPoint(toWorldMat, arr);
        }

        function fromWorldVec(arr, time) {
          var toWorldMat = this.getMatrix(time);
          toWorldMat.props[12] = 0;
          toWorldMat.props[13] = 0;
          toWorldMat.props[14] = 0;
          return this.invertPoint(toWorldMat, arr);
        }

        function fromWorld(arr, time) {
          var toWorldMat = this.getMatrix(time);
          return this.invertPoint(toWorldMat, arr);
        }

        function applyPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;

            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
          }

          return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
        }

        function invertPoint(matrix, arr) {
          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;

            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
            }
          }

          return matrix.inversePoint(arr);
        }

        function fromComp(arr) {
          var toWorldMat = new Matrix();
          toWorldMat.reset();

          this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);

          if (this._elem.hierarchy && this._elem.hierarchy.length) {
            var i;
            var len = this._elem.hierarchy.length;

            for (i = 0; i < len; i += 1) {
              this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
            }

            return toWorldMat.inversePoint(arr);
          }

          return toWorldMat.inversePoint(arr);
        }

        function sampleImage() {
          return [1, 1, 1, 1];
        }

        return function (elem) {
          var transformInterface;

          function _registerMaskInterface(maskManager) {
            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
          }

          function _registerEffectsInterface(effects) {
            _thisLayerFunction.effect = effects;
          }

          function _thisLayerFunction(name) {
            switch (name) {
              case 'ADBE Root Vectors Group':
              case 'Contents':
              case 2:
                return _thisLayerFunction.shapeInterface;

              case 1:
              case 6:
              case 'Transform':
              case 'transform':
              case 'ADBE Transform Group':
                return transformInterface;

              case 4:
              case 'ADBE Effect Parade':
              case 'effects':
              case 'Effects':
                return _thisLayerFunction.effect;

              case 'ADBE Text Properties':
                return _thisLayerFunction.textInterface;

              default:
                return null;
            }
          }

          _thisLayerFunction.getMatrix = getMatrix;
          _thisLayerFunction.invertPoint = invertPoint;
          _thisLayerFunction.applyPoint = applyPoint;
          _thisLayerFunction.toWorld = toWorld;
          _thisLayerFunction.toWorldVec = toWorldVec;
          _thisLayerFunction.fromWorld = fromWorld;
          _thisLayerFunction.fromWorldVec = fromWorldVec;
          _thisLayerFunction.toComp = toWorld;
          _thisLayerFunction.fromComp = fromComp;
          _thisLayerFunction.sampleImage = sampleImage;
          _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
          _thisLayerFunction._elem = elem;
          transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
          var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
          Object.defineProperties(_thisLayerFunction, {
            hasParent: {
              get: function get() {
                return elem.hierarchy.length;
              }
            },
            parent: {
              get: function get() {
                return elem.hierarchy[0].layerInterface;
              }
            },
            rotation: getDescriptor(transformInterface, 'rotation'),
            scale: getDescriptor(transformInterface, 'scale'),
            position: getDescriptor(transformInterface, 'position'),
            opacity: getDescriptor(transformInterface, 'opacity'),
            anchorPoint: anchorPointDescriptor,
            anchor_point: anchorPointDescriptor,
            transform: {
              get: function get() {
                return transformInterface;
              }
            },
            active: {
              get: function get() {
                return elem.isInRange;
              }
            }
          });
          _thisLayerFunction.startTime = elem.data.st;
          _thisLayerFunction.index = elem.data.ind;
          _thisLayerFunction.source = elem.data.refId;
          _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
          _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
          _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
          _thisLayerFunction._name = elem.data.nm;
          _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
          _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
          return _thisLayerFunction;
        };
      }();

      var propertyGroupFactory = function () {
        return function (interfaceFunction, parentPropertyGroup) {
          return function (val) {
            val = val === undefined ? 1 : val;

            if (val <= 0) {
              return interfaceFunction;
            }

            return parentPropertyGroup(val - 1);
          };
        };
      }();

      var PropertyInterface = function () {
        return function (propertyName, propertyGroup) {
          var interfaceFunction = {
            _name: propertyName
          };

          function _propertyGroup(val) {
            val = val === undefined ? 1 : val;

            if (val <= 0) {
              return interfaceFunction;
            }

            return propertyGroup(val - 1);
          }

          return _propertyGroup;
        };
      }();

      var EffectsExpressionInterface = function () {
        var ob = {
          createEffectsInterface: createEffectsInterface
        };

        function createEffectsInterface(elem, propertyGroup) {
          if (elem.effectsManager) {
            var effectElements = [];
            var effectsData = elem.data.ef;
            var i;
            var len = elem.effectsManager.effectElements.length;

            for (i = 0; i < len; i += 1) {
              effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
            }

            var effects = elem.data.ef || [];

            var groupInterface = function groupInterface(name) {
              i = 0;
              len = effects.length;

              while (i < len) {
                if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                  return effectElements[i];
                }

                i += 1;
              }

              return null;
            };

            Object.defineProperty(groupInterface, 'numProperties', {
              get: function get() {
                return effects.length;
              }
            });
            return groupInterface;
          }

          return null;
        }

        function createGroupInterface(data, elements, propertyGroup, elem) {
          function groupInterface(name) {
            var effects = data.ef;
            var i = 0;
            var len = effects.length;

            while (i < len) {
              if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                if (effects[i].ty === 5) {
                  return effectElements[i];
                }

                return effectElements[i]();
              }

              i += 1;
            }

            throw new Error();
          }

          var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

          var effectElements = [];
          var i;
          var len = data.ef.length;

          for (i = 0; i < len; i += 1) {
            if (data.ef[i].ty === 5) {
              effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
            } else {
              effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
            }
          }

          if (data.mn === 'ADBE Color Control') {
            Object.defineProperty(groupInterface, 'color', {
              get: function get() {
                return effectElements[0]();
              }
            });
          }

          Object.defineProperties(groupInterface, {
            numProperties: {
              get: function get() {
                return data.np;
              }
            },
            _name: {
              value: data.nm
            },
            propertyGroup: {
              value: _propertyGroup
            }
          });
          groupInterface.enabled = data.en !== 0;
          groupInterface.active = groupInterface.enabled;
          return groupInterface;
        }

        function createValueInterface(element, type, elem, propertyGroup) {
          var expressionProperty = ExpressionPropertyInterface(element.p);

          function interfaceFunction() {
            if (type === 10) {
              return elem.comp.compInterface(element.p.v);
            }

            return expressionProperty();
          }

          if (element.p.setGroupProperty) {
            element.p.setGroupProperty(PropertyInterface('', propertyGroup));
          }

          return interfaceFunction;
        }

        return ob;
      }();

      var CompExpressionInterface = function () {
        return function (comp) {
          function _thisLayerFunction(name) {
            var i = 0;
            var len = comp.layers.length;

            while (i < len) {
              if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
                return comp.elements[i].layerInterface;
              }

              i += 1;
            }

            return null; // return {active:false};
          }

          Object.defineProperty(_thisLayerFunction, '_name', {
            value: comp.data.nm
          });
          _thisLayerFunction.layer = _thisLayerFunction;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
          _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
          _thisLayerFunction.pixelAspect = 1;
          _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
          _thisLayerFunction.displayStartTime = 0;
          _thisLayerFunction.numLayers = comp.layers.length;
          return _thisLayerFunction;
        };
      }();

      var ShapePathInterface = function () {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;

          function interfaceFunction(val) {
            if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
              return interfaceFunction.path;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }

                return prop;
              }
            },
            shape: {
              get: function get() {
                if (prop.k) {
                  prop.getValue();
                }

                return prop;
              }
            },
            _name: {
              value: shape.nm
            },
            ix: {
              value: shape.ix
            },
            propertyIndex: {
              value: shape.ix
            },
            mn: {
              value: shape.mn
            },
            propertyGroup: {
              value: propertyGroup
            }
          });
          return interfaceFunction;
        };
      }();

      var ShapeExpressionInterface = function () {
        function iterateElements(shapes, view, propertyGroup) {
          var arr = [];
          var i;
          var len = shapes ? shapes.length : 0;

          for (i = 0; i < len; i += 1) {
            if (shapes[i].ty === 'gr') {
              arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'fl') {
              arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'st') {
              arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'tm') {
              arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'tr') ; else if (shapes[i].ty === 'el') {
              arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'sr') {
              arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'sh') {
              arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'rc') {
              arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'rd') {
              arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'rp') {
              arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else if (shapes[i].ty === 'gf') {
              arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
            } else {
              arr.push(defaultInterfaceFactory(shapes[i], view[i]));
            }
          }

          return arr;
        }

        function contentsInterfaceFactory(shape, view, propertyGroup) {
          var interfaces;

          var interfaceFunction = function _interfaceFunction(value) {
            var i = 0;
            var len = interfaces.length;

            while (i < len) {
              if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
                return interfaces[i];
              }

              i += 1;
            }

            if (typeof value === 'number') {
              return interfaces[value - 1];
            }

            return null;
          };

          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
          interfaceFunction.numProperties = interfaces.length;
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.transform = transformInterface;
          interfaceFunction.propertyIndex = shape.cix;
          interfaceFunction._name = shape.nm;
          return interfaceFunction;
        }

        function groupInterfaceFactory(shape, view, propertyGroup) {
          var interfaceFunction = function _interfaceFunction(value) {
            switch (value) {
              case 'ADBE Vectors Group':
              case 'Contents':
              case 2:
                return interfaceFunction.content;
              // Not necessary for now. Keeping them here in case a new case appears
              // case 'ADBE Vector Transform Group':
              // case 3:

              default:
                return interfaceFunction.transform;
            }
          };

          interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
          var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
          interfaceFunction.content = content;
          interfaceFunction.transform = transformInterface;
          Object.defineProperty(interfaceFunction, '_name', {
            get: function get() {
              return shape.nm;
            }
          }); // interfaceFunction.content = interfaceFunction;

          interfaceFunction.numProperties = shape.np;
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.nm = shape.nm;
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function fillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val) {
            if (val === 'Color' || val === 'color') {
              return interfaceFunction.color;
            }

            if (val === 'Opacity' || val === 'opacity') {
              return interfaceFunction.opacity;
            }

            return null;
          }

          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
          view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
          return interfaceFunction;
        }

        function gradientFillInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val) {
            if (val === 'Start Point' || val === 'start point') {
              return interfaceFunction.startPoint;
            }

            if (val === 'End Point' || val === 'end point') {
              return interfaceFunction.endPoint;
            }

            if (val === 'Opacity' || val === 'opacity') {
              return interfaceFunction.opacity;
            }

            return null;
          }

          Object.defineProperties(interfaceFunction, {
            startPoint: {
              get: ExpressionPropertyInterface(view.s)
            },
            endPoint: {
              get: ExpressionPropertyInterface(view.e)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            type: {
              get: function get() {
                return 'a';
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
          view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
          view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
          return interfaceFunction;
        }

        function defaultInterfaceFactory() {
          function interfaceFunction() {
            return null;
          }

          return interfaceFunction;
        }

        function strokeInterfaceFactory(shape, view, propertyGroup) {
          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);

          function addPropertyToDashOb(i) {
            Object.defineProperty(dashOb, shape.d[i].nm, {
              get: ExpressionPropertyInterface(view.d.dataProps[i].p)
            });
          }

          var i;
          var len = shape.d ? shape.d.length : 0;
          var dashOb = {};

          for (i = 0; i < len; i += 1) {
            addPropertyToDashOb(i);
            view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
          }

          function interfaceFunction(val) {
            if (val === 'Color' || val === 'color') {
              return interfaceFunction.color;
            }

            if (val === 'Opacity' || val === 'opacity') {
              return interfaceFunction.opacity;
            }

            if (val === 'Stroke Width' || val === 'stroke width') {
              return interfaceFunction.strokeWidth;
            }

            return null;
          }

          Object.defineProperties(interfaceFunction, {
            color: {
              get: ExpressionPropertyInterface(view.c)
            },
            opacity: {
              get: ExpressionPropertyInterface(view.o)
            },
            strokeWidth: {
              get: ExpressionPropertyInterface(view.w)
            },
            dash: {
              get: function get() {
                return dashOb;
              }
            },
            _name: {
              value: shape.nm
            },
            mn: {
              value: shape.mn
            }
          });
          view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
          view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
          view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
          return interfaceFunction;
        }

        function trimInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(val) {
            if (val === shape.e.ix || val === 'End' || val === 'end') {
              return interfaceFunction.end;
            }

            if (val === shape.s.ix) {
              return interfaceFunction.start;
            }

            if (val === shape.o.ix) {
              return interfaceFunction.offset;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          interfaceFunction.propertyIndex = shape.ix;
          view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
          view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
          view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
          interfaceFunction.propertyIndex = shape.ix;
          interfaceFunction.propertyGroup = propertyGroup;
          Object.defineProperties(interfaceFunction, {
            start: {
              get: ExpressionPropertyInterface(view.s)
            },
            end: {
              get: ExpressionPropertyInterface(view.e)
            },
            offset: {
              get: ExpressionPropertyInterface(view.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function transformInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.a.ix === value || value === 'Anchor Point') {
              return interfaceFunction.anchorPoint;
            }

            if (shape.o.ix === value || value === 'Opacity') {
              return interfaceFunction.opacity;
            }

            if (shape.p.ix === value || value === 'Position') {
              return interfaceFunction.position;
            }

            if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
              return interfaceFunction.rotation;
            }

            if (shape.s.ix === value || value === 'Scale') {
              return interfaceFunction.scale;
            }

            if (shape.sk && shape.sk.ix === value || value === 'Skew') {
              return interfaceFunction.skew;
            }

            if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {
              return interfaceFunction.skewAxis;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
          view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
          view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
          view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
          view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

          if (view.transform.mProps.sk) {
            view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
            view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
          }

          view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            opacity: {
              get: ExpressionPropertyInterface(view.transform.mProps.o)
            },
            position: {
              get: ExpressionPropertyInterface(view.transform.mProps.p)
            },
            anchorPoint: {
              get: ExpressionPropertyInterface(view.transform.mProps.a)
            },
            scale: {
              get: ExpressionPropertyInterface(view.transform.mProps.s)
            },
            rotation: {
              get: ExpressionPropertyInterface(view.transform.mProps.r)
            },
            skew: {
              get: ExpressionPropertyInterface(view.transform.mProps.sk)
            },
            skewAxis: {
              get: ExpressionPropertyInterface(view.transform.mProps.sa)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.ty = 'tr';
          interfaceFunction.mn = shape.mn;
          interfaceFunction.propertyGroup = propertyGroup;
          return interfaceFunction;
        }

        function ellipseInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.p.ix === value) {
              return interfaceFunction.position;
            }

            if (shape.s.ix === value) {
              return interfaceFunction.size;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          interfaceFunction.propertyIndex = shape.ix;
          var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
          prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function starInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.p.ix === value) {
              return interfaceFunction.position;
            }

            if (shape.r.ix === value) {
              return interfaceFunction.rotation;
            }

            if (shape.pt.ix === value) {
              return interfaceFunction.points;
            }

            if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
              return interfaceFunction.outerRadius;
            }

            if (shape.os.ix === value) {
              return interfaceFunction.outerRoundness;
            }

            if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
              return interfaceFunction.innerRadius;
            }

            if (shape.is && shape.is.ix === value) {
              return interfaceFunction.innerRoundness;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
          prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
          prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
          prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

          if (shape.ir) {
            prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
            prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
          }

          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            rotation: {
              get: ExpressionPropertyInterface(prop.r)
            },
            points: {
              get: ExpressionPropertyInterface(prop.pt)
            },
            outerRadius: {
              get: ExpressionPropertyInterface(prop.or)
            },
            outerRoundness: {
              get: ExpressionPropertyInterface(prop.os)
            },
            innerRadius: {
              get: ExpressionPropertyInterface(prop.ir)
            },
            innerRoundness: {
              get: ExpressionPropertyInterface(prop.is)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function rectInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.p.ix === value) {
              return interfaceFunction.position;
            }

            if (shape.r.ix === value) {
              return interfaceFunction.roundness;
            }

            if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
              return interfaceFunction.size;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
          interfaceFunction.propertyIndex = shape.ix;
          prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
          prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
          prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            position: {
              get: ExpressionPropertyInterface(prop.p)
            },
            roundness: {
              get: ExpressionPropertyInterface(prop.r)
            },
            size: {
              get: ExpressionPropertyInterface(prop.s)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function roundedInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.r.ix === value || value === 'Round Corners 1') {
              return interfaceFunction.radius;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            radius: {
              get: ExpressionPropertyInterface(prop.rd)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        function repeaterInterfaceFactory(shape, view, propertyGroup) {
          function interfaceFunction(value) {
            if (shape.c.ix === value || value === 'Copies') {
              return interfaceFunction.copies;
            }

            if (shape.o.ix === value || value === 'Offset') {
              return interfaceFunction.offset;
            }

            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

          var prop = view;
          interfaceFunction.propertyIndex = shape.ix;
          prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
          prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            copies: {
              get: ExpressionPropertyInterface(prop.c)
            },
            offset: {
              get: ExpressionPropertyInterface(prop.o)
            },
            _name: {
              value: shape.nm
            }
          });
          interfaceFunction.mn = shape.mn;
          return interfaceFunction;
        }

        return function (shapes, view, propertyGroup) {
          var interfaces;

          function _interfaceFunction(value) {
            if (typeof value === 'number') {
              value = value === undefined ? 1 : value;

              if (value === 0) {
                return propertyGroup;
              }

              return interfaces[value - 1];
            }

            var i = 0;
            var len = interfaces.length;

            while (i < len) {
              if (interfaces[i]._name === value) {
                return interfaces[i];
              }

              i += 1;
            }

            return null;
          }

          function parentGroupWrapper() {
            return propertyGroup;
          }

          _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
          interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
          _interfaceFunction.numProperties = interfaces.length;
          _interfaceFunction._name = 'Contents';
          return _interfaceFunction;
        };
      }();

      var TextExpressionInterface = function () {
        return function (elem) {
          var _prevValue;

          var _sourceText;

          function _thisLayerFunction(name) {
            switch (name) {
              case 'ADBE Text Document':
                return _thisLayerFunction.sourceText;

              default:
                return null;
            }
          }

          Object.defineProperty(_thisLayerFunction, 'sourceText', {
            get: function get() {
              elem.textProperty.getValue();
              var stringValue = elem.textProperty.currentData.t;

              if (stringValue !== _prevValue) {
                elem.textProperty.currentData.t = _prevValue;
                _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
                // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive

                _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
              }

              return _sourceText;
            }
          });
          return _thisLayerFunction;
        };
      }();

      var getBlendMode = function () {
        var blendModeEnums = {
          0: 'source-over',
          1: 'multiply',
          2: 'screen',
          3: 'overlay',
          4: 'darken',
          5: 'lighten',
          6: 'color-dodge',
          7: 'color-burn',
          8: 'hard-light',
          9: 'soft-light',
          10: 'difference',
          11: 'exclusion',
          12: 'hue',
          13: 'saturation',
          14: 'color',
          15: 'luminosity'
        };
        return function (mode) {
          return blendModeEnums[mode] || '';
        };
      }();

      function SliderEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
      }

      function AngleEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
      }

      function ColorEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
      }

      function PointEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
      }

      function LayerIndexEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
      }

      function MaskIndexEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
      }

      function CheckboxEffect(data, elem, container) {
        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
      }

      function NoValueEffect() {
        this.p = {};
      }

      function EffectsManager(data, element) {
        var effects = data.ef || [];
        this.effectElements = [];
        var i;
        var len = effects.length;
        var effectItem;

        for (i = 0; i < len; i += 1) {
          effectItem = new GroupEffect(effects[i], element);
          this.effectElements.push(effectItem);
        }
      }

      function GroupEffect(data, element) {
        this.init(data, element);
      }

      extendPrototype([DynamicPropertyContainer], GroupEffect);
      GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

      GroupEffect.prototype.init = function (data, element) {
        this.data = data;
        this.effectElements = [];
        this.initDynamicPropertyContainer(element);
        var i;
        var len = this.data.ef.length;
        var eff;
        var effects = this.data.ef;

        for (i = 0; i < len; i += 1) {
          eff = null;

          switch (effects[i].ty) {
            case 0:
              eff = new SliderEffect(effects[i], element, this);
              break;

            case 1:
              eff = new AngleEffect(effects[i], element, this);
              break;

            case 2:
              eff = new ColorEffect(effects[i], element, this);
              break;

            case 3:
              eff = new PointEffect(effects[i], element, this);
              break;

            case 4:
            case 7:
              eff = new CheckboxEffect(effects[i], element, this);
              break;

            case 10:
              eff = new LayerIndexEffect(effects[i], element, this);
              break;

            case 11:
              eff = new MaskIndexEffect(effects[i], element, this);
              break;

            case 5:
              eff = new EffectsManager(effects[i], element, this);
              break;
            // case 6:

            default:
              eff = new NoValueEffect(effects[i], element, this);
              break;
          }

          if (eff) {
            this.effectElements.push(eff);
          }
        }
      };

      function BaseElement() {}

      BaseElement.prototype = {
        checkMasks: function checkMasks() {
          if (!this.data.hasMask) {
            return false;
          }

          var i = 0;
          var len = this.data.masksProperties.length;

          while (i < len) {
            if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {
              return true;
            }

            i += 1;
          }

          return false;
        },
        initExpressions: function initExpressions() {
          this.layerInterface = LayerExpressionInterface(this);

          if (this.data.hasMask && this.maskManager) {
            this.layerInterface.registerMaskInterface(this.maskManager);
          }

          var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(effectsInterface);

          if (this.data.ty === 0 || this.data.xt) {
            this.compInterface = CompExpressionInterface(this);
          } else if (this.data.ty === 4) {
            this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
            this.layerInterface.content = this.layerInterface.shapeInterface;
          } else if (this.data.ty === 5) {
            this.layerInterface.textInterface = TextExpressionInterface(this);
            this.layerInterface.text = this.layerInterface.textInterface;
          }
        },
        setBlendMode: function setBlendMode() {
          var blendModeValue = getBlendMode(this.data.bm);
          var elem = this.baseElement || this.layerElement;
          elem.style['mix-blend-mode'] = blendModeValue;
        },
        initBaseData: function initBaseData(data, globalData, comp) {
          this.globalData = globalData;
          this.comp = comp;
          this.data = data;
          this.layerId = createElementID(); // Stretch factor for old animations missing this property.

          if (!this.data.sr) {
            this.data.sr = 1;
          } // effects manager


          this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
        },
        getType: function getType() {
          return this.type;
        },
        sourceRectAtTime: function sourceRectAtTime() {}
      };

      /**
       * @file
       * Handles element's layer frame update.
       * Checks layer in point and out point
       *
       */
      function FrameElement() {}

      FrameElement.prototype = {
        /**
           * @function
           * Initializes frame related properties.
           *
           */
        initFrame: function initFrame() {
          // set to true when inpoint is rendered
          this._isFirstFrame = false; // list of animated properties

          this.dynamicProperties = []; // If layer has been modified in current tick this will be true

          this._mdf = false;
        },

        /**
           * @function
           * Calculates all dynamic values
           *
           * @param {number} num
           * current frame number in Layer's time
           * @param {boolean} isVisible
           * if layers is currently in range
           *
           */
        prepareProperties: function prepareProperties(num, isVisible) {
          var i;
          var len = this.dynamicProperties.length;

          for (i = 0; i < len; i += 1) {
            if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {
              this.dynamicProperties[i].getValue();

              if (this.dynamicProperties[i]._mdf) {
                this.globalData._mdf = true;
                this._mdf = true;
              }
            }
          }
        },
        addDynamicProperty: function addDynamicProperty(prop) {
          if (this.dynamicProperties.indexOf(prop) === -1) {
            this.dynamicProperties.push(prop);
          }
        }
      };

      function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

      var FootageInterface = function () {
        var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {
          var currentPropertyName = '';
          var currentProperty = elem.getFootageData();

          function init() {
            currentPropertyName = '';
            currentProperty = elem.getFootageData();
            return searchProperty;
          }

          function searchProperty(value) {
            if (currentProperty[value]) {
              currentPropertyName = value;
              currentProperty = currentProperty[value];

              if (_typeof$2(currentProperty) === 'object') {
                return searchProperty;
              }

              return currentProperty;
            }

            var propertyNameIndex = value.indexOf(currentPropertyName);

            if (propertyNameIndex !== -1) {
              var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
              currentProperty = currentProperty[index];

              if (_typeof$2(currentProperty) === 'object') {
                return searchProperty;
              }

              return currentProperty;
            }

            return '';
          }

          return init;
        };

        var dataInterfaceFactory = function dataInterfaceFactory(elem) {
          function interfaceFunction(value) {
            if (value === 'Outline') {
              return interfaceFunction.outlineInterface();
            }

            return null;
          }

          interfaceFunction._name = 'Outline';
          interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
          return interfaceFunction;
        };

        return function (elem) {
          function _interfaceFunction(value) {
            if (value === 'Data') {
              return _interfaceFunction.dataInterface;
            }

            return null;
          }

          _interfaceFunction._name = 'Data';
          _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
          return _interfaceFunction;
        };
      }();

      function FootageElement(data, globalData, comp) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData.getAssetData(data.refId);
        this.footageData = globalData.imageLoader.getAsset(this.assetData);
        this.initBaseData(data, globalData, comp);
      }

      FootageElement.prototype.prepareFrame = function () {};

      extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);

      FootageElement.prototype.getBaseElement = function () {
        return null;
      };

      FootageElement.prototype.renderFrame = function () {};

      FootageElement.prototype.destroy = function () {};

      FootageElement.prototype.initExpressions = function () {
        this.layerInterface = FootageInterface(this);
      };

      FootageElement.prototype.getFootageData = function () {
        return this.footageData;
      };

      function AudioElement(data, globalData, comp) {
        this.initFrame();
        this.initRenderable();
        this.assetData = globalData.getAssetData(data.refId);
        this.initBaseData(data, globalData, comp);
        this._isPlaying = false;
        this._canPlay = false;
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.audio = this.globalData.audioController.createAudio(assetPath);
        this._currentTime = 0;
        this.globalData.audioController.addAudio(this);
        this._volumeMultiplier = 1;
        this._volume = 1;
        this._previousVolume = null;
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
          _placeholder: true
        };
        this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {
          k: [100]
        }, 1, 0.01, this);
      }

      AudioElement.prototype.prepareFrame = function (num) {
        this.prepareRenderableFrame(num, true);
        this.prepareProperties(num, true);

        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;
          this._currentTime = timeRemapped;
        } else {
          this._currentTime = num / this.data.sr;
        }

        this._volume = this.lv.v[0];
        var totalVolume = this._volume * this._volumeMultiplier;

        if (this._previousVolume !== totalVolume) {
          this._previousVolume = totalVolume;
          this.audio.volume(totalVolume);
        }
      };

      extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);

      AudioElement.prototype.renderFrame = function () {
        if (this.isInRange && this._canPlay) {
          if (!this._isPlaying) {
            this.audio.play();
            this.audio.seek(this._currentTime / this.globalData.frameRate);
            this._isPlaying = true;
          } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
            this.audio.seek(this._currentTime / this.globalData.frameRate);
          }
        }
      };

      AudioElement.prototype.show = function () {// this.audio.play()
      };

      AudioElement.prototype.hide = function () {
        this.audio.pause();
        this._isPlaying = false;
      };

      AudioElement.prototype.pause = function () {
        this.audio.pause();
        this._isPlaying = false;
        this._canPlay = false;
      };

      AudioElement.prototype.resume = function () {
        this._canPlay = true;
      };

      AudioElement.prototype.setRate = function (rateValue) {
        this.audio.rate(rateValue);
      };

      AudioElement.prototype.volume = function (volumeValue) {
        this._volumeMultiplier = volumeValue;
        this._previousVolume = volumeValue * this._volume;
        this.audio.volume(this._previousVolume);
      };

      AudioElement.prototype.getBaseElement = function () {
        return null;
      };

      AudioElement.prototype.destroy = function () {};

      AudioElement.prototype.sourceRectAtTime = function () {};

      AudioElement.prototype.initExpressions = function () {};

      function BaseRenderer() {}

      BaseRenderer.prototype.checkLayers = function (num) {
        var i;
        var len = this.layers.length;
        var data;
        this.completeLayers = true;

        for (i = len - 1; i >= 0; i -= 1) {
          if (!this.elements[i]) {
            data = this.layers[i];

            if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {
              this.buildItem(i);
            }
          }

          this.completeLayers = this.elements[i] ? this.completeLayers : false;
        }

        this.checkPendingElements();
      };

      BaseRenderer.prototype.createItem = function (layer) {
        switch (layer.ty) {
          case 2:
            return this.createImage(layer);

          case 0:
            return this.createComp(layer);

          case 1:
            return this.createSolid(layer);

          case 3:
            return this.createNull(layer);

          case 4:
            return this.createShape(layer);

          case 5:
            return this.createText(layer);

          case 6:
            return this.createAudio(layer);

          case 13:
            return this.createCamera(layer);

          case 15:
            return this.createFootage(layer);

          default:
            return this.createNull(layer);
        }
      };

      BaseRenderer.prototype.createCamera = function () {
        throw new Error('You\'re using a 3d camera. Try the html renderer.');
      };

      BaseRenderer.prototype.createAudio = function (data) {
        return new AudioElement(data, this.globalData, this);
      };

      BaseRenderer.prototype.createFootage = function (data) {
        return new FootageElement(data, this.globalData, this);
      };

      BaseRenderer.prototype.buildAllItems = function () {
        var i;
        var len = this.layers.length;

        for (i = 0; i < len; i += 1) {
          this.buildItem(i);
        }

        this.checkPendingElements();
      };

      BaseRenderer.prototype.includeLayers = function (newLayers) {
        this.completeLayers = false;
        var i;
        var len = newLayers.length;
        var j;
        var jLen = this.layers.length;

        for (i = 0; i < len; i += 1) {
          j = 0;

          while (j < jLen) {
            if (this.layers[j].id === newLayers[i].id) {
              this.layers[j] = newLayers[i];
              break;
            }

            j += 1;
          }
        }
      };

      BaseRenderer.prototype.setProjectInterface = function (pInterface) {
        this.globalData.projectInterface = pInterface;
      };

      BaseRenderer.prototype.initItems = function () {
        if (!this.globalData.progressiveLoad) {
          this.buildAllItems();
        }
      };

      BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
        var elements = this.elements;
        var layers = this.layers;
        var i = 0;
        var len = layers.length;

        while (i < len) {
          if (layers[i].ind == parentName) {
            // eslint-disable-line eqeqeq
            if (!elements[i] || elements[i] === true) {
              this.buildItem(i);
              this.addPendingElement(element);
            } else {
              hierarchy.push(elements[i]);
              elements[i].setAsParent();

              if (layers[i].parent !== undefined) {
                this.buildElementParenting(element, layers[i].parent, hierarchy);
              } else {
                element.setHierarchy(hierarchy);
              }
            }
          }

          i += 1;
        }
      };

      BaseRenderer.prototype.addPendingElement = function (element) {
        this.pendingElements.push(element);
      };

      BaseRenderer.prototype.searchExtraCompositions = function (assets) {
        var i;
        var len = assets.length;

        for (i = 0; i < len; i += 1) {
          if (assets[i].xt) {
            var comp = this.createComp(assets[i]);
            comp.initExpressions();
            this.globalData.projectInterface.registerComposition(comp);
          }
        }
      };

      BaseRenderer.prototype.getElementByPath = function (path) {
        var pathValue = path.shift();
        var element;

        if (typeof pathValue === 'number') {
          element = this.elements[pathValue];
        } else {
          var i;
          var len = this.elements.length;

          for (i = 0; i < len; i += 1) {
            if (this.elements[i].data.nm === pathValue) {
              element = this.elements[i];
              break;
            }
          }
        }

        if (path.length === 0) {
          return element;
        }

        return element.getElementByPath(path);
      };

      BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
        this.globalData.fontManager = new FontManager();
        this.globalData.fontManager.addChars(animData.chars);
        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
        this.globalData.imageLoader = this.animationItem.imagePreloader;
        this.globalData.audioController = this.animationItem.audioController;
        this.globalData.frameId = 0;
        this.globalData.frameRate = animData.fr;
        this.globalData.nm = animData.nm;
        this.globalData.compSize = {
          w: animData.w,
          h: animData.h
        };
      };

      function TransformElement() {}

      TransformElement.prototype = {
        initTransform: function initTransform() {
          this.finalTransform = {
            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
              o: 0
            },
            _matMdf: false,
            _opMdf: false,
            mat: new Matrix()
          };

          if (this.data.ao) {
            this.finalTransform.mProp.autoOriented = true;
          } // TODO: check TYPE 11: Guided elements


          if (this.data.ty !== 11) ;
        },
        renderTransform: function renderTransform() {
          this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
          this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

          if (this.hierarchy) {
            var mat;
            var finalMat = this.finalTransform.mat;
            var i = 0;
            var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.

            if (!this.finalTransform._matMdf) {
              while (i < len) {
                if (this.hierarchy[i].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = true;
                  break;
                }

                i += 1;
              }
            }

            if (this.finalTransform._matMdf) {
              mat = this.finalTransform.mProp.v.props;
              finalMat.cloneFromProps(mat);

              for (i = 0; i < len; i += 1) {
                mat = this.hierarchy[i].finalTransform.mProp.v.props;
                finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
              }
            }
          }
        },
        globalToLocal: function globalToLocal(pt) {
          var transforms = [];
          transforms.push(this.finalTransform);
          var flag = true;
          var comp = this.comp;

          while (flag) {
            if (comp.finalTransform) {
              if (comp.data.hasMask) {
                transforms.splice(0, 0, comp.finalTransform);
              }

              comp = comp.comp;
            } else {
              flag = false;
            }
          }

          var i;
          var len = transforms.length;
          var ptNew;

          for (i = 0; i < len; i += 1) {
            ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);

            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
          }

          return pt;
        },
        mHelper: new Matrix()
      };

      function MaskElement(data, element, globalData) {
        this.data = data;
        this.element = element;
        this.globalData = globalData;
        this.storedData = [];
        this.masksProperties = this.data.masksProperties || [];
        this.maskElement = null;
        var defs = this.globalData.defs;
        var i;
        var len = this.masksProperties ? this.masksProperties.length : 0;
        this.viewData = createSizedArray(len);
        this.solidPath = '';
        var path;
        var properties = this.masksProperties;
        var count = 0;
        var currentMasks = [];
        var j;
        var jLen;
        var layerId = createElementID();
        var rect;
        var expansor;
        var feMorph;
        var x;
        var maskType = 'clipPath';
        var maskRef = 'clip-path';

        for (i = 0; i < len; i += 1) {
          if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
            maskType = 'mask';
            maskRef = 'mask';
          }

          if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
            rect = createNS('rect');
            rect.setAttribute('fill', '#ffffff');
            rect.setAttribute('width', this.element.comp.data.w || 0);
            rect.setAttribute('height', this.element.comp.data.h || 0);
            currentMasks.push(rect);
          } else {
            rect = null;
          }

          path = createNS('path');

          if (properties[i].mode === 'n') {
            // TODO move this to a factory or to a constructor
            this.viewData[i] = {
              op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
              elem: path,
              lastPath: ''
            };
            defs.appendChild(path);
          } else {
            count += 1;
            path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
            path.setAttribute('clip-rule', 'nonzero');
            var filterID;

            if (properties[i].x.k !== 0) {
              maskType = 'mask';
              maskRef = 'mask';
              x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
              filterID = createElementID();
              expansor = createNS('filter');
              expansor.setAttribute('id', filterID);
              feMorph = createNS('feMorphology');
              feMorph.setAttribute('operator', 'erode');
              feMorph.setAttribute('in', 'SourceGraphic');
              feMorph.setAttribute('radius', '0');
              expansor.appendChild(feMorph);
              defs.appendChild(expansor);
              path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
            } else {
              feMorph = null;
              x = null;
            } // TODO move this to a factory or to a constructor


            this.storedData[i] = {
              elem: path,
              x: x,
              expan: feMorph,
              lastPath: '',
              lastOperator: '',
              filterId: filterID,
              lastRadius: 0
            };

            if (properties[i].mode === 'i') {
              jLen = currentMasks.length;
              var g = createNS('g');

              for (j = 0; j < jLen; j += 1) {
                g.appendChild(currentMasks[j]);
              }

              var mask = createNS('mask');
              mask.setAttribute('mask-type', 'alpha');
              mask.setAttribute('id', layerId + '_' + count);
              mask.appendChild(path);
              defs.appendChild(mask);
              g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');
              currentMasks.length = 0;
              currentMasks.push(g);
            } else {
              currentMasks.push(path);
            }

            if (properties[i].inv && !this.solidPath) {
              this.solidPath = this.createLayerSolidPath();
            } // TODO move this to a factory or to a constructor


            this.viewData[i] = {
              elem: path,
              lastPath: '',
              op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
              prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
              invRect: rect
            };

            if (!this.viewData[i].prop.k) {
              this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
            }
          }
        }

        this.maskElement = createNS(maskType);
        len = currentMasks.length;

        for (i = 0; i < len; i += 1) {
          this.maskElement.appendChild(currentMasks[i]);
        }

        if (count > 0) {
          this.maskElement.setAttribute('id', layerId);
          this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');
          defs.appendChild(this.maskElement);
        }

        if (this.viewData.length) {
          this.element.addRenderableComponent(this);
        }
      }

      MaskElement.prototype.getMaskProperty = function (pos) {
        return this.viewData[pos].prop;
      };

      MaskElement.prototype.renderFrame = function (isFirstFrame) {
        var finalMat = this.element.finalTransform.mat;
        var i;
        var len = this.masksProperties.length;

        for (i = 0; i < len; i += 1) {
          if (this.viewData[i].prop._mdf || isFirstFrame) {
            this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
          }

          if (this.viewData[i].op._mdf || isFirstFrame) {
            this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
          }

          if (this.masksProperties[i].mode !== 'n') {
            if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
              this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
            }

            if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
              var feMorph = this.storedData[i].expan;

              if (this.storedData[i].x.v < 0) {
                if (this.storedData[i].lastOperator !== 'erode') {
                  this.storedData[i].lastOperator = 'erode';
                  this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');
                }

                feMorph.setAttribute('radius', -this.storedData[i].x.v);
              } else {
                if (this.storedData[i].lastOperator !== 'dilate') {
                  this.storedData[i].lastOperator = 'dilate';
                  this.storedData[i].elem.setAttribute('filter', null);
                }

                this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
              }
            }
          }
        }
      };

      MaskElement.prototype.getMaskelement = function () {
        return this.maskElement;
      };

      MaskElement.prototype.createLayerSolidPath = function () {
        var path = 'M0,0 ';
        path += ' h' + this.globalData.compSize.w;
        path += ' v' + this.globalData.compSize.h;
        path += ' h-' + this.globalData.compSize.w;
        path += ' v-' + this.globalData.compSize.h + ' ';
        return path;
      };

      MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
        var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
        var i;
        var len;
        len = pathNodes._length;

        for (i = 1; i < len; i += 1) {
          // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
          pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
        } // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];


        if (pathNodes.c && len > 1) {
          pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
        } // pathNodes.__renderedString = pathString;


        if (viewData.lastPath !== pathString) {
          var pathShapeValue = '';

          if (viewData.elem) {
            if (pathNodes.c) {
              pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
            }

            viewData.elem.setAttribute('d', pathShapeValue);
          }

          viewData.lastPath = pathString;
        }
      };

      MaskElement.prototype.destroy = function () {
        this.element = null;
        this.globalData = null;
        this.maskElement = null;
        this.data = null;
        this.masksProperties = null;
      };

      var filtersFactory = function () {
        var ob = {};
        ob.createFilter = createFilter;
        ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

        function createFilter(filId, skipCoordinates) {
          var fil = createNS('filter');
          fil.setAttribute('id', filId);

          if (skipCoordinates !== true) {
            fil.setAttribute('filterUnits', 'objectBoundingBox');
            fil.setAttribute('x', '0%');
            fil.setAttribute('y', '0%');
            fil.setAttribute('width', '100%');
            fil.setAttribute('height', '100%');
          }

          return fil;
        }

        function createAlphaToLuminanceFilter() {
          var feColorMatrix = createNS('feColorMatrix');
          feColorMatrix.setAttribute('type', 'matrix');
          feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
          feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
          return feColorMatrix;
        }

        return ob;
      }();

      var featureSupport = function () {
        var ob = {
          maskType: true
        };

        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
          ob.maskType = false;
        }

        return ob;
      }();

      var registeredEffects = {};
      var idPrefix = 'filter_result_';

      function SVGEffects(elem) {
        var i;
        var source = 'SourceGraphic';
        var len = elem.data.ef ? elem.data.ef.length : 0;
        var filId = createElementID();
        var fil = filtersFactory.createFilter(filId, true);
        var count = 0;
        this.filters = [];
        var filterManager;

        for (i = 0; i < len; i += 1) {
          filterManager = null;
          var type = elem.data.ef[i].ty;

          if (registeredEffects[type]) {
            var Effect = registeredEffects[type].effect;
            filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);
            source = idPrefix + count;

            if (registeredEffects[type].countsAsEffect) {
              count += 1;
            }
          }

          if (filterManager) {
            this.filters.push(filterManager);
          }
        }

        if (count) {
          elem.globalData.defs.appendChild(fil);
          elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
        }

        if (this.filters.length) {
          elem.addRenderableComponent(this);
        }
      }

      SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
        var i;
        var len = this.filters.length;

        for (i = 0; i < len; i += 1) {
          this.filters[i].renderFrame(_isFirstFrame);
        }
      };

      function registerEffect(id, effect, countsAsEffect) {
        registeredEffects[id] = {
          effect: effect,
          countsAsEffect: countsAsEffect
        };
      }

      function SVGBaseElement() {}

      SVGBaseElement.prototype = {
        initRendererElement: function initRendererElement() {
          this.layerElement = createNS('g');
        },
        createContainerElements: function createContainerElements() {
          this.matteElement = createNS('g');
          this.transformedElement = this.layerElement;
          this.maskedElement = this.layerElement;
          this._sizeChanged = false;
          var layerElementParent = null; // If this layer acts as a mask for the following layer

          var filId;
          var fil;
          var gg;

          if (this.data.td) {
            if (this.data.td == 3 || this.data.td == 1) {
              // eslint-disable-line eqeqeq
              var masker = createNS('mask');
              masker.setAttribute('id', this.layerId);
              masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'); // eslint-disable-line eqeqeq

              masker.appendChild(this.layerElement);
              layerElementParent = masker;
              this.globalData.defs.appendChild(masker); // This is only for IE and Edge when mask if of type alpha

              if (!featureSupport.maskType && this.data.td == 1) {
                // eslint-disable-line eqeqeq
                masker.setAttribute('mask-type', 'luminance');
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                this.globalData.defs.appendChild(fil);
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS('g');
                gg.appendChild(this.layerElement);
                layerElementParent = gg;
                masker.appendChild(gg);
                gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
              }
            } else if (this.data.td == 2) {
              // eslint-disable-line eqeqeq
              var maskGroup = createNS('mask');
              maskGroup.setAttribute('id', this.layerId);
              maskGroup.setAttribute('mask-type', 'alpha');
              var maskGrouper = createNS('g');
              maskGroup.appendChild(maskGrouper);
              filId = createElementID();
              fil = filtersFactory.createFilter(filId); /// /
              // This solution doesn't work on Android when meta tag with viewport attribute is set

              /* var feColorMatrix = createNS('feColorMatrix');
                      feColorMatrix.setAttribute('type', 'matrix');
                      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                      feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                      fil.appendChild(feColorMatrix); */
              /// /

              var feCTr = createNS('feComponentTransfer');
              feCTr.setAttribute('in', 'SourceGraphic');
              fil.appendChild(feCTr);
              var feFunc = createNS('feFuncA');
              feFunc.setAttribute('type', 'table');
              feFunc.setAttribute('tableValues', '1.0 0.0');
              feCTr.appendChild(feFunc); /// /

              this.globalData.defs.appendChild(fil);
              var alphaRect = createNS('rect');
              alphaRect.setAttribute('width', this.comp.data.w);
              alphaRect.setAttribute('height', this.comp.data.h);
              alphaRect.setAttribute('x', '0');
              alphaRect.setAttribute('y', '0');
              alphaRect.setAttribute('fill', '#ffffff');
              alphaRect.setAttribute('opacity', '0');
              maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');
              maskGrouper.appendChild(alphaRect);
              maskGrouper.appendChild(this.layerElement);
              layerElementParent = maskGrouper;

              if (!featureSupport.maskType) {
                maskGroup.setAttribute('mask-type', 'luminance');
                fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                gg = createNS('g');
                maskGrouper.appendChild(alphaRect);
                gg.appendChild(this.layerElement);
                layerElementParent = gg;
                maskGrouper.appendChild(gg);
              }

              this.globalData.defs.appendChild(maskGroup);
            }
          } else if (this.data.tt) {
            this.matteElement.appendChild(this.layerElement);
            layerElementParent = this.matteElement;
            this.baseElement = this.matteElement;
          } else {
            this.baseElement = this.layerElement;
          }

          if (this.data.ln) {
            this.layerElement.setAttribute('id', this.data.ln);
          }

          if (this.data.cl) {
            this.layerElement.setAttribute('class', this.data.cl);
          } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped


          if (this.data.ty === 0 && !this.data.hd) {
            var cp = createNS('clipPath');
            var pt = createNS('path');
            pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
            var clipId = createElementID();
            cp.setAttribute('id', clipId);
            cp.appendChild(pt);
            this.globalData.defs.appendChild(cp);

            if (this.checkMasks()) {
              var cpGroup = createNS('g');
              cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
              cpGroup.appendChild(this.layerElement);
              this.transformedElement = cpGroup;

              if (layerElementParent) {
                layerElementParent.appendChild(this.transformedElement);
              } else {
                this.baseElement = this.transformedElement;
              }
            } else {
              this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');
            }
          }

          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          if (this.finalTransform._matMdf) {
            this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
          }

          if (this.finalTransform._opMdf) {
            this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
          }
        },
        destroyBaseElement: function destroyBaseElement() {
          this.layerElement = null;
          this.matteElement = null;
          this.maskManager.destroy();
        },
        getBaseElement: function getBaseElement() {
          if (this.data.hd) {
            return null;
          }

          return this.baseElement;
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
          this.renderableEffectsManager = new SVGEffects(this);
        },
        setMatte: function setMatte(id) {
          if (!this.matteElement) {
            return;
          }

          this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');
        }
      };

      /**
       * @file
       * Handles AE's layer parenting property.
       *
       */
      function HierarchyElement() {}

      HierarchyElement.prototype = {
        /**
           * @function
           * Initializes hierarchy properties
           *
           */
        initHierarchy: function initHierarchy() {
          // element's parent list
          this.hierarchy = []; // if element is parent of another layer _isParent will be true

          this._isParent = false;
          this.checkParenting();
        },

        /**
           * @function
           * Sets layer's hierarchy.
           * @param {array} hierarch
           * layer's parent list
           *
           */
        setHierarchy: function setHierarchy(hierarchy) {
          this.hierarchy = hierarchy;
        },

        /**
           * @function
           * Sets layer as parent.
           *
           */
        setAsParent: function setAsParent() {
          this._isParent = true;
        },

        /**
           * @function
           * Searches layer's parenting chain
           *
           */
        checkParenting: function checkParenting() {
          if (this.data.parent !== undefined) {
            this.comp.buildElementParenting(this, this.data.parent, []);
          }
        }
      };

      function RenderableDOMElement() {}

      (function () {
        var _prototype = {
          initElement: function initElement(data, globalData, comp) {
            this.initFrame();
            this.initBaseData(data, globalData, comp);
            this.initTransform(data, globalData, comp);
            this.initHierarchy();
            this.initRenderable();
            this.initRendererElement();
            this.createContainerElements();
            this.createRenderableComponents();
            this.createContent();
            this.hide();
          },
          hide: function hide() {
            // console.log('HIDE', this);
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var elem = this.baseElement || this.layerElement;
              elem.style.display = 'none';
              this.hidden = true;
            }
          },
          show: function show() {
            // console.log('SHOW', this);
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var elem = this.baseElement || this.layerElement;
                elem.style.display = 'block';
              }

              this.hidden = false;
              this._isFirstFrame = true;
            }
          },
          renderFrame: function renderFrame() {
            // If it is exported as hidden (data.hd === true) no need to render
            // If it is not visible no need to render
            if (this.data.hd || this.hidden) {
              return;
            }

            this.renderTransform();
            this.renderRenderable();
            this.renderElement();
            this.renderInnerContent();

            if (this._isFirstFrame) {
              this._isFirstFrame = false;
            }
          },
          renderInnerContent: function renderInnerContent() {},
          prepareFrame: function prepareFrame(num) {
            this._mdf = false;
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
            this.checkTransparency();
          },
          destroy: function destroy() {
            this.innerElem = null;
            this.destroyBaseElement();
          }
        };
        extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
      })();

      function IImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data, globalData, comp);
        this.sourceRect = {
          top: 0,
          left: 0,
          width: this.assetData.w,
          height: this.assetData.h
        };
      }

      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

      IImageElement.prototype.createContent = function () {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        this.innerElem = createNS('image');
        this.innerElem.setAttribute('width', this.assetData.w + 'px');
        this.innerElem.setAttribute('height', this.assetData.h + 'px');
        this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
        this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
        this.layerElement.appendChild(this.innerElem);
      };

      IImageElement.prototype.sourceRectAtTime = function () {
        return this.sourceRect;
      };

      function ProcessedElement(element, position) {
        this.elem = element;
        this.pos = position;
      }

      function IShapeElement() {}

      IShapeElement.prototype = {
        addShapeToModifiers: function addShapeToModifiers(data) {
          var i;
          var len = this.shapeModifiers.length;

          for (i = 0; i < len; i += 1) {
            this.shapeModifiers[i].addShape(data);
          }
        },
        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {
          var i = 0;
          var len = this.shapeModifiers.length;

          while (i < len) {
            if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
              return true;
            }
          }

          return false;
        },
        renderModifiers: function renderModifiers() {
          if (!this.shapeModifiers.length) {
            return;
          }

          var i;
          var len = this.shapes.length;

          for (i = 0; i < len; i += 1) {
            this.shapes[i].sh.reset();
          }

          len = this.shapeModifiers.length;
          var shouldBreakProcess;

          for (i = len - 1; i >= 0; i -= 1) {
            shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice
            // TODO: find a better solution for this

            if (shouldBreakProcess) {
              break;
            }
          }
        },
        searchProcessedElement: function searchProcessedElement(elem) {
          var elements = this.processedElements;
          var i = 0;
          var len = elements.length;

          while (i < len) {
            if (elements[i].elem === elem) {
              return elements[i].pos;
            }

            i += 1;
          }

          return 0;
        },
        addProcessedElement: function addProcessedElement(elem, pos) {
          var elements = this.processedElements;
          var i = elements.length;

          while (i) {
            i -= 1;

            if (elements[i].elem === elem) {
              elements[i].pos = pos;
              return;
            }
          }

          elements.push(new ProcessedElement(elem, pos));
        },
        prepareFrame: function prepareFrame(num) {
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
        }
      };

      var lineCapEnum = {
        1: 'butt',
        2: 'round',
        3: 'square'
      };
      var lineJoinEnum = {
        1: 'miter',
        2: 'round',
        3: 'bevel'
      };

      function SVGShapeData(transformers, level, shape) {
        this.caches = [];
        this.styles = [];
        this.transformers = transformers;
        this.lStr = '';
        this.sh = shape;
        this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.
        // For now, since shapes add up with other shapes. They have to be calculated every time.
        // One way of finding out is checking if all styles associated to this shape depend only of this shape

        this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated

        var i = 0;
        var len = transformers.length;

        while (i < len) {
          if (transformers[i].mProps.dynamicProperties.length) {
            this._isAnimated = true;
            break;
          }

          i += 1;
        }
      }

      SVGShapeData.prototype.setAsAnimated = function () {
        this._isAnimated = true;
      };

      function SVGStyleData(data, level) {
        this.data = data;
        this.type = data.ty;
        this.d = '';
        this.lvl = level;
        this._mdf = false;
        this.closed = data.hd === true;
        this.pElem = createNS('path');
        this.msElem = null;
      }

      SVGStyleData.prototype.reset = function () {
        this.d = '';
        this._mdf = false;
      };

      function DashProperty(elem, data, renderer, container) {
        this.elem = elem;
        this.frameId = -1;
        this.dataProps = createSizedArray(data.length);
        this.renderer = renderer;
        this.k = false;
        this.dashStr = '';
        this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
        this.dashoffset = createTypedArray('float32', 1);
        this.initDynamicPropertyContainer(container);
        var i;
        var len = data.length || 0;
        var prop;

        for (i = 0; i < len; i += 1) {
          prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
          this.k = prop.k || this.k;
          this.dataProps[i] = {
            n: data[i].n,
            p: prop
          };
        }

        if (!this.k) {
          this.getValue(true);
        }

        this._isAnimated = this.k;
      }

      DashProperty.prototype.getValue = function (forceRender) {
        if (this.elem.globalData.frameId === this.frameId && !forceRender) {
          return;
        }

        this.frameId = this.elem.globalData.frameId;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || forceRender;

        if (this._mdf) {
          var i = 0;
          var len = this.dataProps.length;

          if (this.renderer === 'svg') {
            this.dashStr = '';
          }

          for (i = 0; i < len; i += 1) {
            if (this.dataProps[i].n !== 'o') {
              if (this.renderer === 'svg') {
                this.dashStr += ' ' + this.dataProps[i].p.v;
              } else {
                this.dashArray[i] = this.dataProps[i].p.v;
              }
            } else {
              this.dashoffset[0] = this.dataProps[i].p.v;
            }
          }
        }
      };

      extendPrototype([DynamicPropertyContainer], DashProperty);

      function SVGStrokeStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
        this.d = new DashProperty(elem, data.d || {}, 'svg', this);
        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
        this.style = styleOb;
        this._isAnimated = !!this._isAnimated;
      }

      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

      function SVGFillStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
        this.style = styleOb;
      }

      extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

      function SVGNoStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.style = styleOb;
      }

      extendPrototype([DynamicPropertyContainer], SVGNoStyleData);

      function GradientProperty(elem, data, container) {
        this.data = data;
        this.c = createTypedArray('uint8c', data.p * 4);
        var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
        this.o = createTypedArray('float32', cLength);
        this._cmdf = false;
        this._omdf = false;
        this._collapsable = this.checkCollapsable();
        this._hasOpacity = cLength;
        this.initDynamicPropertyContainer(container);
        this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
        this.k = this.prop.k;
        this.getValue(true);
      }

      GradientProperty.prototype.comparePoints = function (values, points) {
        var i = 0;
        var len = this.o.length / 2;
        var diff;

        while (i < len) {
          diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);

          if (diff > 0.01) {
            return false;
          }

          i += 1;
        }

        return true;
      };

      GradientProperty.prototype.checkCollapsable = function () {
        if (this.o.length / 2 !== this.c.length / 4) {
          return false;
        }

        if (this.data.k.k[0].s) {
          var i = 0;
          var len = this.data.k.k.length;

          while (i < len) {
            if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
              return false;
            }

            i += 1;
          }
        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
          return false;
        }

        return true;
      };

      GradientProperty.prototype.getValue = function (forceRender) {
        this.prop.getValue();
        this._mdf = false;
        this._cmdf = false;
        this._omdf = false;

        if (this.prop._mdf || forceRender) {
          var i;
          var len = this.data.p * 4;
          var mult;
          var val;

          for (i = 0; i < len; i += 1) {
            mult = i % 4 === 0 ? 100 : 255;
            val = Math.round(this.prop.v[i] * mult);

            if (this.c[i] !== val) {
              this.c[i] = val;
              this._cmdf = !forceRender;
            }
          }

          if (this.o.length) {
            len = this.prop.v.length;

            for (i = this.data.p * 4; i < len; i += 1) {
              mult = i % 2 === 0 ? 100 : 1;
              val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];

              if (this.o[i - this.data.p * 4] !== val) {
                this.o[i - this.data.p * 4] = val;
                this._omdf = !forceRender;
              }
            }
          }

          this._mdf = !forceRender;
        }
      };

      extendPrototype([DynamicPropertyContainer], GradientProperty);

      function SVGGradientFillStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.initGradientData(elem, data, styleOb);
      }

      SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
        this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
        this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
        this.h = PropertyFactory.getProp(elem, data.h || {
          k: 0
        }, 0, 0.01, this);
        this.a = PropertyFactory.getProp(elem, data.a || {
          k: 0
        }, 0, degToRads, this);
        this.g = new GradientProperty(elem, data.g, this);
        this.style = styleOb;
        this.stops = [];
        this.setGradientData(styleOb.pElem, data);
        this.setGradientOpacity(data, styleOb);
        this._isAnimated = !!this._isAnimated;
      };

      SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
        var gradientId = createElementID();
        var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
        gfill.setAttribute('id', gradientId);
        gfill.setAttribute('spreadMethod', 'pad');
        gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
        var stops = [];
        var stop;
        var j;
        var jLen;
        jLen = data.g.p * 4;

        for (j = 0; j < jLen; j += 4) {
          stop = createNS('stop');
          gfill.appendChild(stop);
          stops.push(stop);
        }

        pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');
        this.gf = gfill;
        this.cst = stops;
      };

      SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
        if (this.g._hasOpacity && !this.g._collapsable) {
          var stop;
          var j;
          var jLen;
          var mask = createNS('mask');
          var maskElement = createNS('path');
          mask.appendChild(maskElement);
          var opacityId = createElementID();
          var maskId = createElementID();
          mask.setAttribute('id', maskId);
          var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
          opFill.setAttribute('id', opacityId);
          opFill.setAttribute('spreadMethod', 'pad');
          opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
          jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
          var stops = this.stops;

          for (j = data.g.p * 4; j < jLen; j += 2) {
            stop = createNS('stop');
            stop.setAttribute('stop-color', 'rgb(255,255,255)');
            opFill.appendChild(stop);
            stops.push(stop);
          }

          maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');

          if (data.ty === 'gs') {
            maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
            maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);

            if (data.lj === 1) {
              maskElement.setAttribute('stroke-miterlimit', data.ml);
            }
          }

          this.of = opFill;
          this.ms = mask;
          this.ost = stops;
          this.maskId = maskId;
          styleOb.msElem = maskElement;
        }
      };

      extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

      function SVGGradientStrokeStyleData(elem, data, styleOb) {
        this.initDynamicPropertyContainer(elem);
        this.getValue = this.iterateDynamicProperties;
        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
        this.d = new DashProperty(elem, data.d || {}, 'svg', this);
        this.initGradientData(elem, data, styleOb);
        this._isAnimated = !!this._isAnimated;
      }

      extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

      function ShapeGroupData() {
        this.it = [];
        this.prevViewData = [];
        this.gr = createNS('g');
      }

      function SVGTransformData(mProps, op, container) {
        this.transform = {
          mProps: mProps,
          op: op,
          container: container
        };
        this.elements = [];
        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
      }

      var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {
        if (length === 0) {
          return '';
        }

        var _o = pathNodes.o;
        var _i = pathNodes.i;
        var _v = pathNodes.v;
        var i;
        var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);

        for (i = 1; i < length; i += 1) {
          shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
        }

        if (closed && length) {
          shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          shapeString += 'z';
        }

        return shapeString;
      };

      var SVGElementsRenderer = function () {
        var _identityMatrix = new Matrix();

        var _matrixHelper = new Matrix();

        var ob = {
          createRenderFunction: createRenderFunction
        };

        function createRenderFunction(data) {
          switch (data.ty) {
            case 'fl':
              return renderFill;

            case 'gf':
              return renderGradient;

            case 'gs':
              return renderGradientStroke;

            case 'st':
              return renderStroke;

            case 'sh':
            case 'el':
            case 'rc':
            case 'sr':
              return renderPath;

            case 'tr':
              return renderContentTransform;

            case 'no':
              return renderNoop;

            default:
              return null;
          }
        }

        function renderContentTransform(styleData, itemData, isFirstFrame) {
          if (isFirstFrame || itemData.transform.op._mdf) {
            itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
          }

          if (isFirstFrame || itemData.transform.mProps._mdf) {
            itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
          }
        }

        function renderNoop() {}

        function renderPath(styleData, itemData, isFirstFrame) {
          var j;
          var jLen;
          var pathStringTransformed;
          var redraw;
          var pathNodes;
          var l;
          var lLen = itemData.styles.length;
          var lvl = itemData.lvl;
          var paths;
          var mat;
          var props;
          var iterations;
          var k;

          for (l = 0; l < lLen; l += 1) {
            redraw = itemData.sh._mdf || isFirstFrame;

            if (itemData.styles[l].lvl < lvl) {
              mat = _matrixHelper.reset();
              iterations = lvl - itemData.styles[l].lvl;
              k = itemData.transformers.length - 1;

              while (!redraw && iterations > 0) {
                redraw = itemData.transformers[k].mProps._mdf || redraw;
                iterations -= 1;
                k -= 1;
              }

              if (redraw) {
                iterations = lvl - itemData.styles[l].lvl;
                k = itemData.transformers.length - 1;

                while (iterations > 0) {
                  props = itemData.transformers[k].mProps.v.props;
                  mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                  iterations -= 1;
                  k -= 1;
                }
              }
            } else {
              mat = _identityMatrix;
            }

            paths = itemData.sh.paths;
            jLen = paths._length;

            if (redraw) {
              pathStringTransformed = '';

              for (j = 0; j < jLen; j += 1) {
                pathNodes = paths.shapes[j];

                if (pathNodes && pathNodes._length) {
                  pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                }
              }

              itemData.caches[l] = pathStringTransformed;
            } else {
              pathStringTransformed = itemData.caches[l];
            }

            itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
            itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
          }
        }

        function renderFill(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;

          if (itemData.c._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
          }

          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
          }
        }

        function renderGradientStroke(styleData, itemData, isFirstFrame) {
          renderGradient(styleData, itemData, isFirstFrame);
          renderStroke(styleData, itemData, isFirstFrame);
        }

        function renderGradient(styleData, itemData, isFirstFrame) {
          var gfill = itemData.gf;
          var hasOpacity = itemData.g._hasOpacity;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;

          if (itemData.o._mdf || isFirstFrame) {
            var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
            itemData.style.pElem.setAttribute(attr, itemData.o.v);
          }

          if (itemData.s._mdf || isFirstFrame) {
            var attr1 = styleData.t === 1 ? 'x1' : 'cx';
            var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
            gfill.setAttribute(attr1, pt1[0]);
            gfill.setAttribute(attr2, pt1[1]);

            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute(attr1, pt1[0]);
              itemData.of.setAttribute(attr2, pt1[1]);
            }
          }

          var stops;
          var i;
          var len;
          var stop;

          if (itemData.g._cmdf || isFirstFrame) {
            stops = itemData.cst;
            var cValues = itemData.g.c;
            len = stops.length;

            for (i = 0; i < len; i += 1) {
              stop = stops[i];
              stop.setAttribute('offset', cValues[i * 4] + '%');
              stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
            }
          }

          if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
            var oValues = itemData.g.o;

            if (itemData.g._collapsable) {
              stops = itemData.cst;
            } else {
              stops = itemData.ost;
            }

            len = stops.length;

            for (i = 0; i < len; i += 1) {
              stop = stops[i];

              if (!itemData.g._collapsable) {
                stop.setAttribute('offset', oValues[i * 2] + '%');
              }

              stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
            }
          }

          if (styleData.t === 1) {
            if (itemData.e._mdf || isFirstFrame) {
              gfill.setAttribute('x2', pt2[0]);
              gfill.setAttribute('y2', pt2[1]);

              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute('x2', pt2[0]);
                itemData.of.setAttribute('y2', pt2[1]);
              }
            }
          } else {
            var rad;

            if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              gfill.setAttribute('r', rad);

              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute('r', rad);
              }
            }

            if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
              if (!rad) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
              }

              var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
              var percent = itemData.h.v;

              if (percent >= 1) {
                percent = 0.99;
              } else if (percent <= -1) {
                percent = -0.99;
              }

              var dist = rad * percent;
              var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
              var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
              gfill.setAttribute('fx', x);
              gfill.setAttribute('fy', y);

              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute('fx', x);
                itemData.of.setAttribute('fy', y);
              }
            } // gfill.setAttribute('fy','200');

          }
        }

        function renderStroke(styleData, itemData, isFirstFrame) {
          var styleElem = itemData.style;
          var d = itemData.d;

          if (d && (d._mdf || isFirstFrame) && d.dashStr) {
            styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
            styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
          }

          if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
            styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
          }

          if (itemData.o._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
          }

          if (itemData.w._mdf || isFirstFrame) {
            styleElem.pElem.setAttribute('stroke-width', itemData.w.v);

            if (styleElem.msElem) {
              styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
            }
          }
        }

        return ob;
      }();

      function SVGShapeElement(data, globalData, comp) {
        // List of drawable elements
        this.shapes = []; // Full shape data

        this.shapesData = data.shapes; // List of styles that will be applied to shapes

        this.stylesList = []; // List of modifiers that will be applied to shapes

        this.shapeModifiers = []; // List of items in shape tree

        this.itemsData = []; // List of items in previous shape tree

        this.processedElements = []; // List of animated components

        this.animatedContents = [];
        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created

        this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
      }

      extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

      SVGShapeElement.prototype.initSecondaryElement = function () {};

      SVGShapeElement.prototype.identityMatrix = new Matrix();

      SVGShapeElement.prototype.buildExpressionInterface = function () {};

      SVGShapeElement.prototype.createContent = function () {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
      };
      /*
      This method searches for multiple shapes that affect a single element and one of them is animated
      */


      SVGShapeElement.prototype.filterUniqueShapes = function () {
        var i;
        var len = this.shapes.length;
        var shape;
        var j;
        var jLen = this.stylesList.length;
        var style;
        var tempShapes = [];
        var areAnimated = false;

        for (j = 0; j < jLen; j += 1) {
          style = this.stylesList[j];
          areAnimated = false;
          tempShapes.length = 0;

          for (i = 0; i < len; i += 1) {
            shape = this.shapes[i];

            if (shape.styles.indexOf(style) !== -1) {
              tempShapes.push(shape);
              areAnimated = shape._isAnimated || areAnimated;
            }
          }

          if (tempShapes.length > 1 && areAnimated) {
            this.setShapesAsAnimated(tempShapes);
          }
        }
      };

      SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
        var i;
        var len = shapes.length;

        for (i = 0; i < len; i += 1) {
          shapes[i].setAsAnimated();
        }
      };

      SVGShapeElement.prototype.createStyleElement = function (data, level) {
        // TODO: prevent drawing of hidden styles
        var elementData;
        var styleOb = new SVGStyleData(data, level);
        var pathElement = styleOb.pElem;

        if (data.ty === 'st') {
          elementData = new SVGStrokeStyleData(this, data, styleOb);
        } else if (data.ty === 'fl') {
          elementData = new SVGFillStyleData(this, data, styleOb);
        } else if (data.ty === 'gf' || data.ty === 'gs') {
          var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
          elementData = new GradientConstructor(this, data, styleOb);
          this.globalData.defs.appendChild(elementData.gf);

          if (elementData.maskId) {
            this.globalData.defs.appendChild(elementData.ms);
            this.globalData.defs.appendChild(elementData.of);
            pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');
          }
        } else if (data.ty === 'no') {
          elementData = new SVGNoStyleData(this, data, styleOb);
        }

        if (data.ty === 'st' || data.ty === 'gs') {
          pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
          pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
          pathElement.setAttribute('fill-opacity', '0');

          if (data.lj === 1) {
            pathElement.setAttribute('stroke-miterlimit', data.ml);
          }
        }

        if (data.r === 2) {
          pathElement.setAttribute('fill-rule', 'evenodd');
        }

        if (data.ln) {
          pathElement.setAttribute('id', data.ln);
        }

        if (data.cl) {
          pathElement.setAttribute('class', data.cl);
        }

        if (data.bm) {
          pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
        }

        this.stylesList.push(styleOb);
        this.addToAnimatedContents(data, elementData);
        return elementData;
      };

      SVGShapeElement.prototype.createGroupElement = function (data) {
        var elementData = new ShapeGroupData();

        if (data.ln) {
          elementData.gr.setAttribute('id', data.ln);
        }

        if (data.cl) {
          elementData.gr.setAttribute('class', data.cl);
        }

        if (data.bm) {
          elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
        }

        return elementData;
      };

      SVGShapeElement.prototype.createTransformElement = function (data, container) {
        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
        this.addToAnimatedContents(data, elementData);
        return elementData;
      };

      SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
        var ty = 4;

        if (data.ty === 'rc') {
          ty = 5;
        } else if (data.ty === 'el') {
          ty = 6;
        } else if (data.ty === 'sr') {
          ty = 7;
        }

        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        this.addToAnimatedContents(data, elementData);
        return elementData;
      };

      SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
        var i = 0;
        var len = this.animatedContents.length;

        while (i < len) {
          if (this.animatedContents[i].element === element) {
            return;
          }

          i += 1;
        }

        this.animatedContents.push({
          fn: SVGElementsRenderer.createRenderFunction(data),
          element: element,
          data: data
        });
      };

      SVGShapeElement.prototype.setElementStyles = function (elementData) {
        var arr = elementData.styles;
        var j;
        var jLen = this.stylesList.length;

        for (j = 0; j < jLen; j += 1) {
          if (!this.stylesList[j].closed) {
            arr.push(this.stylesList[j]);
          }
        }
      };

      SVGShapeElement.prototype.reloadShapes = function () {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;

        for (i = 0; i < len; i += 1) {
          this.prevViewData[i] = this.itemsData[i];
        }

        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
        this.filterUniqueShapes();
        len = this.dynamicProperties.length;

        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
        }

        this.renderModifiers();
      };

      SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
        var ownTransformers = [].concat(transformers);
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var currentTransform;
        var modifier;
        var processedPos;

        for (i = len; i >= 0; i -= 1) {
          processedPos = this.searchProcessedElement(arr[i]);

          if (!processedPos) {
            arr[i]._render = render;
          } else {
            itemsData[i] = prevViewData[processedPos - 1];
          }

          if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {
            if (!processedPos) {
              itemsData[i] = this.createStyleElement(arr[i], level);
            } else {
              itemsData[i].style.closed = false;
            }

            if (arr[i]._render) {
              if (itemsData[i].style.pElem.parentNode !== container) {
                container.appendChild(itemsData[i].style.pElem);
              }
            }

            ownStyles.push(itemsData[i].style);
          } else if (arr[i].ty === 'gr') {
            if (!processedPos) {
              itemsData[i] = this.createGroupElement(arr[i]);
            } else {
              jLen = itemsData[i].it.length;

              for (j = 0; j < jLen; j += 1) {
                itemsData[i].prevViewData[j] = itemsData[i].it[j];
              }
            }

            this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);

            if (arr[i]._render) {
              if (itemsData[i].gr.parentNode !== container) {
                container.appendChild(itemsData[i].gr);
              }
            }
          } else if (arr[i].ty === 'tr') {
            if (!processedPos) {
              itemsData[i] = this.createTransformElement(arr[i], container);
            }

            currentTransform = itemsData[i].transform;
            ownTransformers.push(currentTransform);
          } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
            if (!processedPos) {
              itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
            }

            this.setElementStyles(itemsData[i]);
          } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              modifier.init(this, arr[i]);
              itemsData[i] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i];
              modifier.closed = false;
            }

            ownModifiers.push(modifier);
          } else if (arr[i].ty === 'rp') {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              itemsData[i] = modifier;
              modifier.init(this, arr, i, itemsData);
              this.shapeModifiers.push(modifier);
              render = false;
            } else {
              modifier = itemsData[i];
              modifier.closed = true;
            }

            ownModifiers.push(modifier);
          }

          this.addProcessedElement(arr[i], i + 1);
        }

        len = ownStyles.length;

        for (i = 0; i < len; i += 1) {
          ownStyles[i].closed = true;
        }

        len = ownModifiers.length;

        for (i = 0; i < len; i += 1) {
          ownModifiers[i].closed = true;
        }
      };

      SVGShapeElement.prototype.renderInnerContent = function () {
        this.renderModifiers();
        var i;
        var len = this.stylesList.length;

        for (i = 0; i < len; i += 1) {
          this.stylesList[i].reset();
        }

        this.renderShape();

        for (i = 0; i < len; i += 1) {
          if (this.stylesList[i]._mdf || this._isFirstFrame) {
            if (this.stylesList[i].msElem) {
              this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers

              this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
            }

            this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
          }
        }
      };

      SVGShapeElement.prototype.renderShape = function () {
        var i;
        var len = this.animatedContents.length;
        var animatedContent;

        for (i = 0; i < len; i += 1) {
          animatedContent = this.animatedContents[i];

          if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
          }
        }
      };

      SVGShapeElement.prototype.destroy = function () {
        this.destroyBaseElement();
        this.shapesData = null;
        this.itemsData = null;
      };

      function LetterProps(o, sw, sc, fc, m, p) {
        this.o = o;
        this.sw = sw;
        this.sc = sc;
        this.fc = fc;
        this.m = m;
        this.p = p;
        this._mdf = {
          o: true,
          sw: !!sw,
          sc: !!sc,
          fc: !!fc,
          m: true,
          p: true
        };
      }

      LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
        this._mdf.o = false;
        this._mdf.sw = false;
        this._mdf.sc = false;
        this._mdf.fc = false;
        this._mdf.m = false;
        this._mdf.p = false;
        var updated = false;

        if (this.o !== o) {
          this.o = o;
          this._mdf.o = true;
          updated = true;
        }

        if (this.sw !== sw) {
          this.sw = sw;
          this._mdf.sw = true;
          updated = true;
        }

        if (this.sc !== sc) {
          this.sc = sc;
          this._mdf.sc = true;
          updated = true;
        }

        if (this.fc !== fc) {
          this.fc = fc;
          this._mdf.fc = true;
          updated = true;
        }

        if (this.m !== m) {
          this.m = m;
          this._mdf.m = true;
          updated = true;
        }

        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
          this.p = p;
          this._mdf.p = true;
          updated = true;
        }

        return updated;
      };

      function TextProperty(elem, data) {
        this._frameId = initialDefaultFrame;
        this.pv = '';
        this.v = '';
        this.kf = false;
        this._isFirstFrame = true;
        this._mdf = false;
        this.data = data;
        this.elem = elem;
        this.comp = this.elem.comp;
        this.keysIndex = 0;
        this.canResize = false;
        this.minimumFontSize = 1;
        this.effectsSequence = [];
        this.currentData = {
          ascent: 0,
          boxWidth: this.defaultBoxWidth,
          f: '',
          fStyle: '',
          fWeight: '',
          fc: '',
          j: '',
          justifyOffset: '',
          l: [],
          lh: 0,
          lineWidths: [],
          ls: '',
          of: '',
          s: '',
          sc: '',
          sw: 0,
          t: 0,
          tr: 0,
          sz: 0,
          ps: null,
          fillColorAnim: false,
          strokeColorAnim: false,
          strokeWidthAnim: false,
          yOffset: 0,
          finalSize: 0,
          finalText: [],
          finalLineHeight: 0,
          __complete: false
        };
        this.copyData(this.currentData, this.data.d.k[0].s);

        if (!this.searchProperty()) {
          this.completeTextData(this.currentData);
        }
      }

      TextProperty.prototype.defaultBoxWidth = [0, 0];

      TextProperty.prototype.copyData = function (obj, data) {
        for (var s in data) {
          if (Object.prototype.hasOwnProperty.call(data, s)) {
            obj[s] = data[s];
          }
        }

        return obj;
      };

      TextProperty.prototype.setCurrentData = function (data) {
        if (!data.__complete) {
          this.completeTextData(data);
        }

        this.currentData = data;
        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
        this._mdf = true;
      };

      TextProperty.prototype.searchProperty = function () {
        return this.searchKeyframes();
      };

      TextProperty.prototype.searchKeyframes = function () {
        this.kf = this.data.d.k.length > 1;

        if (this.kf) {
          this.addEffect(this.getKeyframeValue.bind(this));
        }

        return this.kf;
      };

      TextProperty.prototype.addEffect = function (effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.elem.addDynamicProperty(this);
      };

      TextProperty.prototype.getValue = function (_finalValue) {
        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
          return;
        }

        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var currentValue = this.currentData;
        var currentIndex = this.keysIndex;

        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }

        this.lock = true;
        this._mdf = false;
        var i;
        var len = this.effectsSequence.length;
        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;

        for (i = 0; i < len; i += 1) {
          // Checking if index changed to prevent creating a new object every time the expression updates.
          if (currentIndex !== this.keysIndex) {
            finalValue = this.effectsSequence[i](finalValue, finalValue.t);
          } else {
            finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
          }
        }

        if (currentValue !== finalValue) {
          this.setCurrentData(finalValue);
        }

        this.v = this.currentData;
        this.pv = this.v;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      };

      TextProperty.prototype.getKeyframeValue = function () {
        var textKeys = this.data.d.k;
        var frameNum = this.elem.comp.renderedFrame;
        var i = 0;
        var len = textKeys.length;

        while (i <= len - 1) {
          if (i === len - 1 || textKeys[i + 1].t > frameNum) {
            break;
          }

          i += 1;
        }

        if (this.keysIndex !== i) {
          this.keysIndex = i;
        }

        return this.data.d.k[this.keysIndex].s;
      };

      TextProperty.prototype.buildFinalText = function (text) {
        var charactersArray = [];
        var i = 0;
        var len = text.length;
        var charCode;
        var secondCharCode;
        var shouldCombine = false;

        while (i < len) {
          charCode = text.charCodeAt(i);

          if (FontManager.isCombinedCharacter(charCode)) {
            charactersArray[charactersArray.length - 1] += text.charAt(i);
          } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
            secondCharCode = text.charCodeAt(i + 1);

            if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
              if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
                charactersArray[charactersArray.length - 1] += text.substr(i, 2);
                shouldCombine = false;
              } else {
                charactersArray.push(text.substr(i, 2));
              }

              i += 1;
            } else {
              charactersArray.push(text.charAt(i));
            }
          } else if (charCode > 0xDBFF) {
            secondCharCode = text.charCodeAt(i + 1);

            if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
              shouldCombine = true;
              charactersArray[charactersArray.length - 1] += text.substr(i, 2);
              i += 1;
            } else {
              charactersArray.push(text.charAt(i));
            }
          } else if (FontManager.isZeroWidthJoiner(charCode)) {
            charactersArray[charactersArray.length - 1] += text.charAt(i);
            shouldCombine = true;
          } else {
            charactersArray.push(text.charAt(i));
          }

          i += 1;
        }

        return charactersArray;
      };

      TextProperty.prototype.completeTextData = function (documentData) {
        documentData.__complete = true;
        var fontManager = this.elem.globalData.fontManager;
        var data = this.data;
        var letters = [];
        var i;
        var len;
        var newLineFlag;
        var index = 0;
        var val;
        var anchorGrouping = data.m.g;
        var currentSize = 0;
        var currentPos = 0;
        var currentLine = 0;
        var lineWidths = [];
        var lineWidth = 0;
        var maxLineWidth = 0;
        var j;
        var jLen;
        var fontData = fontManager.getFontByName(documentData.f);
        var charData;
        var cLength = 0;
        var fontProps = getFontProperties(fontData);
        documentData.fWeight = fontProps.weight;
        documentData.fStyle = fontProps.style;
        documentData.finalSize = documentData.s;
        documentData.finalText = this.buildFinalText(documentData.t);
        len = documentData.finalText.length;
        documentData.finalLineHeight = documentData.lh;
        var trackingOffset = documentData.tr / 1000 * documentData.finalSize;
        var charCode;

        if (documentData.sz) {
          var flag = true;
          var boxWidth = documentData.sz[0];
          var boxHeight = documentData.sz[1];
          var currentHeight;
          var finalText;

          while (flag) {
            finalText = this.buildFinalText(documentData.t);
            currentHeight = 0;
            lineWidth = 0;
            len = finalText.length;
            trackingOffset = documentData.tr / 1000 * documentData.finalSize;
            var lastSpaceIndex = -1;

            for (i = 0; i < len; i += 1) {
              charCode = finalText[i].charCodeAt(0);
              newLineFlag = false;

              if (finalText[i] === ' ') {
                lastSpaceIndex = i;
              } else if (charCode === 13 || charCode === 3) {
                lineWidth = 0;
                newLineFlag = true;
                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              }

              if (fontManager.chars) {
                charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
              } else {
                // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
                cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
              }

              if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
                if (lastSpaceIndex === -1) {
                  len += 1;
                } else {
                  i = lastSpaceIndex;
                }

                currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r'); // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);

                lastSpaceIndex = -1;
                lineWidth = 0;
              } else {
                lineWidth += cLength;
                lineWidth += trackingOffset;
              }
            }

            currentHeight += fontData.ascent * documentData.finalSize / 100;

            if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
              documentData.finalSize -= 1;
              documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
            } else {
              documentData.finalText = finalText;
              len = documentData.finalText.length;
              flag = false;
            }
          }
        }

        lineWidth = -trackingOffset;
        cLength = 0;
        var uncollapsedSpaces = 0;
        var currentChar;

        for (i = 0; i < len; i += 1) {
          newLineFlag = false;
          currentChar = documentData.finalText[i];
          charCode = currentChar.charCodeAt(0);

          if (charCode === 13 || charCode === 3) {
            uncollapsedSpaces = 0;
            lineWidths.push(lineWidth);
            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
            lineWidth = -2 * trackingOffset;
            val = '';
            newLineFlag = true;
            currentLine += 1;
          } else {
            val = currentChar;
          }

          if (fontManager.chars) {
            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
            cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
          } else {
            // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
            // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
            cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
          } //


          if (currentChar === ' ') {
            uncollapsedSpaces += cLength + trackingOffset;
          } else {
            lineWidth += cLength + trackingOffset + uncollapsedSpaces;
            uncollapsedSpaces = 0;
          }

          letters.push({
            l: cLength,
            an: cLength,
            add: currentSize,
            n: newLineFlag,
            anIndexes: [],
            val: val,
            line: currentLine,
            animatorJustifyOffset: 0
          });

          if (anchorGrouping == 2) {
            // eslint-disable-line eqeqeq
            currentSize += cLength;

            if (val === '' || val === ' ' || i === len - 1) {
              if (val === '' || val === ' ') {
                currentSize -= cLength;
              }

              while (currentPos <= i) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }

              index += 1;
              currentSize = 0;
            }
          } else if (anchorGrouping == 3) {
            // eslint-disable-line eqeqeq
            currentSize += cLength;

            if (val === '' || i === len - 1) {
              if (val === '') {
                currentSize -= cLength;
              }

              while (currentPos <= i) {
                letters[currentPos].an = currentSize;
                letters[currentPos].ind = index;
                letters[currentPos].extra = cLength;
                currentPos += 1;
              }

              currentSize = 0;
              index += 1;
            }
          } else {
            letters[index].ind = index;
            letters[index].extra = 0;
            index += 1;
          }
        }

        documentData.l = letters;
        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
        lineWidths.push(lineWidth);

        if (documentData.sz) {
          documentData.boxWidth = documentData.sz[0];
          documentData.justifyOffset = 0;
        } else {
          documentData.boxWidth = maxLineWidth;

          switch (documentData.j) {
            case 1:
              documentData.justifyOffset = -documentData.boxWidth;
              break;

            case 2:
              documentData.justifyOffset = -documentData.boxWidth / 2;
              break;

            default:
              documentData.justifyOffset = 0;
          }
        }

        documentData.lineWidths = lineWidths;
        var animators = data.a;
        var animatorData;
        var letterData;
        jLen = animators.length;
        var based;
        var ind;
        var indexes = [];

        for (j = 0; j < jLen; j += 1) {
          animatorData = animators[j];

          if (animatorData.a.sc) {
            documentData.strokeColorAnim = true;
          }

          if (animatorData.a.sw) {
            documentData.strokeWidthAnim = true;
          }

          if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
            documentData.fillColorAnim = true;
          }

          ind = 0;
          based = animatorData.s.b;

          for (i = 0; i < len; i += 1) {
            letterData = letters[i];
            letterData.anIndexes[j] = ind;

            if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {
              // eslint-disable-line eqeqeq
              if (animatorData.s.rn === 1) {
                indexes.push(ind);
              }

              ind += 1;
            }
          }

          data.a[j].s.totalChars = ind;
          var currentInd = -1;
          var newInd;

          if (animatorData.s.rn === 1) {
            for (i = 0; i < len; i += 1) {
              letterData = letters[i];

              if (currentInd != letterData.anIndexes[j]) {
                // eslint-disable-line eqeqeq
                currentInd = letterData.anIndexes[j];
                newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
              }

              letterData.anIndexes[j] = newInd;
            }
          }
        }

        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
        documentData.ls = documentData.ls || 0;
        documentData.ascent = fontData.ascent * documentData.finalSize / 100;
      };

      TextProperty.prototype.updateDocumentData = function (newData, index) {
        index = index === undefined ? this.keysIndex : index;
        var dData = this.copyData({}, this.data.d.k[index].s);
        dData = this.copyData(dData, newData);
        this.data.d.k[index].s = dData;
        this.recalculate(index);
        this.elem.addDynamicProperty(this);
      };

      TextProperty.prototype.recalculate = function (index) {
        var dData = this.data.d.k[index].s;
        dData.__complete = false;
        this.keysIndex = 0;
        this._isFirstFrame = true;
        this.getValue(dData);
      };

      TextProperty.prototype.canResizeFont = function (_canResize) {
        this.canResize = _canResize;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };

      TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
        this.minimumFontSize = Math.floor(_fontValue) || 1;
        this.recalculate(this.keysIndex);
        this.elem.addDynamicProperty(this);
      };

      var TextSelectorProp = function () {
        var max = Math.max;
        var min = Math.min;
        var floor = Math.floor;

        function TextSelectorPropFactory(elem, data) {
          this._currentTextLength = -1;
          this.k = false;
          this.data = data;
          this.elem = elem;
          this.comp = elem.comp;
          this.finalS = 0;
          this.finalE = 0;
          this.initDynamicPropertyContainer(elem);
          this.s = PropertyFactory.getProp(elem, data.s || {
            k: 0
          }, 0, 0, this);

          if ('e' in data) {
            this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
          } else {
            this.e = {
              v: 100
            };
          }

          this.o = PropertyFactory.getProp(elem, data.o || {
            k: 0
          }, 0, 0, this);
          this.xe = PropertyFactory.getProp(elem, data.xe || {
            k: 0
          }, 0, 0, this);
          this.ne = PropertyFactory.getProp(elem, data.ne || {
            k: 0
          }, 0, 0, this);
          this.sm = PropertyFactory.getProp(elem, data.sm || {
            k: 100
          }, 0, 0, this);
          this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);

          if (!this.dynamicProperties.length) {
            this.getValue();
          }
        }

        TextSelectorPropFactory.prototype = {
          getMult: function getMult(ind) {
            if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
              this.getValue();
            }

            var x1 = 0;
            var y1 = 0;
            var x2 = 1;
            var y2 = 1;

            if (this.ne.v > 0) {
              x1 = this.ne.v / 100.0;
            } else {
              y1 = -this.ne.v / 100.0;
            }

            if (this.xe.v > 0) {
              x2 = 1.0 - this.xe.v / 100.0;
            } else {
              y2 = 1.0 + this.xe.v / 100.0;
            }

            var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;
            var mult = 0;
            var s = this.finalS;
            var e = this.finalE;
            var type = this.data.sh;

            if (type === 2) {
              if (e === s) {
                mult = ind >= e ? 1 : 0;
              } else {
                mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              }

              mult = easer(mult);
            } else if (type === 3) {
              if (e === s) {
                mult = ind >= e ? 0 : 1;
              } else {
                mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              }

              mult = easer(mult);
            } else if (type === 4) {
              if (e === s) {
                mult = 0;
              } else {
                mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));

                if (mult < 0.5) {
                  mult *= 2;
                } else {
                  mult = 1 - 2 * (mult - 0.5);
                }
              }

              mult = easer(mult);
            } else if (type === 5) {
              if (e === s) {
                mult = 0;
              } else {
                var tot = e - s;
                /* ind += 0.5;
                          mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */

                ind = min(max(0, ind + 0.5 - s), e - s);
                var x = -tot / 2 + ind;
                var a = tot / 2;
                mult = Math.sqrt(1 - x * x / (a * a));
              }

              mult = easer(mult);
            } else if (type === 6) {
              if (e === s) {
                mult = 0;
              } else {
                ind = min(max(0, ind + 0.5 - s), e - s);
                mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line
              }

              mult = easer(mult);
            } else {
              if (ind >= floor(s)) {
                if (ind - s < 0) {
                  mult = max(0, min(min(e, 1) - (s - ind), 1));
                } else {
                  mult = max(0, min(e - ind, 1));
                }
              }

              mult = easer(mult);
            } // Smoothness implementation.
            // The smoothness represents a reduced range of the original [0; 1] range.
            // if smoothness is 25%, the new range will be [0.375; 0.625]
            // Steps are:
            // - find the lower value of the new range (threshold)
            // - if multiplier is smaller than that value, floor it to 0
            // - if it is larger,
            //     - subtract the threshold
            //     - divide it by the smoothness (this will return the range to [0; 1])
            // Note: If it doesn't work on some scenarios, consider applying it before the easer.


            if (this.sm.v !== 100) {
              var smoothness = this.sm.v * 0.01;

              if (smoothness === 0) {
                smoothness = 0.00000001;
              }

              var threshold = 0.5 - smoothness * 0.5;

              if (mult < threshold) {
                mult = 0;
              } else {
                mult = (mult - threshold) / smoothness;

                if (mult > 1) {
                  mult = 1;
                }
              }
            }

            return mult * this.a.v;
          },
          getValue: function getValue(newCharsFlag) {
            this.iterateDynamicProperties();
            this._mdf = newCharsFlag || this._mdf;
            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;

            if (newCharsFlag && this.data.r === 2) {
              this.e.v = this._currentTextLength;
            }

            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
            var o = this.o.v / divisor;
            var s = this.s.v / divisor + o;
            var e = this.e.v / divisor + o;

            if (s > e) {
              var _s = s;
              s = e;
              e = _s;
            }

            this.finalS = s;
            this.finalE = e;
          }
        };
        extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);

        function getTextSelectorProp(elem, data, arr) {
          return new TextSelectorPropFactory(elem, data, arr);
        }

        return {
          getTextSelectorProp: getTextSelectorProp
        };
      }();

      function TextAnimatorDataProperty(elem, animatorProps, container) {
        var defaultData = {
          propType: false
        };
        var getProp = PropertyFactory.getProp;
        var textAnimatorAnimatables = animatorProps.a;
        this.a = {
          r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
          rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
          ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
          sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
          sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
          s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
          a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
          o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
          p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
          sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
          sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
          fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
          fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
          fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
          fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
          t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
        };
        this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
        this.s.t = animatorProps.s.t;
      }

      function TextAnimatorProperty(textData, renderType, elem) {
        this._isFirstFrame = true;
        this._hasMaskedPath = false;
        this._frameId = -1;
        this._textData = textData;
        this._renderType = renderType;
        this._elem = elem;
        this._animatorsData = createSizedArray(this._textData.a.length);
        this._pathData = {};
        this._moreOptions = {
          alignment: {}
        };
        this.renderedLetters = [];
        this.lettersChangedFlag = false;
        this.initDynamicPropertyContainer(elem);
      }

      TextAnimatorProperty.prototype.searchProperties = function () {
        var i;
        var len = this._textData.a.length;
        var animatorProps;
        var getProp = PropertyFactory.getProp;

        for (i = 0; i < len; i += 1) {
          animatorProps = this._textData.a[i];
          this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
        }

        if (this._textData.p && 'm' in this._textData.p) {
          this._pathData = {
            a: getProp(this._elem, this._textData.p.a, 0, 0, this),
            f: getProp(this._elem, this._textData.p.f, 0, 0, this),
            l: getProp(this._elem, this._textData.p.l, 0, 0, this),
            r: getProp(this._elem, this._textData.p.r, 0, 0, this),
            p: getProp(this._elem, this._textData.p.p, 0, 0, this),
            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
          };
          this._hasMaskedPath = true;
        } else {
          this._hasMaskedPath = false;
        }

        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
      };

      TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
        this.lettersChangedFlag = lettersChangedFlag;

        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
          return;
        }

        this._isFirstFrame = false;
        var alignment = this._moreOptions.alignment.v;
        var animators = this._animatorsData;
        var textData = this._textData;
        var matrixHelper = this.mHelper;
        var renderType = this._renderType;
        var renderedLettersCount = this.renderedLetters.length;
        var xPos;
        var yPos;
        var i;
        var len;
        var letters = documentData.l;
        var pathInfo;
        var currentLength;
        var currentPoint;
        var segmentLength;
        var flag;
        var pointInd;
        var segmentInd;
        var prevPoint;
        var points;
        var segments;
        var partialLength;
        var totalLength;
        var perc;
        var tanAngle;
        var mask;

        if (this._hasMaskedPath) {
          mask = this._pathData.m;

          if (!this._pathData.n || this._pathData._mdf) {
            var paths = mask.v;

            if (this._pathData.r.v) {
              paths = paths.reverse();
            } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi


            pathInfo = {
              tLength: 0,
              segments: []
            };
            len = paths._length - 1;
            var bezierData;
            totalLength = 0;

            for (i = 0; i < len; i += 1) {
              bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }

            i = len;

            if (mask.v.c) {
              bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]], [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
              pathInfo.tLength += bezierData.segmentLength;
              pathInfo.segments.push(bezierData);
              totalLength += bezierData.segmentLength;
            }

            this._pathData.pi = pathInfo;
          }

          pathInfo = this._pathData.pi;
          currentLength = this._pathData.f.v;
          segmentInd = 0;
          pointInd = 1;
          segmentLength = 0;
          flag = true;
          segments = pathInfo.segments;

          if (currentLength < 0 && mask.v.c) {
            if (pathInfo.tLength < Math.abs(currentLength)) {
              currentLength = -Math.abs(currentLength) % pathInfo.tLength;
            }

            segmentInd = segments.length - 1;
            points = segments[segmentInd].points;
            pointInd = points.length - 1;

            while (currentLength < 0) {
              currentLength += points[pointInd].partialLength;
              pointInd -= 1;

              if (pointInd < 0) {
                segmentInd -= 1;
                points = segments[segmentInd].points;
                pointInd = points.length - 1;
              }
            }
          }

          points = segments[segmentInd].points;
          prevPoint = points[pointInd - 1];
          currentPoint = points[pointInd];
          partialLength = currentPoint.partialLength;
        }

        len = letters.length;
        xPos = 0;
        yPos = 0;
        var yOff = documentData.finalSize * 1.2 * 0.714;
        var firstLine = true;
        var animatorProps;
        var animatorSelector;
        var j;
        var jLen;
        var letterValue;
        jLen = animators.length;
        var mult;
        var ind = -1;
        var offf;
        var xPathPos;
        var yPathPos;
        var initPathPos = currentLength;
        var initSegmentInd = segmentInd;
        var initPointInd = pointInd;
        var currentLine = -1;
        var elemOpacity;
        var sc;
        var sw;
        var fc;
        var k;
        var letterSw;
        var letterSc;
        var letterFc;
        var letterM = '';
        var letterP = this.defaultPropsArray;
        var letterO; //

        if (documentData.j === 2 || documentData.j === 1) {
          var animatorJustifyOffset = 0;
          var animatorFirstCharOffset = 0;
          var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
          var lastIndex = 0;
          var isNewLine = true;

          for (i = 0; i < len; i += 1) {
            if (letters[i].n) {
              if (animatorJustifyOffset) {
                animatorJustifyOffset += animatorFirstCharOffset;
              }

              while (lastIndex < i) {
                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                lastIndex += 1;
              }

              animatorJustifyOffset = 0;
              isNewLine = true;
            } else {
              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;

                if (animatorProps.t.propType) {
                  if (isNewLine && documentData.j === 2) {
                    animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                  }

                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                  if (mult.length) {
                    animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                  } else {
                    animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                  }
                }
              }

              isNewLine = false;
            }
          }

          if (animatorJustifyOffset) {
            animatorJustifyOffset += animatorFirstCharOffset;
          }

          while (lastIndex < i) {
            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
            lastIndex += 1;
          }
        } //


        for (i = 0; i < len; i += 1) {
          matrixHelper.reset();
          elemOpacity = 1;

          if (letters[i].n) {
            xPos = 0;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            currentLength = initPathPos;
            firstLine = false;

            if (this._hasMaskedPath) {
              segmentInd = initSegmentInd;
              pointInd = initPointInd;
              points = segments[segmentInd].points;
              prevPoint = points[pointInd - 1];
              currentPoint = points[pointInd];
              partialLength = currentPoint.partialLength;
              segmentLength = 0;
            }

            letterM = '';
            letterFc = '';
            letterSw = '';
            letterO = '';
            letterP = this.defaultPropsArray;
          } else {
            if (this._hasMaskedPath) {
              if (currentLine !== letters[i].line) {
                switch (documentData.j) {
                  case 1:
                    currentLength += totalLength - documentData.lineWidths[letters[i].line];
                    break;

                  case 2:
                    currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                    break;
                }

                currentLine = letters[i].line;
              }

              if (ind !== letters[i].ind) {
                if (letters[ind]) {
                  currentLength += letters[ind].extra;
                }

                currentLength += letters[i].an / 2;
                ind = letters[i].ind;
              }

              currentLength += alignment[0] * letters[i].an * 0.005;
              var animatorOffset = 0;

              for (j = 0; j < jLen; j += 1) {
                animatorProps = animators[j].a;

                if (animatorProps.p.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                  if (mult.length) {
                    animatorOffset += animatorProps.p.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.p.v[0] * mult;
                  }
                }

                if (animatorProps.a.propType) {
                  animatorSelector = animators[j].s;
                  mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                  if (mult.length) {
                    animatorOffset += animatorProps.a.v[0] * mult[0];
                  } else {
                    animatorOffset += animatorProps.a.v[0] * mult;
                  }
                }
              }

              flag = true; // Force alignment only works with a single line for now

              if (this._pathData.a.v) {
                currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                currentLength += this._pathData.f.v;
              }

              while (flag) {
                if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                  perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                  xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                  yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                  matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);
                  flag = false;
                } else if (points) {
                  segmentLength += currentPoint.partialLength;
                  pointInd += 1;

                  if (pointInd >= points.length) {
                    pointInd = 0;
                    segmentInd += 1;

                    if (!segments[segmentInd]) {
                      if (mask.v.c) {
                        pointInd = 0;
                        segmentInd = 0;
                        points = segments[segmentInd].points;
                      } else {
                        segmentLength -= currentPoint.partialLength;
                        points = null;
                      }
                    } else {
                      points = segments[segmentInd].points;
                    }
                  }

                  if (points) {
                    prevPoint = currentPoint;
                    currentPoint = points[pointInd];
                    partialLength = currentPoint.partialLength;
                  }
                }
              }

              offf = letters[i].an / 2 - letters[i].add;
              matrixHelper.translate(-offf, 0, 0);
            } else {
              offf = letters[i].an / 2 - letters[i].add;
              matrixHelper.translate(-offf, 0, 0); // Grouping alignment

              matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);
            }

            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;

              if (animatorProps.t.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"

                if (xPos !== 0 || documentData.j !== 0) {
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      currentLength += animatorProps.t.v * mult[0];
                    } else {
                      currentLength += animatorProps.t.v * mult;
                    }
                  } else if (mult.length) {
                    xPos += animatorProps.t.v * mult[0];
                  } else {
                    xPos += animatorProps.t.v * mult;
                  }
                }
              }
            }

            if (documentData.strokeWidthAnim) {
              sw = documentData.sw || 0;
            }

            if (documentData.strokeColorAnim) {
              if (documentData.sc) {
                sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
              } else {
                sc = [0, 0, 0];
              }
            }

            if (documentData.fillColorAnim && documentData.fc) {
              fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
            }

            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;

              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                if (mult.length) {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                }
              }
            }

            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;

              if (animatorProps.s.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                if (mult.length) {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                } else {
                  matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                }
              }
            }

            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

              if (animatorProps.sk.propType) {
                if (mult.length) {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                } else {
                  matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                }
              }

              if (animatorProps.r.propType) {
                if (mult.length) {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                } else {
                  matrixHelper.rotateZ(-animatorProps.r.v * mult);
                }
              }

              if (animatorProps.ry.propType) {
                if (mult.length) {
                  matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                } else {
                  matrixHelper.rotateY(animatorProps.ry.v * mult);
                }
              }

              if (animatorProps.rx.propType) {
                if (mult.length) {
                  matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                } else {
                  matrixHelper.rotateX(animatorProps.rx.v * mult);
                }
              }

              if (animatorProps.o.propType) {
                if (mult.length) {
                  elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                } else {
                  elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                }
              }

              if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                if (mult.length) {
                  sw += animatorProps.sw.v * mult[0];
                } else {
                  sw += animatorProps.sw.v * mult;
                }
              }

              if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                  } else {
                    sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                  }
                }
              }

              if (documentData.fillColorAnim && documentData.fc) {
                if (animatorProps.fc.propType) {
                  for (k = 0; k < 3; k += 1) {
                    if (mult.length) {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                    } else {
                      fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                    }
                  }
                }

                if (animatorProps.fh.propType) {
                  if (mult.length) {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                  } else {
                    fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                  }
                }

                if (animatorProps.fs.propType) {
                  if (mult.length) {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                  } else {
                    fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                  }
                }

                if (animatorProps.fb.propType) {
                  if (mult.length) {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                  } else {
                    fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                  }
                }
              }
            }

            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;

              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

                if (this._hasMaskedPath) {
                  if (mult.length) {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                  } else {
                    matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                } else if (mult.length) {
                  matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                } else {
                  matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              }
            }

            if (documentData.strokeWidthAnim) {
              letterSw = sw < 0 ? 0 : sw;
            }

            if (documentData.strokeColorAnim) {
              letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
            }

            if (documentData.fillColorAnim && documentData.fc) {
              letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
            }

            if (this._hasMaskedPath) {
              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);

              if (this._pathData.p.v) {
                tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                var rot = Math.atan(tanAngle) * 180 / Math.PI;

                if (currentPoint.point[0] < prevPoint.point[0]) {
                  rot += 180;
                }

                matrixHelper.rotate(-rot * Math.PI / 180);
              }

              matrixHelper.translate(xPathPos, yPathPos, 0);
              currentLength -= alignment[0] * letters[i].an * 0.005;

              if (letters[i + 1] && ind !== letters[i + 1].ind) {
                currentLength += letters[i].an / 2;
                currentLength += documentData.tr * 0.001 * documentData.finalSize;
              }
            } else {
              matrixHelper.translate(xPos, yPos, 0);

              if (documentData.ps) {
                // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
                matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
              }

              switch (documentData.j) {
                case 1:
                  matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                  break;

                case 2:
                  matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                  break;
              }

              matrixHelper.translate(0, -documentData.ls);
              matrixHelper.translate(offf, 0, 0);
              matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);
              xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;
            }

            if (renderType === 'html') {
              letterM = matrixHelper.toCSS();
            } else if (renderType === 'svg') {
              letterM = matrixHelper.to2dCSS();
            } else {
              letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
            }

            letterO = elemOpacity;
          }

          if (renderedLettersCount <= i) {
            letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
            this.renderedLetters.push(letterValue);
            renderedLettersCount += 1;
            this.lettersChangedFlag = true;
          } else {
            letterValue = this.renderedLetters[i];
            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
          }
        }
      };

      TextAnimatorProperty.prototype.getValue = function () {
        if (this._elem.globalData.frameId === this._frameId) {
          return;
        }

        this._frameId = this._elem.globalData.frameId;
        this.iterateDynamicProperties();
      };

      TextAnimatorProperty.prototype.mHelper = new Matrix();
      TextAnimatorProperty.prototype.defaultPropsArray = [];
      extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

      function ITextElement() {}

      ITextElement.prototype.initElement = function (data, globalData, comp) {
        this.lettersChangedFlag = true;
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
        this.initRenderable();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();
        this.createContent();
        this.hide();
        this.textAnimator.searchProperties(this.dynamicProperties);
      };

      ITextElement.prototype.prepareFrame = function (num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);

        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
          this.buildNewText();
          this.textProperty._isFirstFrame = false;
          this.textProperty._mdf = false;
        }
      };

      ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
        var j;
        var jLen = shapes.length;
        var pathNodes;
        var shapeStr = '';

        for (j = 0; j < jLen; j += 1) {
          if (shapes[j].ty === 'sh') {
            pathNodes = shapes[j].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
        }

        return shapeStr;
      };

      ITextElement.prototype.updateDocumentData = function (newData, index) {
        this.textProperty.updateDocumentData(newData, index);
      };

      ITextElement.prototype.canResizeFont = function (_canResize) {
        this.textProperty.canResizeFont(_canResize);
      };

      ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
        this.textProperty.setMinimumFontSize(_fontSize);
      };

      ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
        if (documentData.ps) {
          matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
        }

        matrixHelper.translate(0, -documentData.ls, 0);

        switch (documentData.j) {
          case 1:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
            break;

          case 2:
            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
            break;
        }

        matrixHelper.translate(xPos, yPos, 0);
      };

      ITextElement.prototype.buildColor = function (colorData) {
        return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
      };

      ITextElement.prototype.emptyProp = new LetterProps();

      ITextElement.prototype.destroy = function () {};

      var emptyShapeData = {
        shapes: []
      };

      function SVGTextLottieElement(data, globalData, comp) {
        this.textSpans = [];
        this.renderType = 'svg';
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);

      SVGTextLottieElement.prototype.createContent = function () {
        if (this.data.singleShape && !this.globalData.fontManager.chars) {
          this.textContainer = createNS('text');
        }
      };

      SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
        var i = 0;
        var len = textArray.length;
        var textContents = [];
        var currentTextContent = '';

        while (i < len) {
          if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
            textContents.push(currentTextContent);
            currentTextContent = '';
          } else {
            currentTextContent += textArray[i];
          }

          i += 1;
        }

        textContents.push(currentTextContent);
        return textContents;
      };

      SVGTextLottieElement.prototype.buildShapeData = function (data, scale) {
        // data should probably be cloned to apply scale separately to each instance of a text on different layers
        // but since text internal content gets only rendered once and then it's never rerendered,
        // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
        // Avoiding cloning is preferred since cloning each character shape data is expensive
        if (data.shapes && data.shapes.length) {
          var shape = data.shapes[0];

          if (shape.it) {
            var shapeItem = shape.it[shape.it.length - 1];

            if (shapeItem.s) {
              shapeItem.s.k[0] = scale;
              shapeItem.s.k[1] = scale;
            }
          }
        }

        return data;
      };

      SVGTextLottieElement.prototype.buildNewText = function () {
        this.addDynamicProperty(this);
        var i;
        var len;
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);

        if (documentData.fc) {
          this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
        } else {
          this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
        }

        if (documentData.sc) {
          this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
          this.layerElement.setAttribute('stroke-width', documentData.sw);
        }

        this.layerElement.setAttribute('font-size', documentData.finalSize);
        var fontData = this.globalData.fontManager.getFontByName(documentData.f);

        if (fontData.fClass) {
          this.layerElement.setAttribute('class', fontData.fClass);
        } else {
          this.layerElement.setAttribute('font-family', fontData.fFamily);
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          this.layerElement.setAttribute('font-style', fStyle);
          this.layerElement.setAttribute('font-weight', fWeight);
        }

        this.layerElement.setAttribute('aria-label', documentData.t);
        var letters = documentData.l || [];
        var usesGlyphs = !!this.globalData.fontManager.chars;
        len = letters.length;
        var tSpan;
        var matrixHelper = this.mHelper;
        var shapeStr = '';
        var singleShape = this.data.singleShape;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;

        if (singleShape && !usesGlyphs && !documentData.sz) {
          var tElement = this.textContainer;
          var justify = 'start';

          switch (documentData.j) {
            case 1:
              justify = 'end';
              break;

            case 2:
              justify = 'middle';
              break;

            default:
              justify = 'start';
              break;
          }

          tElement.setAttribute('text-anchor', justify);
          tElement.setAttribute('letter-spacing', trackingOffset);
          var textContent = this.buildTextContents(documentData.finalText);
          len = textContent.length;
          yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;

          for (i = 0; i < len; i += 1) {
            tSpan = this.textSpans[i].span || createNS('tspan');
            tSpan.textContent = textContent[i];
            tSpan.setAttribute('x', 0);
            tSpan.setAttribute('y', yPos);
            tSpan.style.display = 'inherit';
            tElement.appendChild(tSpan);

            if (!this.textSpans[i]) {
              this.textSpans[i] = {
                span: null,
                glyph: null
              };
            }

            this.textSpans[i].span = tSpan;
            yPos += documentData.finalLineHeight;
          }

          this.layerElement.appendChild(tElement);
        } else {
          var cachedSpansLength = this.textSpans.length;
          var charData;

          for (i = 0; i < len; i += 1) {
            if (!this.textSpans[i]) {
              this.textSpans[i] = {
                span: null,
                childSpan: null,
                glyph: null
              };
            }

            if (!usesGlyphs || !singleShape || i === 0) {
              tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');

              if (cachedSpansLength <= i) {
                tSpan.setAttribute('stroke-linecap', 'butt');
                tSpan.setAttribute('stroke-linejoin', 'round');
                tSpan.setAttribute('stroke-miterlimit', '4');
                this.textSpans[i].span = tSpan;

                if (usesGlyphs) {
                  var childSpan = createNS('g');
                  tSpan.appendChild(childSpan);
                  this.textSpans[i].childSpan = childSpan;
                }

                this.textSpans[i].span = tSpan;
                this.layerElement.appendChild(tSpan);
              }

              tSpan.style.display = 'inherit';
            }

            matrixHelper.reset();

            if (singleShape) {
              if (letters[i].n) {
                xPos = -trackingOffset;
                yPos += documentData.yOffset;
                yPos += firstLine ? 1 : 0;
                firstLine = false;
              }

              this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
              xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;

              xPos += trackingOffset;
            }

            if (usesGlyphs) {
              charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
              var glyphElement; // t === 1 means the character has been replaced with an animated shaped

              if (charData.t === 1) {
                glyphElement = new SVGCompElement(charData.data, this.globalData, this);
              } else {
                var data = emptyShapeData;

                if (charData.data && charData.data.shapes) {
                  data = this.buildShapeData(charData.data, documentData.finalSize);
                }

                glyphElement = new SVGShapeElement(data, this.globalData, this);
              }

              if (this.textSpans[i].glyph) {
                var glyph = this.textSpans[i].glyph;
                this.textSpans[i].childSpan.removeChild(glyph.layerElement);
                glyph.destroy();
              }

              this.textSpans[i].glyph = glyphElement;
              glyphElement._debug = true;
              glyphElement.prepareFrame(0);
              glyphElement.renderFrame();
              this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale
              // this might have issues with strokes and might need a different solution

              if (charData.t === 1) {
                this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');
              }
            } else {
              if (singleShape) {
                tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
              }

              tSpan.textContent = letters[i].val;
              tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
            } //

          }

          if (singleShape && tSpan) {
            tSpan.setAttribute('d', shapeStr);
          }
        }

        while (i < this.textSpans.length) {
          this.textSpans[i].span.style.display = 'none';
          i += 1;
        }

        this._sizeChanged = true;
      };

      SVGTextLottieElement.prototype.sourceRectAtTime = function () {
        this.prepareFrame(this.comp.renderedFrame - this.data.st);
        this.renderInnerContent();

        if (this._sizeChanged) {
          this._sizeChanged = false;
          var textBox = this.layerElement.getBBox();
          this.bbox = {
            top: textBox.y,
            left: textBox.x,
            width: textBox.width,
            height: textBox.height
          };
        }

        return this.bbox;
      };

      SVGTextLottieElement.prototype.getValue = function () {
        var i;
        var len = this.textSpans.length;
        var glyphElement;
        this.renderedFrame = this.comp.renderedFrame;

        for (i = 0; i < len; i += 1) {
          glyphElement = this.textSpans[i].glyph;

          if (glyphElement) {
            glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);

            if (glyphElement._mdf) {
              this._mdf = true;
            }
          }
        }
      };

      SVGTextLottieElement.prototype.renderInnerContent = function () {
        if (!this.data.singleShape || this._mdf) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);

          if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
            this._sizeChanged = true;
            var i;
            var len;
            var renderedLetters = this.textAnimator.renderedLetters;
            var letters = this.textProperty.currentData.l;
            len = letters.length;
            var renderedLetter;
            var textSpan;
            var glyphElement;

            for (i = 0; i < len; i += 1) {
              if (!letters[i].n) {
                renderedLetter = renderedLetters[i];
                textSpan = this.textSpans[i].span;
                glyphElement = this.textSpans[i].glyph;

                if (glyphElement) {
                  glyphElement.renderFrame();
                }

                if (renderedLetter._mdf.m) {
                  textSpan.setAttribute('transform', renderedLetter.m);
                }

                if (renderedLetter._mdf.o) {
                  textSpan.setAttribute('opacity', renderedLetter.o);
                }

                if (renderedLetter._mdf.sw) {
                  textSpan.setAttribute('stroke-width', renderedLetter.sw);
                }

                if (renderedLetter._mdf.sc) {
                  textSpan.setAttribute('stroke', renderedLetter.sc);
                }

                if (renderedLetter._mdf.fc) {
                  textSpan.setAttribute('fill', renderedLetter.fc);
                }
              }
            }
          }
        }
      };

      function ISolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
      }

      extendPrototype([IImageElement], ISolidElement);

      ISolidElement.prototype.createContent = function () {
        var rect = createNS('rect'); /// /rect.style.width = this.data.sw;
        /// /rect.style.height = this.data.sh;
        /// /rect.style.fill = this.data.sc;

        rect.setAttribute('width', this.data.sw);
        rect.setAttribute('height', this.data.sh);
        rect.setAttribute('fill', this.data.sc);
        this.layerElement.appendChild(rect);
      };

      function NullElement(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initFrame();
        this.initTransform(data, globalData, comp);
        this.initHierarchy();
      }

      NullElement.prototype.prepareFrame = function (num) {
        this.prepareProperties(num, true);
      };

      NullElement.prototype.renderFrame = function () {};

      NullElement.prototype.getBaseElement = function () {
        return null;
      };

      NullElement.prototype.destroy = function () {};

      NullElement.prototype.sourceRectAtTime = function () {};

      NullElement.prototype.hide = function () {};

      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

      function SVGRendererBase() {}

      extendPrototype([BaseRenderer], SVGRendererBase);

      SVGRendererBase.prototype.createNull = function (data) {
        return new NullElement(data, this.globalData, this);
      };

      SVGRendererBase.prototype.createShape = function (data) {
        return new SVGShapeElement(data, this.globalData, this);
      };

      SVGRendererBase.prototype.createText = function (data) {
        return new SVGTextLottieElement(data, this.globalData, this);
      };

      SVGRendererBase.prototype.createImage = function (data) {
        return new IImageElement(data, this.globalData, this);
      };

      SVGRendererBase.prototype.createSolid = function (data) {
        return new ISolidElement(data, this.globalData, this);
      };

      SVGRendererBase.prototype.configAnimation = function (animData) {
        this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');

        if (this.renderConfig.viewBoxSize) {
          this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
        } else {
          this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
        }

        if (!this.renderConfig.viewBoxOnly) {
          this.svgElement.setAttribute('width', animData.w);
          this.svgElement.setAttribute('height', animData.h);
          this.svgElement.style.width = '100%';
          this.svgElement.style.height = '100%';
          this.svgElement.style.transform = 'translate3d(0,0,0)';
          this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
        }

        if (this.renderConfig.width) {
          this.svgElement.setAttribute('width', this.renderConfig.width);
        }

        if (this.renderConfig.height) {
          this.svgElement.setAttribute('height', this.renderConfig.height);
        }

        if (this.renderConfig.className) {
          this.svgElement.setAttribute('class', this.renderConfig.className);
        }

        if (this.renderConfig.id) {
          this.svgElement.setAttribute('id', this.renderConfig.id);
        }

        if (this.renderConfig.focusable !== undefined) {
          this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
        }

        this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';
        // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";

        this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation

        var defs = this.globalData.defs;
        this.setupGlobalData(animData, defs);
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.data = animData;
        var maskElement = createNS('clipPath');
        var rect = createNS('rect');
        rect.setAttribute('width', animData.w);
        rect.setAttribute('height', animData.h);
        rect.setAttribute('x', 0);
        rect.setAttribute('y', 0);
        var maskId = createElementID();
        maskElement.setAttribute('id', maskId);
        maskElement.appendChild(rect);
        this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');
        defs.appendChild(maskElement);
        this.layers = animData.layers;
        this.elements = createSizedArray(animData.layers.length);
      };

      SVGRendererBase.prototype.destroy = function () {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = '';
        }

        this.layerElement = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;

        for (i = 0; i < len; i += 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }

        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };

      SVGRendererBase.prototype.updateContainerSize = function () {};

      SVGRendererBase.prototype.buildItem = function (pos) {
        var elements = this.elements;

        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }

        elements[pos] = true;
        var element = this.createItem(this.layers[pos]);
        elements[pos] = element;

        if (getExpressionsPlugin()) {
          if (this.layers[pos].ty === 0) {
            this.globalData.projectInterface.registerComposition(element);
          }

          element.initExpressions();
        }

        this.appendElementInPos(element, pos);

        if (this.layers[pos].tt) {
          if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
            this.buildItem(pos - 1);
            this.addPendingElement(element);
          } else {
            element.setMatte(elements[pos - 1].layerId);
          }
        }
      };

      SVGRendererBase.prototype.checkPendingElements = function () {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();

          if (element.data.tt) {
            var i = 0;
            var len = this.elements.length;

            while (i < len) {
              if (this.elements[i] === element) {
                element.setMatte(this.elements[i - 1].layerId);
                break;
              }

              i += 1;
            }
          }
        }
      };

      SVGRendererBase.prototype.renderFrame = function (num) {
        if (this.renderedFrame === num || this.destroyed) {
          return;
        }

        if (num === null) {
          num = this.renderedFrame;
        } else {
          this.renderedFrame = num;
        } // console.log('-------');
        // console.log('FRAME ',num);


        this.globalData.frameNum = num;
        this.globalData.frameId += 1;
        this.globalData.projectInterface.currentFrame = num;
        this.globalData._mdf = false;
        var i;
        var len = this.layers.length;

        if (!this.completeLayers) {
          this.checkLayers(num);
        }

        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(num - this.layers[i].st);
          }
        }

        if (this.globalData._mdf) {
          for (i = 0; i < len; i += 1) {
            if (this.completeLayers || this.elements[i]) {
              this.elements[i].renderFrame();
            }
          }
        }
      };

      SVGRendererBase.prototype.appendElementInPos = function (element, pos) {
        var newElement = element.getBaseElement();

        if (!newElement) {
          return;
        }

        var i = 0;
        var nextElement;

        while (i < pos) {
          if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
            nextElement = this.elements[i].getBaseElement();
          }

          i += 1;
        }

        if (nextElement) {
          this.layerElement.insertBefore(newElement, nextElement);
        } else {
          this.layerElement.appendChild(newElement);
        }
      };

      SVGRendererBase.prototype.hide = function () {
        this.layerElement.style.display = 'none';
      };

      SVGRendererBase.prototype.show = function () {
        this.layerElement.style.display = 'block';
      };

      function ICompElement() {}

      extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

      ICompElement.prototype.initElement = function (data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initTransform(data, globalData, comp);
        this.initRenderable();
        this.initHierarchy();
        this.initRendererElement();
        this.createContainerElements();
        this.createRenderableComponents();

        if (this.data.xt || !globalData.progressiveLoad) {
          this.buildAllItems();
        }

        this.hide();
      };
      /* ICompElement.prototype.hide = function(){
          if(!this.hidden){
              this.hideElement();
              var i,len = this.elements.length;
              for( i = 0; i < len; i+=1 ){
                  if(this.elements[i]){
                      this.elements[i].hide();
                  }
              }
          }
      }; */


      ICompElement.prototype.prepareFrame = function (num) {
        this._mdf = false;
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);

        if (!this.isInRange && !this.data.xt) {
          return;
        }

        if (!this.tm._placeholder) {
          var timeRemapped = this.tm.v;

          if (timeRemapped === this.data.op) {
            timeRemapped = this.data.op - 1;
          }

          this.renderedFrame = timeRemapped;
        } else {
          this.renderedFrame = num / this.data.sr;
        }

        var i;
        var len = this.elements.length;

        if (!this.completeLayers) {
          this.checkLayers(this.renderedFrame);
        } // This iteration needs to be backwards because of how expressions connect between each other


        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);

            if (this.elements[i]._mdf) {
              this._mdf = true;
            }
          }
        }
      };

      ICompElement.prototype.renderInnerContent = function () {
        var i;
        var len = this.layers.length;

        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      };

      ICompElement.prototype.setElements = function (elems) {
        this.elements = elems;
      };

      ICompElement.prototype.getElements = function () {
        return this.elements;
      };

      ICompElement.prototype.destroyElements = function () {
        var i;
        var len = this.layers.length;

        for (i = 0; i < len; i += 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }
      };

      ICompElement.prototype.destroy = function () {
        this.destroyElements();
        this.destroyBaseElement();
      };

      function SVGCompElement(data, globalData, comp) {
        this.layers = data.layers;
        this.supports3d = true;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
          _placeholder: true
        };
      }

      extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement);

      SVGCompElement.prototype.createComp = function (data) {
        return new SVGCompElement(data, this.globalData, this);
      };

      function SVGRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.svgElement = createNS('svg');
        var ariaLabel = '';

        if (config && config.title) {
          var titleElement = createNS('title');
          var titleId = createElementID();
          titleElement.setAttribute('id', titleId);
          titleElement.textContent = config.title;
          this.svgElement.appendChild(titleElement);
          ariaLabel += titleId;
        }

        if (config && config.description) {
          var descElement = createNS('desc');
          var descId = createElementID();
          descElement.setAttribute('id', descId);
          descElement.textContent = config.description;
          this.svgElement.appendChild(descElement);
          ariaLabel += ' ' + descId;
        }

        if (ariaLabel) {
          this.svgElement.setAttribute('aria-labelledby', ariaLabel);
        }

        var defs = createNS('defs');
        this.svgElement.appendChild(defs);
        var maskElement = createNS('g');
        this.svgElement.appendChild(maskElement);
        this.layerElement = maskElement;
        this.renderConfig = {
          preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
          contentVisibility: config && config.contentVisibility || 'visible',
          progressiveLoad: config && config.progressiveLoad || false,
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          viewBoxOnly: config && config.viewBoxOnly || false,
          viewBoxSize: config && config.viewBoxSize || false,
          className: config && config.className || '',
          id: config && config.id || '',
          focusable: config && config.focusable,
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || '100%',
            height: config && config.filterSize && config.filterSize.height || '100%',
            x: config && config.filterSize && config.filterSize.x || '0%',
            y: config && config.filterSize && config.filterSize.y || '0%'
          },
          width: config && config.width,
          height: config && config.height
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          defs: defs,
          renderConfig: this.renderConfig
        };
        this.elements = [];
        this.pendingElements = [];
        this.destroyed = false;
        this.rendererType = 'svg';
      }

      extendPrototype([SVGRendererBase], SVGRenderer);

      SVGRenderer.prototype.createComp = function (data) {
        return new SVGCompElement(data, this.globalData, this);
      };

      function CVContextData() {
        this.saved = [];
        this.cArrPos = 0;
        this.cTr = new Matrix();
        this.cO = 1;
        var i;
        var len = 15;
        this.savedOp = createTypedArray('float32', len);

        for (i = 0; i < len; i += 1) {
          this.saved[i] = createTypedArray('float32', 16);
        }

        this._length = len;
      }

      CVContextData.prototype.duplicate = function () {
        var newLength = this._length * 2;
        var currentSavedOp = this.savedOp;
        this.savedOp = createTypedArray('float32', newLength);
        this.savedOp.set(currentSavedOp);
        var i = 0;

        for (i = this._length; i < newLength; i += 1) {
          this.saved[i] = createTypedArray('float32', 16);
        }

        this._length = newLength;
      };

      CVContextData.prototype.reset = function () {
        this.cArrPos = 0;
        this.cTr.reset();
        this.cO = 1;
      };

      function ShapeTransformManager() {
        this.sequences = {};
        this.sequenceList = [];
        this.transform_key_count = 0;
      }

      ShapeTransformManager.prototype = {
        addTransformSequence: function addTransformSequence(transforms) {
          var i;
          var len = transforms.length;
          var key = '_';

          for (i = 0; i < len; i += 1) {
            key += transforms[i].transform.key + '_';
          }

          var sequence = this.sequences[key];

          if (!sequence) {
            sequence = {
              transforms: [].concat(transforms),
              finalTransform: new Matrix(),
              _mdf: false
            };
            this.sequences[key] = sequence;
            this.sequenceList.push(sequence);
          }

          return sequence;
        },
        processSequence: function processSequence(sequence, isFirstFrame) {
          var i = 0;
          var len = sequence.transforms.length;
          var _mdf = isFirstFrame;

          while (i < len && !isFirstFrame) {
            if (sequence.transforms[i].transform.mProps._mdf) {
              _mdf = true;
              break;
            }

            i += 1;
          }

          if (_mdf) {
            var props;
            sequence.finalTransform.reset();

            for (i = len - 1; i >= 0; i -= 1) {
              props = sequence.transforms[i].transform.mProps.v.props;
              sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
            }
          }

          sequence._mdf = _mdf;
        },
        processSequences: function processSequences(isFirstFrame) {
          var i;
          var len = this.sequenceList.length;

          for (i = 0; i < len; i += 1) {
            this.processSequence(this.sequenceList[i], isFirstFrame);
          }
        },
        getNewKey: function getNewKey() {
          this.transform_key_count += 1;
          return '_' + this.transform_key_count;
        }
      };

      function CVEffects() {}

      CVEffects.prototype.renderFrame = function () {};

      function CVMaskElement(data, element) {
        this.data = data;
        this.element = element;
        this.masksProperties = this.data.masksProperties || [];
        this.viewData = createSizedArray(this.masksProperties.length);
        var i;
        var len = this.masksProperties.length;
        var hasMasks = false;

        for (i = 0; i < len; i += 1) {
          if (this.masksProperties[i].mode !== 'n') {
            hasMasks = true;
          }

          this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
        }

        this.hasMasks = hasMasks;

        if (hasMasks) {
          this.element.addRenderableComponent(this);
        }
      }

      CVMaskElement.prototype.renderFrame = function () {
        if (!this.hasMasks) {
          return;
        }

        var transform = this.element.finalTransform.mat;
        var ctx = this.element.canvasContext;
        var i;
        var len = this.masksProperties.length;
        var pt;
        var pts;
        var data;
        ctx.beginPath();

        for (i = 0; i < len; i += 1) {
          if (this.masksProperties[i].mode !== 'n') {
            if (this.masksProperties[i].inv) {
              ctx.moveTo(0, 0);
              ctx.lineTo(this.element.globalData.compSize.w, 0);
              ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
              ctx.lineTo(0, this.element.globalData.compSize.h);
              ctx.lineTo(0, 0);
            }

            data = this.viewData[i].v;
            pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
            ctx.moveTo(pt[0], pt[1]);
            var j;
            var jLen = data._length;

            for (j = 1; j < jLen; j += 1) {
              pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
              ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
            }

            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
        }

        this.element.globalData.renderer.save(true);
        ctx.clip();
      };

      CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

      CVMaskElement.prototype.destroy = function () {
        this.element = null;
      };

      function CVBaseElement() {}

      CVBaseElement.prototype = {
        createElements: function createElements() {},
        initRendererElement: function initRendererElement() {},
        createContainerElements: function createContainerElements() {
          this.canvasContext = this.globalData.canvasContext;
          this.renderableEffectsManager = new CVEffects(this);
        },
        createContent: function createContent() {},
        setBlendMode: function setBlendMode() {
          var globalData = this.globalData;

          if (globalData.blendMode !== this.data.bm) {
            globalData.blendMode = this.data.bm;
            var blendModeValue = getBlendMode(this.data.bm);
            globalData.canvasContext.globalCompositeOperation = blendModeValue;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new CVMaskElement(this.data, this);
        },
        hideElement: function hideElement() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            this.hidden = true;
          }
        },
        showElement: function showElement() {
          if (this.isInRange && !this.isTransparent) {
            this.hidden = false;
            this._isFirstFrame = true;
            this.maskManager._isFirstFrame = true;
          }
        },
        renderFrame: function renderFrame() {
          if (this.hidden || this.data.hd) {
            return;
          }

          this.renderTransform();
          this.renderRenderable();
          this.setBlendMode();
          var forceRealStack = this.data.ty === 0;
          this.globalData.renderer.save(forceRealStack);
          this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
          this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
          this.renderInnerContent();
          this.globalData.renderer.restore(forceRealStack);

          if (this.maskManager.hasMasks) {
            this.globalData.renderer.restore(true);
          }

          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.canvasContext = null;
          this.data = null;
          this.globalData = null;
          this.maskManager.destroy();
        },
        mHelper: new Matrix()
      };
      CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
      CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

      function CVShapeData(element, data, styles, transformsManager) {
        this.styledShapes = [];
        this.tr = [0, 0, 0, 0, 0, 0];
        var ty = 4;

        if (data.ty === 'rc') {
          ty = 5;
        } else if (data.ty === 'el') {
          ty = 6;
        } else if (data.ty === 'sr') {
          ty = 7;
        }

        this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
        var i;
        var len = styles.length;
        var styledShape;

        for (i = 0; i < len; i += 1) {
          if (!styles[i].closed) {
            styledShape = {
              transforms: transformsManager.addTransformSequence(styles[i].transforms),
              trNodes: []
            };
            this.styledShapes.push(styledShape);
            styles[i].elements.push(styledShape);
          }
        }
      }

      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

      function CVShapeElement(data, globalData, comp) {
        this.shapes = [];
        this.shapesData = data.shapes;
        this.stylesList = [];
        this.itemsData = [];
        this.prevViewData = [];
        this.shapeModifiers = [];
        this.processedElements = [];
        this.transformsManager = new ShapeTransformManager();
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);
      CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;
      CVShapeElement.prototype.transformHelper = {
        opacity: 1,
        _opMdf: false
      };
      CVShapeElement.prototype.dashResetter = [];

      CVShapeElement.prototype.createContent = function () {
        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      };

      CVShapeElement.prototype.createStyleElement = function (data, transforms) {
        var styleElem = {
          data: data,
          type: data.ty,
          preTransforms: this.transformsManager.addTransformSequence(transforms),
          transforms: [],
          elements: [],
          closed: data.hd === true
        };
        var elementData = {};

        if (data.ty === 'fl' || data.ty === 'st') {
          elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);

          if (!elementData.c.k) {
            styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
          }
        } else if (data.ty === 'gf' || data.ty === 'gs') {
          elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
          elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
          elementData.h = PropertyFactory.getProp(this, data.h || {
            k: 0
          }, 0, 0.01, this);
          elementData.a = PropertyFactory.getProp(this, data.a || {
            k: 0
          }, 0, degToRads, this);
          elementData.g = new GradientProperty(this, data.g, this);
        }

        elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);

        if (data.ty === 'st' || data.ty === 'gs') {
          styleElem.lc = lineCapEnum[data.lc || 2];
          styleElem.lj = lineJoinEnum[data.lj || 2];

          if (data.lj == 1) {
            // eslint-disable-line eqeqeq
            styleElem.ml = data.ml;
          }

          elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);

          if (!elementData.w.k) {
            styleElem.wi = elementData.w.v;
          }

          if (data.d) {
            var d = new DashProperty(this, data.d, 'canvas', this);
            elementData.d = d;

            if (!elementData.d.k) {
              styleElem.da = elementData.d.dashArray;
              styleElem["do"] = elementData.d.dashoffset[0];
            }
          }
        } else {
          styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
        }

        this.stylesList.push(styleElem);
        elementData.style = styleElem;
        return elementData;
      };

      CVShapeElement.prototype.createGroupElement = function () {
        var elementData = {
          it: [],
          prevViewData: []
        };
        return elementData;
      };

      CVShapeElement.prototype.createTransformElement = function (data) {
        var elementData = {
          transform: {
            opacity: 1,
            _opMdf: false,
            key: this.transformsManager.getNewKey(),
            op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
            mProps: TransformPropertyFactory.getTransformProperty(this, data, this)
          }
        };
        return elementData;
      };

      CVShapeElement.prototype.createShapeElement = function (data) {
        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);
        this.shapes.push(elementData);
        this.addShapeToModifiers(elementData);
        return elementData;
      };

      CVShapeElement.prototype.reloadShapes = function () {
        this._isFirstFrame = true;
        var i;
        var len = this.itemsData.length;

        for (i = 0; i < len; i += 1) {
          this.prevViewData[i] = this.itemsData[i];
        }

        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
        len = this.dynamicProperties.length;

        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
        }

        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
      };

      CVShapeElement.prototype.addTransformToStyleList = function (transform) {
        var i;
        var len = this.stylesList.length;

        for (i = 0; i < len; i += 1) {
          if (!this.stylesList[i].closed) {
            this.stylesList[i].transforms.push(transform);
          }
        }
      };

      CVShapeElement.prototype.removeTransformFromStyleList = function () {
        var i;
        var len = this.stylesList.length;

        for (i = 0; i < len; i += 1) {
          if (!this.stylesList[i].closed) {
            this.stylesList[i].transforms.pop();
          }
        }
      };

      CVShapeElement.prototype.closeStyles = function (styles) {
        var i;
        var len = styles.length;

        for (i = 0; i < len; i += 1) {
          styles[i].closed = true;
        }
      };

      CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
        var i;
        var len = arr.length - 1;
        var j;
        var jLen;
        var ownStyles = [];
        var ownModifiers = [];
        var processedPos;
        var modifier;
        var currentTransform;
        var ownTransforms = [].concat(transforms);

        for (i = len; i >= 0; i -= 1) {
          processedPos = this.searchProcessedElement(arr[i]);

          if (!processedPos) {
            arr[i]._shouldRender = shouldRender;
          } else {
            itemsData[i] = prevViewData[processedPos - 1];
          }

          if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
            if (!processedPos) {
              itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
            } else {
              itemsData[i].style.closed = false;
            }

            ownStyles.push(itemsData[i].style);
          } else if (arr[i].ty === 'gr') {
            if (!processedPos) {
              itemsData[i] = this.createGroupElement(arr[i]);
            } else {
              jLen = itemsData[i].it.length;

              for (j = 0; j < jLen; j += 1) {
                itemsData[i].prevViewData[j] = itemsData[i].it[j];
              }
            }

            this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
          } else if (arr[i].ty === 'tr') {
            if (!processedPos) {
              currentTransform = this.createTransformElement(arr[i]);
              itemsData[i] = currentTransform;
            }

            ownTransforms.push(itemsData[i]);
            this.addTransformToStyleList(itemsData[i]);
          } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
            if (!processedPos) {
              itemsData[i] = this.createShapeElement(arr[i]);
            }
          } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              modifier.init(this, arr[i]);
              itemsData[i] = modifier;
              this.shapeModifiers.push(modifier);
            } else {
              modifier = itemsData[i];
              modifier.closed = false;
            }

            ownModifiers.push(modifier);
          } else if (arr[i].ty === 'rp') {
            if (!processedPos) {
              modifier = ShapeModifiers.getModifier(arr[i].ty);
              itemsData[i] = modifier;
              modifier.init(this, arr, i, itemsData);
              this.shapeModifiers.push(modifier);
              shouldRender = false;
            } else {
              modifier = itemsData[i];
              modifier.closed = true;
            }

            ownModifiers.push(modifier);
          }

          this.addProcessedElement(arr[i], i + 1);
        }

        this.removeTransformFromStyleList();
        this.closeStyles(ownStyles);
        len = ownModifiers.length;

        for (i = 0; i < len; i += 1) {
          ownModifiers[i].closed = true;
        }
      };

      CVShapeElement.prototype.renderInnerContent = function () {
        this.transformHelper.opacity = 1;
        this.transformHelper._opMdf = false;
        this.renderModifiers();
        this.transformsManager.processSequences(this._isFirstFrame);
        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
      };

      CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
          groupTransform.opacity = parentTransform.opacity;
          groupTransform.opacity *= groupTransform.op.v;
          groupTransform._opMdf = true;
        }
      };

      CVShapeElement.prototype.drawLayer = function () {
        var i;
        var len = this.stylesList.length;
        var j;
        var jLen;
        var k;
        var kLen;
        var elems;
        var nodes;
        var renderer = this.globalData.renderer;
        var ctx = this.globalData.canvasContext;
        var type;
        var currentStyle;

        for (i = 0; i < len; i += 1) {
          currentStyle = this.stylesList[i];
          type = currentStyle.type; // Skipping style when
          // Stroke width equals 0
          // style should not be rendered (extra unused repeaters)
          // current opacity equals 0
          // global opacity equals 0

          if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
            renderer.save();
            elems = currentStyle.elements;

            if (type === 'st' || type === 'gs') {
              ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
              ctx.lineWidth = currentStyle.wi;
              ctx.lineCap = currentStyle.lc;
              ctx.lineJoin = currentStyle.lj;
              ctx.miterLimit = currentStyle.ml || 0;
            } else {
              ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
            }

            renderer.ctxOpacity(currentStyle.coOp);

            if (type !== 'st' && type !== 'gs') {
              ctx.beginPath();
            }

            renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
            jLen = elems.length;

            for (j = 0; j < jLen; j += 1) {
              if (type === 'st' || type === 'gs') {
                ctx.beginPath();

                if (currentStyle.da) {
                  ctx.setLineDash(currentStyle.da);
                  ctx.lineDashOffset = currentStyle["do"];
                }
              }

              nodes = elems[j].trNodes;
              kLen = nodes.length;

              for (k = 0; k < kLen; k += 1) {
                if (nodes[k].t === 'm') {
                  ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
                } else if (nodes[k].t === 'c') {
                  ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
                } else {
                  ctx.closePath();
                }
              }

              if (type === 'st' || type === 'gs') {
                ctx.stroke();

                if (currentStyle.da) {
                  ctx.setLineDash(this.dashResetter);
                }
              }
            }

            if (type !== 'st' && type !== 'gs') {
              ctx.fill(currentStyle.r);
            }

            renderer.restore();
          }
        }
      };

      CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
        var i;
        var len = items.length - 1;
        var groupTransform;
        groupTransform = parentTransform;

        for (i = len; i >= 0; i -= 1) {
          if (items[i].ty === 'tr') {
            groupTransform = data[i].transform;
            this.renderShapeTransform(parentTransform, groupTransform);
          } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
            this.renderPath(items[i], data[i]);
          } else if (items[i].ty === 'fl') {
            this.renderFill(items[i], data[i], groupTransform);
          } else if (items[i].ty === 'st') {
            this.renderStroke(items[i], data[i], groupTransform);
          } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
            this.renderGradientFill(items[i], data[i], groupTransform);
          } else if (items[i].ty === 'gr') {
            this.renderShape(groupTransform, items[i].it, data[i].it);
          } else if (items[i].ty === 'tm') ;
        }

        if (isMain) {
          this.drawLayer();
        }
      };

      CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
          var shapeNodes = styledShape.trNodes;
          var paths = shape.paths;
          var i;
          var len;
          var j;
          var jLen = paths._length;
          shapeNodes.length = 0;
          var groupTransformMat = styledShape.transforms.finalTransform;

          for (j = 0; j < jLen; j += 1) {
            var pathNodes = paths.shapes[j];

            if (pathNodes && pathNodes.v) {
              len = pathNodes._length;

              for (i = 1; i < len; i += 1) {
                if (i === 1) {
                  shapeNodes.push({
                    t: 'm',
                    p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                  });
                }

                shapeNodes.push({
                  t: 'c',
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])
                });
              }

              if (len === 1) {
                shapeNodes.push({
                  t: 'm',
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)
                });
              }

              if (pathNodes.c && len) {
                shapeNodes.push({
                  t: 'c',
                  pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])
                });
                shapeNodes.push({
                  t: 'z'
                });
              }
            }
          }

          styledShape.trNodes = shapeNodes;
        }
      };

      CVShapeElement.prototype.renderPath = function (pathData, itemData) {
        if (pathData.hd !== true && pathData._shouldRender) {
          var i;
          var len = itemData.styledShapes.length;

          for (i = 0; i < len; i += 1) {
            this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
          }
        }
      };

      CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
        var styleElem = itemData.style;

        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
        }

        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }
      };

      CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var grd;

        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {
          var ctx = this.globalData.canvasContext;
          var pt1 = itemData.s.v;
          var pt2 = itemData.e.v;

          if (styleData.t === 1) {
            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
          } else {
            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
            var percent = itemData.h.v;

            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }

            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
          }

          var i;
          var len = styleData.g.p;
          var cValues = itemData.g.c;
          var opacity = 1;

          for (i = 0; i < len; i += 1) {
            if (itemData.g._hasOpacity && itemData.g._collapsable) {
              opacity = itemData.g.o[i * 2 + 1];
            }

            grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
          }

          styleElem.grd = grd;
        }

        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      };

      CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
        var styleElem = itemData.style;
        var d = itemData.d;

        if (d && (d._mdf || this._isFirstFrame)) {
          styleElem.da = d.dashArray;
          styleElem["do"] = d.dashoffset[0];
        }

        if (itemData.c._mdf || this._isFirstFrame) {
          styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
        }

        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
          styleElem.coOp = itemData.o.v * groupTransform.opacity;
        }

        if (itemData.w._mdf || this._isFirstFrame) {
          styleElem.wi = itemData.w.v;
        }
      };

      CVShapeElement.prototype.destroy = function () {
        this.shapesData = null;
        this.globalData = null;
        this.canvasContext = null;
        this.stylesList.length = 0;
        this.itemsData.length = 0;
      };

      function CVTextElement(data, globalData, comp) {
        this.textSpans = [];
        this.yOffset = 0;
        this.fillColorAnim = false;
        this.strokeColorAnim = false;
        this.strokeWidthAnim = false;
        this.stroke = false;
        this.fill = false;
        this.justifyOffset = 0;
        this.currentRender = null;
        this.renderType = 'canvas';
        this.values = {
          fill: 'rgba(0,0,0,0)',
          stroke: 'rgba(0,0,0,0)',
          sWidth: 0,
          fValue: ''
        };
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);
      CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

      CVTextElement.prototype.buildNewText = function () {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var hasFill = false;

        if (documentData.fc) {
          hasFill = true;
          this.values.fill = this.buildColor(documentData.fc);
        } else {
          this.values.fill = 'rgba(0,0,0,0)';
        }

        this.fill = hasFill;
        var hasStroke = false;

        if (documentData.sc) {
          hasStroke = true;
          this.values.stroke = this.buildColor(documentData.sc);
          this.values.sWidth = documentData.sw;
        }

        var fontData = this.globalData.fontManager.getFontByName(documentData.f);
        var i;
        var len;
        var letters = documentData.l;
        var matrixHelper = this.mHelper;
        this.stroke = hasStroke;
        this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
        len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;

        var charData;
        var shapeData;
        var k;
        var kLen;
        var shapes;
        var j;
        var jLen;
        var pathNodes;
        var commands;
        var pathArr;
        var singleShape = this.data.singleShape;
        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
        var xPos = 0;
        var yPos = 0;
        var firstLine = true;
        var cnt = 0;

        for (i = 0; i < len; i += 1) {
          charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          shapeData = charData && charData.data || {};
          matrixHelper.reset();

          if (singleShape && letters[i].n) {
            xPos = -trackingOffset;
            yPos += documentData.yOffset;
            yPos += firstLine ? 1 : 0;
            firstLine = false;
          }

          shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
          jLen = shapes.length;
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);

          if (singleShape) {
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
          }

          commands = createSizedArray(jLen - 1);
          var commandsCounter = 0;

          for (j = 0; j < jLen; j += 1) {
            if (shapes[j].ty === 'sh') {
              kLen = shapes[j].ks.k.i.length;
              pathNodes = shapes[j].ks.k;
              pathArr = [];

              for (k = 1; k < kLen; k += 1) {
                if (k === 1) {
                  pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
                }

                pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
              }

              pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
              commands[commandsCounter] = pathArr;
              commandsCounter += 1;
            }
          }

          if (singleShape) {
            xPos += letters[i].l;
            xPos += trackingOffset;
          }

          if (this.textSpans[cnt]) {
            this.textSpans[cnt].elem = commands;
          } else {
            this.textSpans[cnt] = {
              elem: commands
            };
          }

          cnt += 1;
        }
      };

      CVTextElement.prototype.renderInnerContent = function () {
        var ctx = this.canvasContext;
        ctx.font = this.values.fValue;
        ctx.lineCap = 'butt';
        ctx.lineJoin = 'miter';
        ctx.miterLimit = 4;

        if (!this.data.singleShape) {
          this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        }

        var i;
        var len;
        var j;
        var jLen;
        var k;
        var kLen;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var lastFill = null;
        var lastStroke = null;
        var lastStrokeW = null;
        var commands;
        var pathArr;

        for (i = 0; i < len; i += 1) {
          if (!letters[i].n) {
            renderedLetter = renderedLetters[i];

            if (renderedLetter) {
              this.globalData.renderer.save();
              this.globalData.renderer.ctxTransform(renderedLetter.p);
              this.globalData.renderer.ctxOpacity(renderedLetter.o);
            }

            if (this.fill) {
              if (renderedLetter && renderedLetter.fc) {
                if (lastFill !== renderedLetter.fc) {
                  lastFill = renderedLetter.fc;
                  ctx.fillStyle = renderedLetter.fc;
                }
              } else if (lastFill !== this.values.fill) {
                lastFill = this.values.fill;
                ctx.fillStyle = this.values.fill;
              }

              commands = this.textSpans[i].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();

              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);

                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }

              this.globalData.canvasContext.closePath();
              this.globalData.canvasContext.fill(); /// ctx.fillText(this.textSpans[i].val,0,0);
            }

            if (this.stroke) {
              if (renderedLetter && renderedLetter.sw) {
                if (lastStrokeW !== renderedLetter.sw) {
                  lastStrokeW = renderedLetter.sw;
                  ctx.lineWidth = renderedLetter.sw;
                }
              } else if (lastStrokeW !== this.values.sWidth) {
                lastStrokeW = this.values.sWidth;
                ctx.lineWidth = this.values.sWidth;
              }

              if (renderedLetter && renderedLetter.sc) {
                if (lastStroke !== renderedLetter.sc) {
                  lastStroke = renderedLetter.sc;
                  ctx.strokeStyle = renderedLetter.sc;
                }
              } else if (lastStroke !== this.values.stroke) {
                lastStroke = this.values.stroke;
                ctx.strokeStyle = this.values.stroke;
              }

              commands = this.textSpans[i].elem;
              jLen = commands.length;
              this.globalData.canvasContext.beginPath();

              for (j = 0; j < jLen; j += 1) {
                pathArr = commands[j];
                kLen = pathArr.length;
                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);

                for (k = 2; k < kLen; k += 6) {
                  this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
                }
              }

              this.globalData.canvasContext.closePath();
              this.globalData.canvasContext.stroke(); /// ctx.strokeText(letters[i].val,0,0);
            }

            if (renderedLetter) {
              this.globalData.renderer.restore();
            }
          }
        }
      };

      function CVImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.img = globalData.imageLoader.getAsset(this.assetData);
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);
      CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

      CVImageElement.prototype.createContent = function () {
        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
          var canvas = createTag('canvas');
          canvas.width = this.assetData.w;
          canvas.height = this.assetData.h;
          var ctx = canvas.getContext('2d');
          var imgW = this.img.width;
          var imgH = this.img.height;
          var imgRel = imgW / imgH;
          var canvasRel = this.assetData.w / this.assetData.h;
          var widthCrop;
          var heightCrop;
          var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;

          if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {
            heightCrop = imgH;
            widthCrop = heightCrop * canvasRel;
          } else {
            widthCrop = imgW;
            heightCrop = widthCrop / canvasRel;
          }

          ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
          this.img = canvas;
        }
      };

      CVImageElement.prototype.renderInnerContent = function () {
        this.canvasContext.drawImage(this.img, 0, 0);
      };

      CVImageElement.prototype.destroy = function () {
        this.img = null;
      };

      function CVSolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);
      CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
      CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

      CVSolidElement.prototype.renderInnerContent = function () {
        var ctx = this.canvasContext;
        ctx.fillStyle = this.data.sc;
        ctx.fillRect(0, 0, this.data.sw, this.data.sh); //
      };

      function CanvasRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
          context: config && config.context || null,
          progressiveLoad: config && config.progressiveLoad || false,
          preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
          contentVisibility: config && config.contentVisibility || 'visible',
          className: config && config.className || '',
          id: config && config.id || ''
        };
        this.renderConfig.dpr = config && config.dpr || 1;

        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        }

        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = 'canvas';
      }

      extendPrototype([BaseRenderer], CanvasRendererBase);

      CanvasRendererBase.prototype.createShape = function (data) {
        return new CVShapeElement(data, this.globalData, this);
      };

      CanvasRendererBase.prototype.createText = function (data) {
        return new CVTextElement(data, this.globalData, this);
      };

      CanvasRendererBase.prototype.createImage = function (data) {
        return new CVImageElement(data, this.globalData, this);
      };

      CanvasRendererBase.prototype.createSolid = function (data) {
        return new CVSolidElement(data, this.globalData, this);
      };

      CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;

      CanvasRendererBase.prototype.ctxTransform = function (props) {
        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
          return;
        }

        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
          return;
        }

        this.transformMat.cloneFromProps(props);
        var cProps = this.contextData.cTr.props;
        this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]); // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);

        this.contextData.cTr.cloneFromProps(this.transformMat.props);
        var trProps = this.contextData.cTr.props;
        this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
      };

      CanvasRendererBase.prototype.ctxOpacity = function (op) {
        /* if(op === 1){
              return;
          } */
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
          this.globalData.currentGlobalAlpha = this.contextData.cO;
          return;
        }

        this.contextData.cO *= op < 0 ? 0 : op;

        if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
          this.canvasContext.globalAlpha = this.contextData.cO;
          this.globalData.currentGlobalAlpha = this.contextData.cO;
        }
      };

      CanvasRendererBase.prototype.reset = function () {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }

        this.contextData.reset();
      };

      CanvasRendererBase.prototype.save = function (actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.save();
          return;
        }

        if (actionFlag) {
          this.canvasContext.save();
        }

        var props = this.contextData.cTr.props;

        if (this.contextData._length <= this.contextData.cArrPos) {
          this.contextData.duplicate();
        }

        var i;
        var arr = this.contextData.saved[this.contextData.cArrPos];

        for (i = 0; i < 16; i += 1) {
          arr[i] = props[i];
        }

        this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
        this.contextData.cArrPos += 1;
      };

      CanvasRendererBase.prototype.restore = function (actionFlag) {
        if (!this.renderConfig.clearCanvas) {
          this.canvasContext.restore();
          return;
        }

        if (actionFlag) {
          this.canvasContext.restore();
          this.globalData.blendMode = 'source-over';
        }

        this.contextData.cArrPos -= 1;
        var popped = this.contextData.saved[this.contextData.cArrPos];
        var i;
        var arr = this.contextData.cTr.props;

        for (i = 0; i < 16; i += 1) {
          arr[i] = popped[i];
        }

        this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
        popped = this.contextData.savedOp[this.contextData.cArrPos];
        this.contextData.cO = popped;

        if (this.globalData.currentGlobalAlpha !== popped) {
          this.canvasContext.globalAlpha = popped;
          this.globalData.currentGlobalAlpha = popped;
        }
      };

      CanvasRendererBase.prototype.configAnimation = function (animData) {
        if (this.animationItem.wrapper) {
          this.animationItem.container = createTag('canvas');
          var containerStyle = this.animationItem.container.style;
          containerStyle.width = '100%';
          containerStyle.height = '100%';
          var origin = '0px 0px 0px';
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          containerStyle['-webkit-transform'] = origin;
          containerStyle.contentVisibility = this.renderConfig.contentVisibility;
          this.animationItem.wrapper.appendChild(this.animationItem.container);
          this.canvasContext = this.animationItem.container.getContext('2d');

          if (this.renderConfig.className) {
            this.animationItem.container.setAttribute('class', this.renderConfig.className);
          }

          if (this.renderConfig.id) {
            this.animationItem.container.setAttribute('id', this.renderConfig.id);
          }
        } else {
          this.canvasContext = this.renderConfig.context;
        }

        this.data = animData;
        this.layers = animData.layers;
        this.transformCanvas = {
          w: animData.w,
          h: animData.h,
          sx: 0,
          sy: 0,
          tx: 0,
          ty: 0
        };
        this.setupGlobalData(animData, document.body);
        this.globalData.canvasContext = this.canvasContext;
        this.globalData.renderer = this;
        this.globalData.isDashed = false;
        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
        this.globalData.transformCanvas = this.transformCanvas;
        this.elements = createSizedArray(animData.layers.length);
        this.updateContainerSize();
      };

      CanvasRendererBase.prototype.updateContainerSize = function () {
        this.reset();
        var elementWidth;
        var elementHeight;

        if (this.animationItem.wrapper && this.animationItem.container) {
          elementWidth = this.animationItem.wrapper.offsetWidth;
          elementHeight = this.animationItem.wrapper.offsetHeight;
          this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
          this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
        } else {
          elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
          elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
        }

        var elementRel;
        var animationRel;

        if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
          var par = this.renderConfig.preserveAspectRatio.split(' ');
          var fillType = par[1] || 'meet';
          var pos = par[0] || 'xMidYMid';
          var xPos = pos.substr(0, 4);
          var yPos = pos.substr(4);
          elementRel = elementWidth / elementHeight;
          animationRel = this.transformCanvas.w / this.transformCanvas.h;

          if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {
            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
            this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          } else {
            this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          }

          if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;
          } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {
            this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.tx = 0;
          }

          if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;
          } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {
            this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;
          } else {
            this.transformCanvas.ty = 0;
          }
        } else if (this.renderConfig.preserveAspectRatio === 'none') {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        } else {
          this.transformCanvas.sx = this.renderConfig.dpr;
          this.transformCanvas.sy = this.renderConfig.dpr;
          this.transformCanvas.tx = 0;
          this.transformCanvas.ty = 0;
        }

        this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
        /* var i, len = this.elements.length;
          for(i=0;i<len;i+=1){
              if(this.elements[i] && this.elements[i].data.ty === 0){
                  this.elements[i].resize(this.globalData.transformCanvas);
              }
          } */

        this.ctxTransform(this.transformCanvas.props);
        this.canvasContext.beginPath();
        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        this.canvasContext.closePath();
        this.canvasContext.clip();
        this.renderFrame(this.renderedFrame, true);
      };

      CanvasRendererBase.prototype.destroy = function () {
        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = '';
        }

        var i;
        var len = this.layers ? this.layers.length : 0;

        for (i = len - 1; i >= 0; i -= 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }

        this.elements.length = 0;
        this.globalData.canvasContext = null;
        this.animationItem.container = null;
        this.destroyed = true;
      };

      CanvasRendererBase.prototype.renderFrame = function (num, forceRender) {
        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {
          return;
        }

        this.renderedFrame = num;
        this.globalData.frameNum = num - this.animationItem._isFirstFrame;
        this.globalData.frameId += 1;
        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
        this.globalData.projectInterface.currentFrame = num; // console.log('--------');
        // console.log('NEW: ',num);

        var i;
        var len = this.layers.length;

        if (!this.completeLayers) {
          this.checkLayers(num);
        }

        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].prepareFrame(num - this.layers[i].st);
          }
        }

        if (this.globalData._mdf) {
          if (this.renderConfig.clearCanvas === true) {
            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
          } else {
            this.save();
          }

          for (i = len - 1; i >= 0; i -= 1) {
            if (this.completeLayers || this.elements[i]) {
              this.elements[i].renderFrame();
            }
          }

          if (this.renderConfig.clearCanvas !== true) {
            this.restore();
          }
        }
      };

      CanvasRendererBase.prototype.buildItem = function (pos) {
        var elements = this.elements;

        if (elements[pos] || this.layers[pos].ty === 99) {
          return;
        }

        var element = this.createItem(this.layers[pos], this, this.globalData);
        elements[pos] = element;
        element.initExpressions();
        /* if(this.layers[pos].ty === 0){
              element.resize(this.globalData.transformCanvas);
          } */
      };

      CanvasRendererBase.prototype.checkPendingElements = function () {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };

      CanvasRendererBase.prototype.hide = function () {
        this.animationItem.container.style.display = 'none';
      };

      CanvasRendererBase.prototype.show = function () {
        this.animationItem.container.style.display = 'block';
      };

      function CVCompElement(data, globalData, comp) {
        this.completeLayers = false;
        this.layers = data.layers;
        this.pendingElements = [];
        this.elements = createSizedArray(this.layers.length);
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
          _placeholder: true
        };
      }

      extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement);

      CVCompElement.prototype.renderInnerContent = function () {
        var ctx = this.canvasContext;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(this.data.w, 0);
        ctx.lineTo(this.data.w, this.data.h);
        ctx.lineTo(0, this.data.h);
        ctx.lineTo(0, 0);
        ctx.clip();
        var i;
        var len = this.layers.length;

        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      };

      CVCompElement.prototype.destroy = function () {
        var i;
        var len = this.layers.length;

        for (i = len - 1; i >= 0; i -= 1) {
          if (this.elements[i]) {
            this.elements[i].destroy();
          }
        }

        this.layers = null;
        this.elements = null;
      };

      CVCompElement.prototype.createComp = function (data) {
        return new CVCompElement(data, this.globalData, this);
      };

      function CanvasRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.renderConfig = {
          clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,
          context: config && config.context || null,
          progressiveLoad: config && config.progressiveLoad || false,
          preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
          contentVisibility: config && config.contentVisibility || 'visible',
          className: config && config.className || '',
          id: config && config.id || ''
        };
        this.renderConfig.dpr = config && config.dpr || 1;

        if (this.animationItem.wrapper) {
          this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;
        }

        this.renderedFrame = -1;
        this.globalData = {
          frameNum: -1,
          _mdf: false,
          renderConfig: this.renderConfig,
          currentGlobalAlpha: -1
        };
        this.contextData = new CVContextData();
        this.elements = [];
        this.pendingElements = [];
        this.transformMat = new Matrix();
        this.completeLayers = false;
        this.rendererType = 'canvas';
      }

      extendPrototype([CanvasRendererBase], CanvasRenderer);

      CanvasRenderer.prototype.createComp = function (data) {
        return new CVCompElement(data, this.globalData, this);
      };

      function HBaseElement() {}

      HBaseElement.prototype = {
        checkBlendMode: function checkBlendMode() {},
        initRendererElement: function initRendererElement() {
          this.baseElement = createTag(this.data.tg || 'div');

          if (this.data.hasMask) {
            this.svgElement = createNS('svg');
            this.layerElement = createNS('g');
            this.maskedElement = this.layerElement;
            this.svgElement.appendChild(this.layerElement);
            this.baseElement.appendChild(this.svgElement);
          } else {
            this.layerElement = this.baseElement;
          }

          styleDiv(this.baseElement);
        },
        createContainerElements: function createContainerElements() {
          this.renderableEffectsManager = new CVEffects(this);
          this.transformedElement = this.baseElement;
          this.maskedElement = this.layerElement;

          if (this.data.ln) {
            this.layerElement.setAttribute('id', this.data.ln);
          }

          if (this.data.cl) {
            this.layerElement.setAttribute('class', this.data.cl);
          }

          if (this.data.bm !== 0) {
            this.setBlendMode();
          }
        },
        renderElement: function renderElement() {
          var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};

          if (this.finalTransform._matMdf) {
            var matrixValue = this.finalTransform.mat.toCSS();
            transformedElementStyle.transform = matrixValue;
            transformedElementStyle.webkitTransform = matrixValue;
          }

          if (this.finalTransform._opMdf) {
            transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
          }
        },
        renderFrame: function renderFrame() {
          // If it is exported as hidden (data.hd === true) no need to render
          // If it is not visible no need to render
          if (this.data.hd || this.hidden) {
            return;
          }

          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();

          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        destroy: function destroy() {
          this.layerElement = null;
          this.transformedElement = null;

          if (this.matteElement) {
            this.matteElement = null;
          }

          if (this.maskManager) {
            this.maskManager.destroy();
            this.maskManager = null;
          }
        },
        createRenderableComponents: function createRenderableComponents() {
          this.maskManager = new MaskElement(this.data, this, this.globalData);
        },
        addEffects: function addEffects() {},
        setMatte: function setMatte() {}
      };
      HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
      HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
      HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;

      function HSolidElement(data, globalData, comp) {
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

      HSolidElement.prototype.createContent = function () {
        var rect;

        if (this.data.hasMask) {
          rect = createNS('rect');
          rect.setAttribute('width', this.data.sw);
          rect.setAttribute('height', this.data.sh);
          rect.setAttribute('fill', this.data.sc);
          this.svgElement.setAttribute('width', this.data.sw);
          this.svgElement.setAttribute('height', this.data.sh);
        } else {
          rect = createTag('div');
          rect.style.width = this.data.sw + 'px';
          rect.style.height = this.data.sh + 'px';
          rect.style.backgroundColor = this.data.sc;
        }

        this.layerElement.appendChild(rect);
      };

      function HShapeElement(data, globalData, comp) {
        // List of drawable elements
        this.shapes = []; // Full shape data

        this.shapesData = data.shapes; // List of styles that will be applied to shapes

        this.stylesList = []; // List of modifiers that will be applied to shapes

        this.shapeModifiers = []; // List of items in shape tree

        this.itemsData = []; // List of items in previous shape tree

        this.processedElements = []; // List of animated components

        this.animatedContents = [];
        this.shapesContainer = createNS('g');
        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
        // List of elements that have been created

        this.prevViewData = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
      }

      extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
      HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

      HShapeElement.prototype.createContent = function () {
        var cont;
        this.baseElement.style.fontSize = 0;

        if (this.data.hasMask) {
          this.layerElement.appendChild(this.shapesContainer);
          cont = this.svgElement;
        } else {
          cont = createNS('svg');
          var size = this.comp.data ? this.comp.data : this.globalData.compSize;
          cont.setAttribute('width', size.w);
          cont.setAttribute('height', size.h);
          cont.appendChild(this.shapesContainer);
          this.layerElement.appendChild(cont);
        }

        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
        this.filterUniqueShapes();
        this.shapeCont = cont;
      };

      HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
        var i;
        var len = transformers.length;

        for (i = 0; i < len; i += 1) {
          point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
        }

        return point;
      };

      HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
        var shape = item.sh.v;
        var transformers = item.transformers;
        var i;
        var len = shape._length;
        var vPoint;
        var oPoint;
        var nextIPoint;
        var nextVPoint;

        if (len <= 1) {
          return;
        }

        for (i = 0; i < len - 1; i += 1) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }

        if (shape.c) {
          vPoint = this.getTransformedPoint(transformers, shape.v[i]);
          oPoint = this.getTransformedPoint(transformers, shape.o[i]);
          nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
          nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
          this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
        }
      };

      HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
        var bounds = this.shapeBoundingBox;
        boundingBox.x = bmMin(bounds.left, boundingBox.x);
        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
        boundingBox.y = bmMin(bounds.top, boundingBox.y);
        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
      };

      HShapeElement.prototype.shapeBoundingBox = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      HShapeElement.prototype.tempBoundingBox = {
        x: 0,
        xMax: 0,
        y: 0,
        yMax: 0,
        width: 0,
        height: 0
      };

      HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
        var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

        for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {
          // eslint-disable-line no-plusplus
          b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
          a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
          c = 3 * p1[i] - 3 * p0[i];
          b |= 0; // eslint-disable-line no-bitwise

          a |= 0; // eslint-disable-line no-bitwise

          c |= 0; // eslint-disable-line no-bitwise

          if (a === 0 && b === 0) ; else if (a === 0) {
            t = -c / b;

            if (t > 0 && t < 1) {
              bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
            }
          } else {
            b2ac = b * b - 4 * c * a;

            if (b2ac >= 0) {
              t1 = (-b + bmSqrt(b2ac)) / (2 * a);
              if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
              t2 = (-b - bmSqrt(b2ac)) / (2 * a);
              if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
            }
          }
        }

        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
      };

      HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];
      };

      HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
        var i;
        var len = itemsData.length;

        for (i = 0; i < len; i += 1) {
          if (itemsData[i] && itemsData[i].sh) {
            this.calculateShapeBoundingBox(itemsData[i], boundingBox);
          } else if (itemsData[i] && itemsData[i].it) {
            this.calculateBoundingBox(itemsData[i].it, boundingBox);
          }
        }
      };

      HShapeElement.prototype.currentBoxContains = function (box) {
        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
      };

      HShapeElement.prototype.renderInnerContent = function () {
        this._renderShapeFrame();

        if (!this.hidden && (this._isFirstFrame || this._mdf)) {
          var tempBoundingBox = this.tempBoundingBox;
          var max = 999999;
          tempBoundingBox.x = max;
          tempBoundingBox.xMax = -max;
          tempBoundingBox.y = max;
          tempBoundingBox.yMax = -max;
          this.calculateBoundingBox(this.itemsData, tempBoundingBox);
          tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
          tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();

          if (this.currentBoxContains(tempBoundingBox)) {
            return;
          }

          var changed = false;

          if (this.currentBBox.w !== tempBoundingBox.width) {
            this.currentBBox.w = tempBoundingBox.width;
            this.shapeCont.setAttribute('width', tempBoundingBox.width);
            changed = true;
          }

          if (this.currentBBox.h !== tempBoundingBox.height) {
            this.currentBBox.h = tempBoundingBox.height;
            this.shapeCont.setAttribute('height', tempBoundingBox.height);
            changed = true;
          }

          if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
            this.currentBBox.w = tempBoundingBox.width;
            this.currentBBox.h = tempBoundingBox.height;
            this.currentBBox.x = tempBoundingBox.x;
            this.currentBBox.y = tempBoundingBox.y;
            this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
            var shapeStyle = this.shapeCont.style;
            var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
            shapeStyle.transform = shapeTransform;
            shapeStyle.webkitTransform = shapeTransform;
          }
        }
      };

      function HTextElement(data, globalData, comp) {
        this.textSpans = [];
        this.textPaths = [];
        this.currentBBox = {
          x: 999999,
          y: -999999,
          h: 0,
          w: 0
        };
        this.renderType = 'svg';
        this.isMasked = false;
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

      HTextElement.prototype.createContent = function () {
        this.isMasked = this.checkMasks();

        if (this.isMasked) {
          this.renderType = 'svg';
          this.compW = this.comp.data.w;
          this.compH = this.comp.data.h;
          this.svgElement.setAttribute('width', this.compW);
          this.svgElement.setAttribute('height', this.compH);
          var g = createNS('g');
          this.maskedElement.appendChild(g);
          this.innerElem = g;
        } else {
          this.renderType = 'html';
          this.innerElem = this.layerElement;
        }

        this.checkParenting();
      };

      HTextElement.prototype.buildNewText = function () {
        var documentData = this.textProperty.currentData;
        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
        var innerElemStyle = this.innerElem.style;
        var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
        innerElemStyle.fill = textColor;
        innerElemStyle.color = textColor;

        if (documentData.sc) {
          innerElemStyle.stroke = this.buildColor(documentData.sc);
          innerElemStyle.strokeWidth = documentData.sw + 'px';
        }

        var fontData = this.globalData.fontManager.getFontByName(documentData.f);

        if (!this.globalData.fontManager.chars) {
          innerElemStyle.fontSize = documentData.finalSize + 'px';
          innerElemStyle.lineHeight = documentData.finalSize + 'px';

          if (fontData.fClass) {
            this.innerElem.className = fontData.fClass;
          } else {
            innerElemStyle.fontFamily = fontData.fFamily;
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            innerElemStyle.fontStyle = fStyle;
            innerElemStyle.fontWeight = fWeight;
          }
        }

        var i;
        var len;
        var letters = documentData.l;
        len = letters.length;
        var tSpan;
        var tParent;
        var tCont;
        var matrixHelper = this.mHelper;
        var shapes;
        var shapeStr = '';
        var cnt = 0;

        for (i = 0; i < len; i += 1) {
          if (this.globalData.fontManager.chars) {
            if (!this.textPaths[cnt]) {
              tSpan = createNS('path');
              tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
              tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
              tSpan.setAttribute('stroke-miterlimit', '4');
            } else {
              tSpan = this.textPaths[cnt];
            }

            if (!this.isMasked) {
              if (this.textSpans[cnt]) {
                tParent = this.textSpans[cnt];
                tCont = tParent.children[0];
              } else {
                tParent = createTag('div');
                tParent.style.lineHeight = 0;
                tCont = createNS('svg');
                tCont.appendChild(tSpan);
                styleDiv(tParent);
              }
            }
          } else if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tSpan = this.textPaths[cnt];
            } else {
              tParent = createTag('span');
              styleDiv(tParent);
              tSpan = createTag('span');
              styleDiv(tSpan);
              tParent.appendChild(tSpan);
            }
          } else {
            tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
          } // tSpan.setAttribute('visibility', 'hidden');


          if (this.globalData.fontManager.chars) {
            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            var shapeData;

            if (charData) {
              shapeData = charData.data;
            } else {
              shapeData = null;
            }

            matrixHelper.reset();

            if (shapeData && shapeData.shapes && shapeData.shapes.length) {
              shapes = shapeData.shapes[0].it;
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              shapeStr = this.createPathShape(matrixHelper, shapes);
              tSpan.setAttribute('d', shapeStr);
            }

            if (!this.isMasked) {
              this.innerElem.appendChild(tParent);

              if (shapeData && shapeData.shapes) {
                // document.body.appendChild is needed to get exact measure of shape
                document.body.appendChild(tCont);
                var boundingBox = tCont.getBBox();
                tCont.setAttribute('width', boundingBox.width + 2);
                tCont.setAttribute('height', boundingBox.height + 2);
                tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
                var tContStyle = tCont.style;
                var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
                tContStyle.transform = tContTranslation;
                tContStyle.webkitTransform = tContTranslation;
                letters[i].yOffset = boundingBox.y - 1;
              } else {
                tCont.setAttribute('width', 1);
                tCont.setAttribute('height', 1);
              }

              tParent.appendChild(tCont);
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } else {
            tSpan.textContent = letters[i].val;
            tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');

            if (!this.isMasked) {
              this.innerElem.appendChild(tParent); //

              var tStyle = tSpan.style;
              var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
              tStyle.transform = tSpanTranslation;
              tStyle.webkitTransform = tSpanTranslation;
            } else {
              this.innerElem.appendChild(tSpan);
            }
          } //


          if (!this.isMasked) {
            this.textSpans[cnt] = tParent;
          } else {
            this.textSpans[cnt] = tSpan;
          }

          this.textSpans[cnt].style.display = 'block';
          this.textPaths[cnt] = tSpan;
          cnt += 1;
        }

        while (cnt < this.textSpans.length) {
          this.textSpans[cnt].style.display = 'none';
          cnt += 1;
        }
      };

      HTextElement.prototype.renderInnerContent = function () {
        var svgStyle;

        if (this.data.singleShape) {
          if (!this._isFirstFrame && !this.lettersChangedFlag) {
            return;
          }

          if (this.isMasked && this.finalTransform._matMdf) {
            // Todo Benchmark if using this is better than getBBox
            this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
            svgStyle = this.svgElement.style;
            var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
            svgStyle.transform = translation;
            svgStyle.webkitTransform = translation;
          }
        }

        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);

        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
          return;
        }

        var i;
        var len;
        var count = 0;
        var renderedLetters = this.textAnimator.renderedLetters;
        var letters = this.textProperty.currentData.l;
        len = letters.length;
        var renderedLetter;
        var textSpan;
        var textPath;

        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            count += 1;
          } else {
            textSpan = this.textSpans[i];
            textPath = this.textPaths[i];
            renderedLetter = renderedLetters[count];
            count += 1;

            if (renderedLetter._mdf.m) {
              if (!this.isMasked) {
                textSpan.style.webkitTransform = renderedLetter.m;
                textSpan.style.transform = renderedLetter.m;
              } else {
                textSpan.setAttribute('transform', renderedLetter.m);
              }
            } /// /textSpan.setAttribute('opacity',renderedLetter.o);


            textSpan.style.opacity = renderedLetter.o;

            if (renderedLetter.sw && renderedLetter._mdf.sw) {
              textPath.setAttribute('stroke-width', renderedLetter.sw);
            }

            if (renderedLetter.sc && renderedLetter._mdf.sc) {
              textPath.setAttribute('stroke', renderedLetter.sc);
            }

            if (renderedLetter.fc && renderedLetter._mdf.fc) {
              textPath.setAttribute('fill', renderedLetter.fc);
              textPath.style.color = renderedLetter.fc;
            }
          }
        }

        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var boundingBox = this.innerElem.getBBox();

          if (this.currentBBox.w !== boundingBox.width) {
            this.currentBBox.w = boundingBox.width;
            this.svgElement.setAttribute('width', boundingBox.width);
          }

          if (this.currentBBox.h !== boundingBox.height) {
            this.currentBBox.h = boundingBox.height;
            this.svgElement.setAttribute('height', boundingBox.height);
          }

          var margin = 1;

          if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {
            this.currentBBox.w = boundingBox.width + margin * 2;
            this.currentBBox.h = boundingBox.height + margin * 2;
            this.currentBBox.x = boundingBox.x - margin;
            this.currentBBox.y = boundingBox.y - margin;
            this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
            svgStyle = this.svgElement.style;
            var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
            svgStyle.transform = svgTransform;
            svgStyle.webkitTransform = svgTransform;
          }
        }
      };

      function HCameraElement(data, globalData, comp) {
        this.initFrame();
        this.initBaseData(data, globalData, comp);
        this.initHierarchy();
        var getProp = PropertyFactory.getProp;
        this.pe = getProp(this, data.pe, 0, 0, this);

        if (data.ks.p.s) {
          this.px = getProp(this, data.ks.p.x, 1, 0, this);
          this.py = getProp(this, data.ks.p.y, 1, 0, this);
          this.pz = getProp(this, data.ks.p.z, 1, 0, this);
        } else {
          this.p = getProp(this, data.ks.p, 1, 0, this);
        }

        if (data.ks.a) {
          this.a = getProp(this, data.ks.a, 1, 0, this);
        }

        if (data.ks.or.k.length && data.ks.or.k[0].to) {
          var i;
          var len = data.ks.or.k.length;

          for (i = 0; i < len; i += 1) {
            data.ks.or.k[i].to = null;
            data.ks.or.k[i].ti = null;
          }
        }

        this.or = getProp(this, data.ks.or, 1, degToRads, this);
        this.or.sh = true;
        this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
        this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
        this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
        this.mat = new Matrix();
        this._prevMat = new Matrix();
        this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.

        this.finalTransform = {
          mProp: this
        };
      }

      extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

      HCameraElement.prototype.setup = function () {
        var i;
        var len = this.comp.threeDElements.length;
        var comp;
        var perspectiveStyle;
        var containerStyle;

        for (i = 0; i < len; i += 1) {
          // [perspectiveElem,container]
          comp = this.comp.threeDElements[i];

          if (comp.type === '3d') {
            perspectiveStyle = comp.perspectiveElem.style;
            containerStyle = comp.container.style;
            var perspective = this.pe.v + 'px';
            var origin = '0px 0px 0px';
            var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
            perspectiveStyle.perspective = perspective;
            perspectiveStyle.webkitPerspective = perspective;
            containerStyle.transformOrigin = origin;
            containerStyle.mozTransformOrigin = origin;
            containerStyle.webkitTransformOrigin = origin;
            perspectiveStyle.transform = matrix;
            perspectiveStyle.webkitTransform = matrix;
          }
        }
      };

      HCameraElement.prototype.createElements = function () {};

      HCameraElement.prototype.hide = function () {};

      HCameraElement.prototype.renderFrame = function () {
        var _mdf = this._isFirstFrame;
        var i;
        var len;

        if (this.hierarchy) {
          len = this.hierarchy.length;

          for (i = 0; i < len; i += 1) {
            _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
          }
        }

        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
          this.mat.reset();

          if (this.hierarchy) {
            len = this.hierarchy.length - 1;

            for (i = len; i >= 0; i -= 1) {
              var mTransf = this.hierarchy[i].finalTransform.mProp;
              this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
              this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
              this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
              this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
              this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
            }
          }

          if (this.p) {
            this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
          } else {
            this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
          }

          if (this.a) {
            var diffVector;

            if (this.p) {
              diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
            } else {
              diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
            }

            var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));

            var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
            var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
            var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);
            var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);
            this.mat.rotateY(mRotationY).rotateX(-mRotationX);
          }

          this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
          this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
          this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
          this.mat.translate(0, 0, this.pe.v);
          var hasMatrixChanged = !this._prevMat.equals(this.mat);

          if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
            len = this.comp.threeDElements.length;
            var comp;
            var perspectiveStyle;
            var containerStyle;

            for (i = 0; i < len; i += 1) {
              comp = this.comp.threeDElements[i];

              if (comp.type === '3d') {
                if (hasMatrixChanged) {
                  var matValue = this.mat.toCSS();
                  containerStyle = comp.container.style;
                  containerStyle.transform = matValue;
                  containerStyle.webkitTransform = matValue;
                }

                if (this.pe._mdf) {
                  perspectiveStyle = comp.perspectiveElem.style;
                  perspectiveStyle.perspective = this.pe.v + 'px';
                  perspectiveStyle.webkitPerspective = this.pe.v + 'px';
                }
              }
            }

            this.mat.clone(this._prevMat);
          }
        }

        this._isFirstFrame = false;
      };

      HCameraElement.prototype.prepareFrame = function (num) {
        this.prepareProperties(num, true);
      };

      HCameraElement.prototype.destroy = function () {};

      HCameraElement.prototype.getBaseElement = function () {
        return null;
      };

      function HImageElement(data, globalData, comp) {
        this.assetData = globalData.getAssetData(data.refId);
        this.initElement(data, globalData, comp);
      }

      extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

      HImageElement.prototype.createContent = function () {
        var assetPath = this.globalData.getAssetsPath(this.assetData);
        var img = new Image();

        if (this.data.hasMask) {
          this.imageElem = createNS('image');
          this.imageElem.setAttribute('width', this.assetData.w + 'px');
          this.imageElem.setAttribute('height', this.assetData.h + 'px');
          this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
          this.layerElement.appendChild(this.imageElem);
          this.baseElement.setAttribute('width', this.assetData.w);
          this.baseElement.setAttribute('height', this.assetData.h);
        } else {
          this.layerElement.appendChild(img);
        }

        img.crossOrigin = 'anonymous';
        img.src = assetPath;

        if (this.data.ln) {
          this.baseElement.setAttribute('id', this.data.ln);
        }
      };

      function HybridRendererBase(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || '',
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || '400%',
            height: config && config.filterSize && config.filterSize.height || '400%',
            x: config && config.filterSize && config.filterSize.x || '-100%',
            y: config && config.filterSize && config.filterSize.y || '-100%'
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = 'html';
      }

      extendPrototype([BaseRenderer], HybridRendererBase);
      HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;

      HybridRendererBase.prototype.checkPendingElements = function () {
        while (this.pendingElements.length) {
          var element = this.pendingElements.pop();
          element.checkParenting();
        }
      };

      HybridRendererBase.prototype.appendElementInPos = function (element, pos) {
        var newDOMElement = element.getBaseElement();

        if (!newDOMElement) {
          return;
        }

        var layer = this.layers[pos];

        if (!layer.ddd || !this.supports3d) {
          if (this.threeDElements) {
            this.addTo3dContainer(newDOMElement, pos);
          } else {
            var i = 0;
            var nextDOMElement;
            var nextLayer;
            var tmpDOMElement;

            while (i < pos) {
              if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
                nextLayer = this.elements[i];
                tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
                nextDOMElement = tmpDOMElement || nextDOMElement;
              }

              i += 1;
            }

            if (nextDOMElement) {
              if (!layer.ddd || !this.supports3d) {
                this.layerElement.insertBefore(newDOMElement, nextDOMElement);
              }
            } else if (!layer.ddd || !this.supports3d) {
              this.layerElement.appendChild(newDOMElement);
            }
          }
        } else {
          this.addTo3dContainer(newDOMElement, pos);
        }
      };

      HybridRendererBase.prototype.createShape = function (data) {
        if (!this.supports3d) {
          return new SVGShapeElement(data, this.globalData, this);
        }

        return new HShapeElement(data, this.globalData, this);
      };

      HybridRendererBase.prototype.createText = function (data) {
        if (!this.supports3d) {
          return new SVGTextLottieElement(data, this.globalData, this);
        }

        return new HTextElement(data, this.globalData, this);
      };

      HybridRendererBase.prototype.createCamera = function (data) {
        this.camera = new HCameraElement(data, this.globalData, this);
        return this.camera;
      };

      HybridRendererBase.prototype.createImage = function (data) {
        if (!this.supports3d) {
          return new IImageElement(data, this.globalData, this);
        }

        return new HImageElement(data, this.globalData, this);
      };

      HybridRendererBase.prototype.createSolid = function (data) {
        if (!this.supports3d) {
          return new ISolidElement(data, this.globalData, this);
        }

        return new HSolidElement(data, this.globalData, this);
      };

      HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;

      HybridRendererBase.prototype.getThreeDContainerByPos = function (pos) {
        var i = 0;
        var len = this.threeDElements.length;

        while (i < len) {
          if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
            return this.threeDElements[i].perspectiveElem;
          }

          i += 1;
        }

        return null;
      };

      HybridRendererBase.prototype.createThreeDContainer = function (pos, type) {
        var perspectiveElem = createTag('div');
        var style;
        var containerStyle;
        styleDiv(perspectiveElem);
        var container = createTag('div');
        styleDiv(container);

        if (type === '3d') {
          style = perspectiveElem.style;
          style.width = this.globalData.compSize.w + 'px';
          style.height = this.globalData.compSize.h + 'px';
          var center = '50% 50%';
          style.webkitTransformOrigin = center;
          style.mozTransformOrigin = center;
          style.transformOrigin = center;
          containerStyle = container.style;
          var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
          containerStyle.transform = matrix;
          containerStyle.webkitTransform = matrix;
        }

        perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);

        var threeDContainerData = {
          container: container,
          perspectiveElem: perspectiveElem,
          startPos: pos,
          endPos: pos,
          type: type
        };
        this.threeDElements.push(threeDContainerData);
        return threeDContainerData;
      };

      HybridRendererBase.prototype.build3dContainers = function () {
        var i;
        var len = this.layers.length;
        var lastThreeDContainerData;
        var currentContainer = '';

        for (i = 0; i < len; i += 1) {
          if (this.layers[i].ddd && this.layers[i].ty !== 3) {
            if (currentContainer !== '3d') {
              currentContainer = '3d';
              lastThreeDContainerData = this.createThreeDContainer(i, '3d');
            }

            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
          } else {
            if (currentContainer !== '2d') {
              currentContainer = '2d';
              lastThreeDContainerData = this.createThreeDContainer(i, '2d');
            }

            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
          }
        }

        len = this.threeDElements.length;

        for (i = len - 1; i >= 0; i -= 1) {
          this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
        }
      };

      HybridRendererBase.prototype.addTo3dContainer = function (elem, pos) {
        var i = 0;
        var len = this.threeDElements.length;

        while (i < len) {
          if (pos <= this.threeDElements[i].endPos) {
            var j = this.threeDElements[i].startPos;
            var nextElement;

            while (j < pos) {
              if (this.elements[j] && this.elements[j].getBaseElement) {
                nextElement = this.elements[j].getBaseElement();
              }

              j += 1;
            }

            if (nextElement) {
              this.threeDElements[i].container.insertBefore(elem, nextElement);
            } else {
              this.threeDElements[i].container.appendChild(elem);
            }

            break;
          }

          i += 1;
        }
      };

      HybridRendererBase.prototype.configAnimation = function (animData) {
        var resizerElem = createTag('div');
        var wrapper = this.animationItem.wrapper;
        var style = resizerElem.style;
        style.width = animData.w + 'px';
        style.height = animData.h + 'px';
        this.resizerElem = resizerElem;
        styleDiv(resizerElem);
        style.transformStyle = 'flat';
        style.mozTransformStyle = 'flat';
        style.webkitTransformStyle = 'flat';

        if (this.renderConfig.className) {
          resizerElem.setAttribute('class', this.renderConfig.className);
        }

        wrapper.appendChild(resizerElem);
        style.overflow = 'hidden';
        var svg = createNS('svg');
        svg.setAttribute('width', '1');
        svg.setAttribute('height', '1');
        styleDiv(svg);
        this.resizerElem.appendChild(svg);
        var defs = createNS('defs');
        svg.appendChild(defs);
        this.data = animData; // Mask animation

        this.setupGlobalData(animData, svg);
        this.globalData.defs = defs;
        this.layers = animData.layers;
        this.layerElement = this.resizerElem;
        this.build3dContainers();
        this.updateContainerSize();
      };

      HybridRendererBase.prototype.destroy = function () {
        if (this.animationItem.wrapper) {
          this.animationItem.wrapper.innerText = '';
        }

        this.animationItem.container = null;
        this.globalData.defs = null;
        var i;
        var len = this.layers ? this.layers.length : 0;

        for (i = 0; i < len; i += 1) {
          this.elements[i].destroy();
        }

        this.elements.length = 0;
        this.destroyed = true;
        this.animationItem = null;
      };

      HybridRendererBase.prototype.updateContainerSize = function () {
        var elementWidth = this.animationItem.wrapper.offsetWidth;
        var elementHeight = this.animationItem.wrapper.offsetHeight;
        var elementRel = elementWidth / elementHeight;
        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
        var sx;
        var sy;
        var tx;
        var ty;

        if (animationRel > elementRel) {
          sx = elementWidth / this.globalData.compSize.w;
          sy = elementWidth / this.globalData.compSize.w;
          tx = 0;
          ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;
        } else {
          sx = elementHeight / this.globalData.compSize.h;
          sy = elementHeight / this.globalData.compSize.h;
          tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
          ty = 0;
        }

        var style = this.resizerElem.style;
        style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
        style.transform = style.webkitTransform;
      };

      HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

      HybridRendererBase.prototype.hide = function () {
        this.resizerElem.style.display = 'none';
      };

      HybridRendererBase.prototype.show = function () {
        this.resizerElem.style.display = 'block';
      };

      HybridRendererBase.prototype.initItems = function () {
        this.buildAllItems();

        if (this.camera) {
          this.camera.setup();
        } else {
          var cWidth = this.globalData.compSize.w;
          var cHeight = this.globalData.compSize.h;
          var i;
          var len = this.threeDElements.length;

          for (i = 0; i < len; i += 1) {
            var style = this.threeDElements[i].perspectiveElem.style;
            style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
            style.perspective = style.webkitPerspective;
          }
        }
      };

      HybridRendererBase.prototype.searchExtraCompositions = function (assets) {
        var i;
        var len = assets.length;
        var floatingContainer = createTag('div');

        for (i = 0; i < len; i += 1) {
          if (assets[i].xt) {
            var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
            comp.initExpressions();
            this.globalData.projectInterface.registerComposition(comp);
          }
        }
      };

      function HCompElement(data, globalData, comp) {
        this.layers = data.layers;
        this.supports3d = !data.hasMask;
        this.completeLayers = false;
        this.pendingElements = [];
        this.elements = this.layers ? createSizedArray(this.layers.length) : [];
        this.initElement(data, globalData, comp);
        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {
          _placeholder: true
        };
      }

      extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement);
      HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

      HCompElement.prototype.createContainerElements = function () {
        this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';


        if (this.data.hasMask) {
          this.svgElement.setAttribute('width', this.data.w);
          this.svgElement.setAttribute('height', this.data.h);
          this.transformedElement = this.baseElement;
        } else {
          this.transformedElement = this.layerElement;
        }
      };

      HCompElement.prototype.addTo3dContainer = function (elem, pos) {
        var j = 0;
        var nextElement;

        while (j < pos) {
          if (this.elements[j] && this.elements[j].getBaseElement) {
            nextElement = this.elements[j].getBaseElement();
          }

          j += 1;
        }

        if (nextElement) {
          this.layerElement.insertBefore(elem, nextElement);
        } else {
          this.layerElement.appendChild(elem);
        }
      };

      HCompElement.prototype.createComp = function (data) {
        if (!this.supports3d) {
          return new SVGCompElement(data, this.globalData, this);
        }

        return new HCompElement(data, this.globalData, this);
      };

      function HybridRenderer(animationItem, config) {
        this.animationItem = animationItem;
        this.layers = null;
        this.renderedFrame = -1;
        this.renderConfig = {
          className: config && config.className || '',
          imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',
          hideOnTransparent: !(config && config.hideOnTransparent === false),
          filterSize: {
            width: config && config.filterSize && config.filterSize.width || '400%',
            height: config && config.filterSize && config.filterSize.height || '400%',
            x: config && config.filterSize && config.filterSize.x || '-100%',
            y: config && config.filterSize && config.filterSize.y || '-100%'
          }
        };
        this.globalData = {
          _mdf: false,
          frameNum: -1,
          renderConfig: this.renderConfig
        };
        this.pendingElements = [];
        this.elements = [];
        this.threeDElements = [];
        this.destroyed = false;
        this.camera = null;
        this.supports3d = true;
        this.rendererType = 'html';
      }

      extendPrototype([HybridRendererBase], HybridRenderer);

      HybridRenderer.prototype.createComp = function (data) {
        if (!this.supports3d) {
          return new SVGCompElement(data, this.globalData, this);
        }

        return new HCompElement(data, this.globalData, this);
      };

      var Expressions = function () {
        var ob = {};
        ob.initExpressions = initExpressions;

        function initExpressions(animation) {
          var stackCount = 0;
          var registers = [];

          function pushExpression() {
            stackCount += 1;
          }

          function popExpression() {
            stackCount -= 1;

            if (stackCount === 0) {
              releaseInstances();
            }
          }

          function registerExpressionProperty(expression) {
            if (registers.indexOf(expression) === -1) {
              registers.push(expression);
            }
          }

          function releaseInstances() {
            var i;
            var len = registers.length;

            for (i = 0; i < len; i += 1) {
              registers[i].release();
            }

            registers.length = 0;
          }

          animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
          animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
          animation.renderer.globalData.pushExpression = pushExpression;
          animation.renderer.globalData.popExpression = popExpression;
          animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
        }

        return ob;
      }();

      function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

      /* eslint-disable */

      /*
       Copyright 2014 David Bau.

       Permission is hereby granted, free of charge, to any person obtaining
       a copy of this software and associated documentation files (the
       "Software"), to deal in the Software without restriction, including
       without limitation the rights to use, copy, modify, merge, publish,
       distribute, sublicense, and/or sell copies of the Software, and to
       permit persons to whom the Software is furnished to do so, subject to
       the following conditions:

       The above copyright notice and this permission notice shall be
       included in all copies or substantial portions of the Software.

       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
       EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
       MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
       IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
       CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
       TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
       SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

       */
      function seedRandom(pool, math) {
        //
        // The following constants are related to IEEE 754 limits.
        //
        var global = this,
            width = 256,
            // each RC4 output is 0 <= x < 256
        chunks = 6,
            // at least six RC4 outputs for each double
        digits = 52,
            // there are 52 significant digits in a double
        rngname = 'random',
            // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
            significance = math.pow(2, digits),
            overflow = significance * 2,
            mask = width - 1,
            nodecrypto; // node.js crypto module, initialized at the bottom.
        //
        // seedrandom()
        // This is the seedrandom function described above.
        //

        function seedrandom(seed, options, callback) {
          var key = [];
          options = options === true ? {
            entropy: true
          } : options || {}; // Flatten the seed string or build one from local entropy if needed.

          var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.

          var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains
          // randomness in every bit of the mantissa of the IEEE 754 value.

          var prng = function prng() {
            var n = arc4.g(chunks),
                // Start with a numerator n < 2 ^ 48
            d = startdenom,
                //   and denominator d = 2 ^ 48.
            x = 0; //   and no 'extra last byte'.

            while (n < significance) {
              // Fill up all significant digits by
              n = (n + x) * width; //   shifting numerator and

              d *= width; //   denominator and generating a

              x = arc4.g(1); //   new least-significant-byte.
            }

            while (n >= overflow) {
              // To avoid rounding up, before adding
              n /= 2; //   last byte, shift everything

              d /= 2; //   right using integer math until

              x >>>= 1; //   we have exactly the desired bits.
            }

            return (n + x) / d; // Form the number within [0, 1).
          };

          prng.int32 = function () {
            return arc4.g(4) | 0;
          };

          prng.quick = function () {
            return arc4.g(4) / 0x100000000;
          };

          prng["double"] = prng; // Mix the randomness into accumulated entropy.

          mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.

          return (options.pass || callback || function (prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) {
                copy(state, arc4);
              } // Only provide the .state method if requested via options.state.


              prng.state = function () {
                return copy(arc4, {});
              };
            } // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.


            if (is_math_call) {
              math[rngname] = prng;
              return seed;
            } // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);
        }

        math['seed' + rngname] = seedrandom; //
        // ARC4
        //
        // An ARC4 implementation.  The constructor takes a key in the form of
        // an array of at most (width) integers that should be 0 <= x < (width).
        //
        // The g(count) method returns a pseudorandom integer that concatenates
        // the next (count) outputs from ARC4.  Its return value is a number x
        // that is in the range 0 <= x < (width ^ count).
        //

        function ARC4(key) {
          var t,
              keylen = key.length,
              me = this,
              i = 0,
              j = me.i = me.j = 0,
              s = me.S = []; // The empty key [] is treated as [0].

          if (!keylen) {
            key = [keylen++];
          } // Set up S using the standard key scheduling algorithm.


          while (i < width) {
            s[i] = i++;
          }

          for (i = 0; i < width; i++) {
            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
            s[j] = t;
          } // The "g" method returns the next (count) outputs as one number.


          me.g = function (count) {
            // Using instance members instead of closure state nearly doubles speed.
            var t,
                r = 0,
                i = me.i,
                j = me.j,
                s = me.S;

            while (count--) {
              t = s[i = mask & i + 1];
              r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];
            }

            me.i = i;
            me.j = j;
            return r; // For robust unpredictability, the function call below automatically
            // discards an initial batch of values.  This is called RC4-drop[256].
            // See http://google.com/search?q=rsa+fluhrer+response&btnI
          };
        } //
        // copy()
        // Copies internal state of ARC4 to or from a plain object.
        //


        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        } //
        // flatten()
        // Converts an object tree to nested arrays of strings.
        //


        function flatten(obj, depth) {
          var result = [],
              typ = _typeof$1(obj),
              prop;

          if (depth && typ == 'object') {
            for (prop in obj) {
              try {
                result.push(flatten(obj[prop], depth - 1));
              } catch (e) {}
            }
          }

          return result.length ? result : typ == 'string' ? obj : obj + '\0';
        } //
        // mixkey()
        // Mixes a string seed into a key that is an array of integers, and
        // returns a shortened string seed that is equivalent to the result key.
        //


        function mixkey(seed, key) {
          var stringseed = seed + '',
              smear,
              j = 0;

          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }

          return tostring(key);
        } //
        // autoseed()
        // Returns an object for autoseeding, using window.crypto and Node crypto
        // module if available.
        //


        function autoseed() {
          try {
            if (nodecrypto) ;

            var out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
            return tostring(out);
          } catch (e) {
            var browser = global.navigator,
                plugins = browser && browser.plugins;
            return [+new Date(), global, plugins, global.screen, tostring(pool)];
          }
        } //
        // tostring()
        // Converts an array of charcodes to a string
        //


        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        } //
        // When seedrandom.js is loaded, we immediately mix a few bits
        // from the built-in RNG into the entropy pool.  Because we do
        // not want to interfere with deterministic PRNG state later,
        // seedrandom will not call math.random on its own again after
        // initialization.
        //


        mixkey(math.random(), pool); //
        // Nodejs and AMD support: export the implementation as a module using
        // either convention.
        //
        // End anonymous scope, and pass initial values.
      }

      function initialize$2(BMMath) {
        seedRandom([], BMMath);
      }

      var propTypes = {
        SHAPE: 'shape'
      };

      function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

      var ExpressionManager = function () {

        var ob = {};
        var Math = BMMath;
        var window = null;
        var document = null;
        var XMLHttpRequest = null;
        var fetch = null;
        var frames = null;
        initialize$2(BMMath);

        function $bm_isInstanceOfArray(arr) {
          return arr.constructor === Array || arr.constructor === Float32Array;
        }

        function isNumerable(tOfV, v) {
          return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;
        }

        function $bm_neg(a) {
          var tOfA = _typeof(a);

          if (tOfA === 'number' || tOfA === 'boolean' || a instanceof Number) {
            return -a;
          }

          if ($bm_isInstanceOfArray(a)) {
            var i;
            var lenA = a.length;
            var retArr = [];

            for (i = 0; i < lenA; i += 1) {
              retArr[i] = -a[i];
            }

            return retArr;
          }

          if (a.propType) {
            return a.v;
          }

          return -a;
        }

        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

        function sum(a, b) {
          var tOfA = _typeof(a);

          var tOfB = _typeof(b);

          if (tOfA === 'string' || tOfB === 'string') {
            return a + b;
          }

          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a + b;
          }

          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] += b;
            return a;
          }

          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a + b[0];
            return b;
          }

          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];

            while (i < lenA || i < lenB) {
              if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
                retArr[i] = a[i] + b[i];
              } else {
                retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
              }

              i += 1;
            }

            return retArr;
          }

          return 0;
        }

        var add = sum;

        function sub(a, b) {
          var tOfA = _typeof(a);

          var tOfB = _typeof(b);

          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            if (tOfA === 'string') {
              a = parseInt(a, 10);
            }

            if (tOfB === 'string') {
              b = parseInt(b, 10);
            }

            return a - b;
          }

          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            a = a.slice(0);
            a[0] -= b;
            return a;
          }

          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            b = b.slice(0);
            b[0] = a - b[0];
            return b;
          }

          if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {
            var i = 0;
            var lenA = a.length;
            var lenB = b.length;
            var retArr = [];

            while (i < lenA || i < lenB) {
              if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {
                retArr[i] = a[i] - b[i];
              } else {
                retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];
              }

              i += 1;
            }

            return retArr;
          }

          return 0;
        }

        function mul(a, b) {
          var tOfA = _typeof(a);

          var tOfB = _typeof(b);

          var arr;

          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a * b;
          }

          var i;
          var len;

          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray('float32', len);

            for (i = 0; i < len; i += 1) {
              arr[i] = a[i] * b;
            }

            return arr;
          }

          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray('float32', len);

            for (i = 0; i < len; i += 1) {
              arr[i] = a * b[i];
            }

            return arr;
          }

          return 0;
        }

        function div(a, b) {
          var tOfA = _typeof(a);

          var tOfB = _typeof(b);

          var arr;

          if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {
            return a / b;
          }

          var i;
          var len;

          if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {
            len = a.length;
            arr = createTypedArray('float32', len);

            for (i = 0; i < len; i += 1) {
              arr[i] = a[i] / b;
            }

            return arr;
          }

          if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {
            len = b.length;
            arr = createTypedArray('float32', len);

            for (i = 0; i < len; i += 1) {
              arr[i] = a / b[i];
            }

            return arr;
          }

          return 0;
        }

        function mod(a, b) {
          if (typeof a === 'string') {
            a = parseInt(a, 10);
          }

          if (typeof b === 'string') {
            b = parseInt(b, 10);
          }

          return a % b;
        }

        var $bm_sum = sum;
        var $bm_sub = sub;
        var $bm_mul = mul;
        var $bm_div = div;
        var $bm_mod = mod;

        function clamp(num, min, max) {
          if (min > max) {
            var mm = max;
            max = min;
            min = mm;
          }

          return Math.min(Math.max(num, min), max);
        }

        function radiansToDegrees(val) {
          return val / degToRads;
        }

        var radians_to_degrees = radiansToDegrees;

        function degreesToRadians(val) {
          return val * degToRads;
        }

        var degrees_to_radians = radiansToDegrees;
        var helperLengthArray = [0, 0, 0, 0, 0, 0];

        function length(arr1, arr2) {
          if (typeof arr1 === 'number' || arr1 instanceof Number) {
            arr2 = arr2 || 0;
            return Math.abs(arr1 - arr2);
          }

          if (!arr2) {
            arr2 = helperLengthArray;
          }

          var i;
          var len = Math.min(arr1.length, arr2.length);
          var addedLength = 0;

          for (i = 0; i < len; i += 1) {
            addedLength += Math.pow(arr2[i] - arr1[i], 2);
          }

          return Math.sqrt(addedLength);
        }

        function normalize(vec) {
          return div(vec, length(vec));
        }

        function rgbToHsl(val) {
          var r = val[0];
          var g = val[1];
          var b = val[2];
          var max = Math.max(r, g, b);
          var min = Math.min(r, g, b);
          var h;
          var s;
          var l = (max + min) / 2;

          if (max === min) {
            h = 0; // achromatic

            s = 0; // achromatic
          } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;

              case g:
                h = (b - r) / d + 2;
                break;

              case b:
                h = (r - g) / d + 4;
                break;
            }

            h /= 6;
          }

          return [h, s, l, val[3]];
        }

        function hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        }

        function hslToRgb(val) {
          var h = val[0];
          var s = val[1];
          var l = val[2];
          var r;
          var g;
          var b;

          if (s === 0) {
            r = l; // achromatic

            b = l; // achromatic

            g = l; // achromatic
          } else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
          }

          return [r, g, b, val[3]];
        }

        function linear(t, tMin, tMax, value1, value2) {
          if (value1 === undefined || value2 === undefined) {
            value1 = tMin;
            value2 = tMax;
            tMin = 0;
            tMax = 1;
          }

          if (tMax < tMin) {
            var _tMin = tMax;
            tMax = tMin;
            tMin = _tMin;
          }

          if (t <= tMin) {
            return value1;
          }

          if (t >= tMax) {
            return value2;
          }

          var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);

          if (!value1.length) {
            return value1 + (value2 - value1) * perc;
          }

          var i;
          var len = value1.length;
          var arr = createTypedArray('float32', len);

          for (i = 0; i < len; i += 1) {
            arr[i] = value1[i] + (value2[i] - value1[i]) * perc;
          }

          return arr;
        }

        function random(min, max) {
          if (max === undefined) {
            if (min === undefined) {
              min = 0;
              max = 1;
            } else {
              max = min;
              min = undefined;
            }
          }

          if (max.length) {
            var i;
            var len = max.length;

            if (!min) {
              min = createTypedArray('float32', len);
            }

            var arr = createTypedArray('float32', len);
            var rnd = BMMath.random();

            for (i = 0; i < len; i += 1) {
              arr[i] = min[i] + rnd * (max[i] - min[i]);
            }

            return arr;
          }

          if (min === undefined) {
            min = 0;
          }

          var rndm = BMMath.random();
          return min + rndm * (max - min);
        }

        function createPath(points, inTangents, outTangents, closed) {
          var i;
          var len = points.length;
          var path = shapePool.newElement();
          path.setPathData(!!closed, len);
          var arrPlaceholder = [0, 0];
          var inVertexPoint;
          var outVertexPoint;

          for (i = 0; i < len; i += 1) {
            inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;
            outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;
            path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);
          }

          return path;
        }

        function initiateExpression(elem, data, property) {
          var val = data.x;
          var needsVelocity = /velocity(?![\w\d])/.test(val);

          var _needsRandom = val.indexOf('random') !== -1;

          var elemType = elem.data.ty;
          var transform;
          var $bm_transform;
          var content;
          var effect;
          var thisProperty = property;
          thisProperty.valueAtTime = thisProperty.getValueAtTime;
          Object.defineProperty(thisProperty, 'value', {
            get: function get() {
              return thisProperty.v;
            }
          });
          elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
          elem.comp.displayStartTime = 0;
          var inPoint = elem.data.ip / elem.comp.globalData.frameRate;
          var outPoint = elem.data.op / elem.comp.globalData.frameRate;
          var width = elem.data.sw ? elem.data.sw : 0;
          var height = elem.data.sh ? elem.data.sh : 0;
          var name = elem.data.nm;
          var loopIn;
          var loop_in;
          var loopOut;
          var loop_out;
          var smooth;
          var toWorld;
          var fromWorld;
          var fromComp;
          var toComp;
          var fromCompToSurface;
          var position;
          var rotation;
          var anchorPoint;
          var scale;
          var thisLayer;
          var thisComp;
          var mask;
          var valueAtTime;
          var velocityAtTime;
          var scoped_bm_rt; // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls

          var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval

          var numKeys = property.kf ? data.k.length : 0;
          var active = !this.data || this.data.hd !== true;

          var wiggle = function wiggle(freq, amp) {
            var iWiggle;
            var j;
            var lenWiggle = this.pv.length ? this.pv.length : 1;
            var addedAmps = createTypedArray('float32', lenWiggle);
            freq = 5;
            var iterations = Math.floor(time * freq);
            iWiggle = 0;
            j = 0;

            while (iWiggle < iterations) {
              // var rnd = BMMath.random();
              for (j = 0; j < lenWiggle; j += 1) {
                addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;
              }

              iWiggle += 1;
            } // var rnd2 = BMMath.random();


            var periods = time * freq;
            var perc = periods - Math.floor(periods);
            var arr = createTypedArray('float32', lenWiggle);

            if (lenWiggle > 1) {
              for (j = 0; j < lenWiggle; j += 1) {
                arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
                // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
              }

              return arr;
            }

            return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
          }.bind(this);

          if (thisProperty.loopIn) {
            loopIn = thisProperty.loopIn.bind(thisProperty);
            loop_in = loopIn;
          }

          if (thisProperty.loopOut) {
            loopOut = thisProperty.loopOut.bind(thisProperty);
            loop_out = loopOut;
          }

          if (thisProperty.smooth) {
            smooth = thisProperty.smooth.bind(thisProperty);
          }

          function loopInDuration(type, duration) {
            return loopIn(type, duration, true);
          }

          function loopOutDuration(type, duration) {
            return loopOut(type, duration, true);
          }

          if (this.getValueAtTime) {
            valueAtTime = this.getValueAtTime.bind(this);
          }

          if (this.getVelocityAtTime) {
            velocityAtTime = this.getVelocityAtTime.bind(this);
          }

          var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

          function lookAt(elem1, elem2) {
            var fVec = [elem2[0] - elem1[0], elem2[1] - elem1[1], elem2[2] - elem1[2]];
            var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;
            var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;
            return [yaw, pitch, 0];
          }

          function easeOut(t, tMin, tMax, val1, val2) {
            return applyEase(easeOutBez, t, tMin, tMax, val1, val2);
          }

          function easeIn(t, tMin, tMax, val1, val2) {
            return applyEase(easeInBez, t, tMin, tMax, val1, val2);
          }

          function ease(t, tMin, tMax, val1, val2) {
            return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);
          }

          function applyEase(fn, t, tMin, tMax, val1, val2) {
            if (val1 === undefined) {
              val1 = tMin;
              val2 = tMax;
            } else {
              t = (t - tMin) / (tMax - tMin);
            }

            if (t > 1) {
              t = 1;
            } else if (t < 0) {
              t = 0;
            }

            var mult = fn(t);

            if ($bm_isInstanceOfArray(val1)) {
              var iKey;
              var lenKey = val1.length;
              var arr = createTypedArray('float32', lenKey);

              for (iKey = 0; iKey < lenKey; iKey += 1) {
                arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];
              }

              return arr;
            }

            return (val2 - val1) * mult + val1;
          }

          function nearestKey(time) {
            var iKey;
            var lenKey = data.k.length;
            var index;
            var keyTime;

            if (!data.k.length || typeof data.k[0] === 'number') {
              index = 0;
              keyTime = 0;
            } else {
              index = -1;
              time *= elem.comp.globalData.frameRate;

              if (time < data.k[0].t) {
                index = 1;
                keyTime = data.k[0].t;
              } else {
                for (iKey = 0; iKey < lenKey - 1; iKey += 1) {
                  if (time === data.k[iKey].t) {
                    index = iKey + 1;
                    keyTime = data.k[iKey].t;
                    break;
                  } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {
                    if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {
                      index = iKey + 2;
                      keyTime = data.k[iKey + 1].t;
                    } else {
                      index = iKey + 1;
                      keyTime = data.k[iKey].t;
                    }

                    break;
                  }
                }

                if (index === -1) {
                  index = iKey + 1;
                  keyTime = data.k[iKey].t;
                }
              }
            }

            var obKey = {};
            obKey.index = index;
            obKey.time = keyTime / elem.comp.globalData.frameRate;
            return obKey;
          }

          function key(ind) {
            var obKey;
            var iKey;
            var lenKey;

            if (!data.k.length || typeof data.k[0] === 'number') {
              throw new Error('The property has no keyframe at index ' + ind);
            }

            ind -= 1;
            obKey = {
              time: data.k[ind].t / elem.comp.globalData.frameRate,
              value: []
            };
            var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;
            lenKey = arr.length;

            for (iKey = 0; iKey < lenKey; iKey += 1) {
              obKey[iKey] = arr[iKey];
              obKey.value[iKey] = arr[iKey];
            }

            return obKey;
          }

          function framesToTime(fr, fps) {
            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }

            return fr / fps;
          }

          function timeToFrames(t, fps) {
            if (!t && t !== 0) {
              t = time;
            }

            if (!fps) {
              fps = elem.comp.globalData.frameRate;
            }

            return t * fps;
          }

          function seedRandom(seed) {
            BMMath.seedrandom(randSeed + seed);
          }

          function sourceRectAtTime() {
            return elem.sourceRectAtTime();
          }

          function substring(init, end) {
            if (typeof value === 'string') {
              if (end === undefined) {
                return value.substring(init);
              }

              return value.substring(init, end);
            }

            return '';
          }

          function substr(init, end) {
            if (typeof value === 'string') {
              if (end === undefined) {
                return value.substr(init);
              }

              return value.substr(init, end);
            }

            return '';
          }

          function posterizeTime(framesPerSecond) {
            time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;
            value = valueAtTime(time);
          }

          var time;
          var velocity;
          var value;
          var text;
          var textIndex;
          var textTotal;
          var selectorValue;
          var index = elem.data.ind;
          var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          var parent;
          var randSeed = Math.floor(Math.random() * 1000000);
          var globalData = elem.globalData;

          function executeExpression(_value) {
            // globalData.pushExpression();
            value = _value;

            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
              return value;
            }

            if (this.propType === 'textSelector') {
              textIndex = this.textIndex;
              textTotal = this.textTotal;
              selectorValue = this.selectorValue;
            }

            if (!thisLayer) {
              text = elem.layerInterface.text;
              thisLayer = elem.layerInterface;
              thisComp = elem.comp.compInterface;
              toWorld = thisLayer.toWorld.bind(thisLayer);
              fromWorld = thisLayer.fromWorld.bind(thisLayer);
              fromComp = thisLayer.fromComp.bind(thisLayer);
              toComp = thisLayer.toComp.bind(thisLayer);
              mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
              fromCompToSurface = fromComp;
            }

            if (!transform) {
              transform = elem.layerInterface('ADBE Transform Group');
              $bm_transform = transform;

              if (transform) {
                anchorPoint = transform.anchorPoint;
                /* position = transform.position;
                          rotation = transform.rotation;
                          scale = transform.scale; */
              }
            }

            if (elemType === 4 && !content) {
              content = thisLayer('ADBE Root Vectors Group');
            }

            if (!effect) {
              effect = thisLayer(4);
            }

            hasParent = !!(elem.hierarchy && elem.hierarchy.length);

            if (hasParent && !parent) {
              parent = elem.hierarchy[0].layerInterface;
            }

            time = this.comp.renderedFrame / this.comp.globalData.frameRate;

            if (_needsRandom) {
              seedRandom(randSeed + time);
            }

            if (needsVelocity) {
              velocity = velocityAtTime(time);
            }

            expression_function();
            this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value
            // Changed this to a ternary operation because Rollup failed compiling it correctly

            scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;
            return scoped_bm_rt;
          } // Bundlers will see these as dead code and unless we reference them


          executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData];
          return executeExpression;
        }

        ob.initiateExpression = initiateExpression;
        ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath];
        return ob;
      }();

      var expressionHelpers = function () {
        function searchExpressions(elem, data, prop) {
          if (data.x) {
            prop.k = true;
            prop.x = true;
            prop.initiateExpression = ExpressionManager.initiateExpression;
            prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
          }
        }

        function getValueAtTime(frameNum) {
          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;

          if (frameNum !== this._cachingAtTime.lastFrame) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
            this._cachingAtTime.lastFrame = frameNum;
          }

          return this._cachingAtTime.value;
        }

        function getSpeedAtTime(frameNum) {
          var delta = -0.01;
          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var speed = 0;

          if (v1.length) {
            var i;

            for (i = 0; i < v1.length; i += 1) {
              speed += Math.pow(v2[i] - v1[i], 2);
            }

            speed = Math.sqrt(speed) * 100;
          } else {
            speed = 0;
          }

          return speed;
        }

        function getVelocityAtTime(frameNum) {
          if (this.vel !== undefined) {
            return this.vel;
          }

          var delta = -0.001; // frameNum += this.elem.data.st;

          var v1 = this.getValueAtTime(frameNum);
          var v2 = this.getValueAtTime(frameNum + delta);
          var velocity;

          if (v1.length) {
            velocity = createTypedArray('float32', v1.length);
            var i;

            for (i = 0; i < v1.length; i += 1) {
              // removing frameRate
              // if needed, don't add it here
              // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
              velocity[i] = (v2[i] - v1[i]) / delta;
            }
          } else {
            velocity = (v2 - v1) / delta;
          }

          return velocity;
        }

        function getStaticValueAtTime() {
          return this.pv;
        }

        function setGroupProperty(propertyGroup) {
          this.propertyGroup = propertyGroup;
        }

        return {
          searchExpressions: searchExpressions,
          getSpeedAtTime: getSpeedAtTime,
          getVelocityAtTime: getVelocityAtTime,
          getValueAtTime: getValueAtTime,
          getStaticValueAtTime: getStaticValueAtTime,
          setGroupProperty: setGroupProperty
        };
      }();

      function addPropertyDecorator() {
        function loopOut(type, duration, durationFlag) {
          if (!this.k || !this.keyframes) {
            return this.pv;
          }

          type = type ? type.toLowerCase() : '';
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var lastKeyFrame = keyframes[keyframes.length - 1].t;

          if (currentFrame <= lastKeyFrame) {
            return this.pv;
          }

          var cycleDuration;
          var firstKeyFrame;

          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }

            firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
            } else {
              cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
            }

            firstKeyFrame = lastKeyFrame - cycleDuration;
          }

          var i;
          var len;
          var ret;

          if (type === 'pingpong') {
            var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);

            if (iterations % 2 !== 0) {
              return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
            }
          } else if (type === 'offset') {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line

            var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);

            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;

              for (i = 0; i < len; i += 1) {
                ret[i] = (endV[i] - initV[i]) * repeats + current[i];
              }

              return ret;
            }

            return (endV - initV) * repeats + current;
          } else if (type === 'continue') {
            var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);

            if (this.pv.length) {
              ret = new Array(lastValue.length);
              len = ret.length;

              for (i = 0; i < len; i += 1) {
                ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
              }

              return ret;
            }

            return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);
          }

          return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
        }

        function loopIn(type, duration, durationFlag) {
          if (!this.k) {
            return this.pv;
          }

          type = type ? type.toLowerCase() : '';
          var currentFrame = this.comp.renderedFrame;
          var keyframes = this.keyframes;
          var firstKeyFrame = keyframes[0].t;

          if (currentFrame >= firstKeyFrame) {
            return this.pv;
          }

          var cycleDuration;
          var lastKeyFrame;

          if (!durationFlag) {
            if (!duration || duration > keyframes.length - 1) {
              duration = keyframes.length - 1;
            }

            lastKeyFrame = keyframes[duration].t;
            cycleDuration = lastKeyFrame - firstKeyFrame;
          } else {
            if (!duration) {
              cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
            } else {
              cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
            }

            lastKeyFrame = firstKeyFrame + cycleDuration;
          }

          var i;
          var len;
          var ret;

          if (type === 'pingpong') {
            var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);

            if (iterations % 2 === 0) {
              return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
            }
          } else if (type === 'offset') {
            var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);
            var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;

            if (this.pv.length) {
              ret = new Array(initV.length);
              len = ret.length;

              for (i = 0; i < len; i += 1) {
                ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
              }

              return ret;
            }

            return current - (endV - initV) * repeats;
          } else if (type === 'continue') {
            var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
            var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);

            if (this.pv.length) {
              ret = new Array(firstValue.length);
              len = ret.length;

              for (i = 0; i < len; i += 1) {
                ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;
              }

              return ret;
            }

            return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;
          }

          return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
        }

        function smooth(width, samples) {
          if (!this.k) {
            return this.pv;
          }

          width = (width || 0.4) * 0.5;
          samples = Math.floor(samples || 5);

          if (samples <= 1) {
            return this.pv;
          }

          var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
          var initFrame = currentTime - width;
          var endFrame = currentTime + width;
          var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
          var i = 0;
          var j = 0;
          var value;

          if (this.pv.length) {
            value = createTypedArray('float32', this.pv.length);
          } else {
            value = 0;
          }

          var sampleValue;

          while (i < samples) {
            sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);

            if (this.pv.length) {
              for (j = 0; j < this.pv.length; j += 1) {
                value[j] += sampleValue[j];
              }
            } else {
              value += sampleValue;
            }

            i += 1;
          }

          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value[j] /= samples;
            }
          } else {
            value /= samples;
          }

          return value;
        }

        function getTransformValueAtTime(time) {
          if (!this._transformCachingAtTime) {
            this._transformCachingAtTime = {
              v: new Matrix()
            };
          } /// /


          var matrix = this._transformCachingAtTime.v;
          matrix.cloneFromProps(this.pre.props);

          if (this.appliedTransformations < 1) {
            var anchor = this.a.getValueAtTime(time);
            matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);
          }

          if (this.appliedTransformations < 2) {
            var scale = this.s.getValueAtTime(time);
            matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);
          }

          if (this.sk && this.appliedTransformations < 3) {
            var skew = this.sk.getValueAtTime(time);
            var skewAxis = this.sa.getValueAtTime(time);
            matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
          }

          if (this.r && this.appliedTransformations < 4) {
            var rotation = this.r.getValueAtTime(time);
            matrix.rotate(-rotation * this.r.mult);
          } else if (!this.r && this.appliedTransformations < 4) {
            var rotationZ = this.rz.getValueAtTime(time);
            var rotationY = this.ry.getValueAtTime(time);
            var rotationX = this.rx.getValueAtTime(time);
            var orientation = this.or.getValueAtTime(time);
            matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);
          }

          if (this.data.p && this.data.p.s) {
            var positionX = this.px.getValueAtTime(time);
            var positionY = this.py.getValueAtTime(time);

            if (this.data.p.z) {
              var positionZ = this.pz.getValueAtTime(time);
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);
            } else {
              matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
            }
          } else {
            var position = this.p.getValueAtTime(time);
            matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);
          }

          return matrix; /// /
        }

        function getTransformStaticValueAtTime() {
          return this.v.clone(new Matrix());
        }

        var getTransformProperty = TransformPropertyFactory.getTransformProperty;

        TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
          var prop = getTransformProperty(elem, data, container);

          if (prop.dynamicProperties.length) {
            prop.getValueAtTime = getTransformValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
          }

          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          return prop;
        };

        var propertyGetProp = PropertyFactory.getProp;

        PropertyFactory.getProp = function (elem, data, type, mult, container) {
          var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;
          // prop.loopOut = loopOut;
          // prop.loopIn = loopIn;

          if (prop.kf) {
            prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
          } else {
            prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
          }

          prop.setGroupProperty = expressionHelpers.setGroupProperty;
          prop.loopOut = loopOut;
          prop.loopIn = loopIn;
          prop.smooth = smooth;
          prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
          prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
          prop.numKeys = data.a === 1 ? data.k.length : 0;
          prop.propertyIndex = data.ix;
          var value = 0;

          if (type !== 0) {
            value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
          }

          prop._cachingAtTime = {
            lastFrame: initialDefaultFrame,
            lastIndex: 0,
            value: value
          };
          expressionHelpers.searchExpressions(elem, data, prop);

          if (prop.k) {
            container.addDynamicProperty(prop);
          }

          return prop;
        };

        function getShapeValueAtTime(frameNum) {
          // For now this caching object is created only when needed instead of creating it when the shape is initialized.
          if (!this._cachingAtTime) {
            this._cachingAtTime = {
              shapeValue: shapePool.clone(this.pv),
              lastIndex: 0,
              lastTime: initialDefaultFrame
            };
          }

          frameNum *= this.elem.globalData.frameRate;
          frameNum -= this.offsetTime;

          if (frameNum !== this._cachingAtTime.lastTime) {
            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
            this._cachingAtTime.lastTime = frameNum;
            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
          }

          return this._cachingAtTime.shapeValue;
        }

        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

        function ShapeExpressions() {}

        ShapeExpressions.prototype = {
          vertices: function vertices(prop, time) {
            if (this.k) {
              this.getValue();
            }

            var shapePath = this.v;

            if (time !== undefined) {
              shapePath = this.getValueAtTime(time, 0);
            }

            var i;
            var len = shapePath._length;
            var vertices = shapePath[prop];
            var points = shapePath.v;
            var arr = createSizedArray(len);

            for (i = 0; i < len; i += 1) {
              if (prop === 'i' || prop === 'o') {
                arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
              } else {
                arr[i] = [vertices[i][0], vertices[i][1]];
              }
            }

            return arr;
          },
          points: function points(time) {
            return this.vertices('v', time);
          },
          inTangents: function inTangents(time) {
            return this.vertices('i', time);
          },
          outTangents: function outTangents(time) {
            return this.vertices('o', time);
          },
          isClosed: function isClosed() {
            return this.v.c;
          },
          pointOnPath: function pointOnPath(perc, time) {
            var shapePath = this.v;

            if (time !== undefined) {
              shapePath = this.getValueAtTime(time, 0);
            }

            if (!this._segmentsLength) {
              this._segmentsLength = bez.getSegmentsLength(shapePath);
            }

            var segmentsLength = this._segmentsLength;
            var lengths = segmentsLength.lengths;
            var lengthPos = segmentsLength.totalLength * perc;
            var i = 0;
            var len = lengths.length;
            var accumulatedLength = 0;
            var pt;

            while (i < len) {
              if (accumulatedLength + lengths[i].addedLength > lengthPos) {
                var initIndex = i;
                var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;
                var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
                pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
                break;
              } else {
                accumulatedLength += lengths[i].addedLength;
              }

              i += 1;
            }

            if (!pt) {
              pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
            }

            return pt;
          },
          vectorOnPath: function vectorOnPath(perc, time, vectorType) {
            // perc doesn't use triple equality because it can be a Number object as well as a primitive.
            if (perc == 1) {
              // eslint-disable-line eqeqeq
              perc = this.v.c;
            } else if (perc == 0) {
              // eslint-disable-line eqeqeq
              perc = 0.999;
            }

            var pt1 = this.pointOnPath(perc, time);
            var pt2 = this.pointOnPath(perc + 0.001, time);
            var xLength = pt2[0] - pt1[0];
            var yLength = pt2[1] - pt1[1];
            var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));

            if (magnitude === 0) {
              return [0, 0];
            }

            var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
            return unitVector;
          },
          tangentOnPath: function tangentOnPath(perc, time) {
            return this.vectorOnPath(perc, time, 'tangent');
          },
          normalOnPath: function normalOnPath(perc, time) {
            return this.vectorOnPath(perc, time, 'normal');
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime
        };
        extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
        extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;
        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;

        ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
          var prop = propertyGetShapeProp(elem, data, type, arr, trims);
          prop.propertyIndex = data.ix;
          prop.lock = false;

          if (type === 3) {
            expressionHelpers.searchExpressions(elem, data.pt, prop);
          } else if (type === 4) {
            expressionHelpers.searchExpressions(elem, data.ks, prop);
          }

          if (prop.k) {
            elem.addDynamicProperty(prop);
          }

          return prop;
        };
      }

      function initialize$1() {
        addPropertyDecorator();
      }

      function addDecorator() {
        function searchExpressions() {
          if (this.data.d.x) {
            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
            this.addEffect(this.getExpressionValue.bind(this));
            return true;
          }

          return null;
        }

        TextProperty.prototype.getExpressionValue = function (currentValue, text) {
          var newValue = this.calculateExpression(text);

          if (currentValue.t !== newValue) {
            var newData = {};
            this.copyData(newData, currentValue);
            newData.t = newValue.toString();
            newData.__complete = false;
            return newData;
          }

          return currentValue;
        };

        TextProperty.prototype.searchProperty = function () {
          var isKeyframed = this.searchKeyframes();
          var hasExpressions = this.searchExpressions();
          this.kf = isKeyframed || hasExpressions;
          return this.kf;
        };

        TextProperty.prototype.searchExpressions = searchExpressions;
      }

      function initialize() {
        addDecorator();
      }

      function SVGComposableEffect() {}

      SVGComposableEffect.prototype = {
        createMergeNode: function createMergeNode(resultId, ins) {
          var feMerge = createNS('feMerge');
          feMerge.setAttribute('result', resultId);
          var feMergeNode;
          var i;

          for (i = 0; i < ins.length; i += 1) {
            feMergeNode = createNS('feMergeNode');
            feMergeNode.setAttribute('in', ins[i]);
            feMerge.appendChild(feMergeNode);
            feMerge.appendChild(feMergeNode);
          }

          return feMerge;
        }
      };

      function SVGTintFilter(filter, filterManager, elem, id, source) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
        feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result', id + '_tint_1');
        filter.appendChild(feColorMatrix);
        feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
        feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result', id + '_tint_2');
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
        var feMerge = this.createMergeNode(id, [source, id + '_tint_1', id + '_tint_2']);
        filter.appendChild(feMerge);
      }

      extendPrototype([SVGComposableEffect], SVGTintFilter);

      SVGTintFilter.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var colorBlack = this.filterManager.effectElements[0].p.v;
          var colorWhite = this.filterManager.effectElements[1].p.v;
          var opacity = this.filterManager.effectElements[2].p.v / 100;
          this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
        }
      };

      function SVGFillFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
        feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
        feColorMatrix.setAttribute('result', id);
        filter.appendChild(feColorMatrix);
        this.matrixFilter = feColorMatrix;
      }

      SVGFillFilter.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color = this.filterManager.effectElements[2].p.v;
          var opacity = this.filterManager.effectElements[6].p.v;
          this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
        }
      };

      function SVGStrokeEffect(fil, filterManager, elem) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.elem = elem;
        this.paths = [];
      }

      SVGStrokeEffect.prototype.initialize = function () {
        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
        var path;
        var groupPath;
        var i;
        var len;

        if (this.filterManager.effectElements[1].p.v === 1) {
          len = this.elem.maskManager.masksProperties.length;
          i = 0;
        } else {
          i = this.filterManager.effectElements[0].p.v - 1;
          len = i + 1;
        }

        groupPath = createNS('g');
        groupPath.setAttribute('fill', 'none');
        groupPath.setAttribute('stroke-linecap', 'round');
        groupPath.setAttribute('stroke-dashoffset', 1);

        for (i; i < len; i += 1) {
          path = createNS('path');
          groupPath.appendChild(path);
          this.paths.push({
            p: path,
            m: i
          });
        }

        if (this.filterManager.effectElements[10].p.v === 3) {
          var mask = createNS('mask');
          var id = createElementID();
          mask.setAttribute('id', id);
          mask.setAttribute('mask-type', 'alpha');
          mask.appendChild(groupPath);
          this.elem.globalData.defs.appendChild(mask);
          var g = createNS('g');
          g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');

          while (elemChildren[0]) {
            g.appendChild(elemChildren[0]);
          }

          this.elem.layerElement.appendChild(g);
          this.masker = mask;
          groupPath.setAttribute('stroke', '#fff');
        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (this.filterManager.effectElements[10].p.v === 2) {
            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;

            while (elemChildren.length) {
              this.elem.layerElement.removeChild(elemChildren[0]);
            }
          }

          this.elem.layerElement.appendChild(groupPath);
          this.elem.layerElement.removeAttribute('mask');
          groupPath.setAttribute('stroke', '#fff');
        }

        this.initialized = true;
        this.pathMasker = groupPath;
      };

      SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
        if (!this.initialized) {
          this.initialize();
        }

        var i;
        var len = this.paths.length;
        var mask;
        var path;

        for (i = 0; i < len; i += 1) {
          if (this.paths[i].m !== -1) {
            mask = this.elem.maskManager.viewData[this.paths[i].m];
            path = this.paths[i].p;

            if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
              path.setAttribute('d', mask.lastPath);
            }

            if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
              var dasharrayValue;

              if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                var l = path.getTotalLength();
                dasharrayValue = '0 0 0 ' + l * s + ' ';
                var lineLength = l * (e - s);
                var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                var units = Math.floor(lineLength / segment);
                var j;

                for (j = 0; j < units; j += 1) {
                  dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
                }

                dasharrayValue += '0 ' + l * 10 + ' 0 0';
              } else {
                dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              }

              path.setAttribute('stroke-dasharray', dasharrayValue);
            }
          }
        }

        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
        }

        if (forceRender || this.filterManager.effectElements[6].p._mdf) {
          this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
        }

        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
          if (forceRender || this.filterManager.effectElements[3].p._mdf) {
            var color = this.filterManager.effectElements[3].p.v;
            this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
          }
        }
      };

      function SVGTritoneFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
        feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
        filter.appendChild(feColorMatrix);
        var feComponentTransfer = createNS('feComponentTransfer');
        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
        feComponentTransfer.setAttribute('result', id);
        this.matrixFilter = feComponentTransfer;
        var feFuncR = createNS('feFuncR');
        feFuncR.setAttribute('type', 'table');
        feComponentTransfer.appendChild(feFuncR);
        this.feFuncR = feFuncR;
        var feFuncG = createNS('feFuncG');
        feFuncG.setAttribute('type', 'table');
        feComponentTransfer.appendChild(feFuncG);
        this.feFuncG = feFuncG;
        var feFuncB = createNS('feFuncB');
        feFuncB.setAttribute('type', 'table');
        feComponentTransfer.appendChild(feFuncB);
        this.feFuncB = feFuncB;
        filter.appendChild(feComponentTransfer);
      }

      SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var color1 = this.filterManager.effectElements[0].p.v;
          var color2 = this.filterManager.effectElements[1].p.v;
          var color3 = this.filterManager.effectElements[2].p.v;
          var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
          var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
          var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
          this.feFuncR.setAttribute('tableValues', tableR);
          this.feFuncG.setAttribute('tableValues', tableG);
          this.feFuncB.setAttribute('tableValues', tableB);
        }
      };

      function SVGProLevelsFilter(filter, filterManager, elem, id) {
        this.filterManager = filterManager;
        var effectElements = this.filterManager.effectElements;
        var feComponentTransfer = createNS('feComponentTransfer'); // Red

        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
          this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
        } // Green


        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
          this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
        } // Blue


        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
          this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
        } // Alpha


        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
          this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
        } // RGB


        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
          feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
          filter.appendChild(feComponentTransfer);
        }

        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
          feComponentTransfer = createNS('feComponentTransfer');
          feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
          feComponentTransfer.setAttribute('result', id);
          filter.appendChild(feComponentTransfer);
          this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
          this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
          this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
        }
      }

      SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
        var feFunc = createNS(type);
        feFunc.setAttribute('type', 'table');
        feComponentTransfer.appendChild(feFunc);
        return feFunc;
      };

      SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
        var cnt = 0;
        var segments = 256;
        var perc;
        var min = Math.min(inputBlack, inputWhite);
        var max = Math.max(inputBlack, inputWhite);
        var table = Array.call(null, {
          length: segments
        });
        var colorValue;
        var pos = 0;
        var outputDelta = outputWhite - outputBlack;
        var inputDelta = inputWhite - inputBlack;

        while (cnt <= 256) {
          perc = cnt / 256;

          if (perc <= min) {
            colorValue = inputDelta < 0 ? outputWhite : outputBlack;
          } else if (perc >= max) {
            colorValue = inputDelta < 0 ? outputBlack : outputWhite;
          } else {
            colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
          }

          table[pos] = colorValue;
          pos += 1;
          cnt += 256 / (segments - 1);
        }

        return table.join(' ');
      };

      SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          var val;
          var effectElements = this.filterManager.effectElements;

          if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
            val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
            this.feFuncRComposed.setAttribute('tableValues', val);
            this.feFuncGComposed.setAttribute('tableValues', val);
            this.feFuncBComposed.setAttribute('tableValues', val);
          }

          if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
            val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
            this.feFuncR.setAttribute('tableValues', val);
          }

          if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
            val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
            this.feFuncG.setAttribute('tableValues', val);
          }

          if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
            val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
            this.feFuncB.setAttribute('tableValues', val);
          }

          if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
            val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
            this.feFuncA.setAttribute('tableValues', val);
          }
        }
      };

      function SVGDropShadowEffect(filter, filterManager, elem, id, source) {
        var filterSize = filterManager.container.globalData.renderConfig.filterSize;
        filter.setAttribute('x', filterSize.x);
        filter.setAttribute('y', filterSize.y);
        filter.setAttribute('width', filterSize.width);
        filter.setAttribute('height', filterSize.height);
        this.filterManager = filterManager;
        var feGaussianBlur = createNS('feGaussianBlur');
        feGaussianBlur.setAttribute('in', 'SourceAlpha');
        feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');
        feGaussianBlur.setAttribute('stdDeviation', '0');
        this.feGaussianBlur = feGaussianBlur;
        filter.appendChild(feGaussianBlur);
        var feOffset = createNS('feOffset');
        feOffset.setAttribute('dx', '25');
        feOffset.setAttribute('dy', '0');
        feOffset.setAttribute('in', id + '_drop_shadow_1');
        feOffset.setAttribute('result', id + '_drop_shadow_2');
        this.feOffset = feOffset;
        filter.appendChild(feOffset);
        var feFlood = createNS('feFlood');
        feFlood.setAttribute('flood-color', '#00ff00');
        feFlood.setAttribute('flood-opacity', '1');
        feFlood.setAttribute('result', id + '_drop_shadow_3');
        this.feFlood = feFlood;
        filter.appendChild(feFlood);
        var feComposite = createNS('feComposite');
        feComposite.setAttribute('in', id + '_drop_shadow_3');
        feComposite.setAttribute('in2', id + '_drop_shadow_2');
        feComposite.setAttribute('operator', 'in');
        feComposite.setAttribute('result', id + '_drop_shadow_4');
        filter.appendChild(feComposite);
        var feMerge = this.createMergeNode(id, [id + '_drop_shadow_4', source]);
        filter.appendChild(feMerge); //
      }

      extendPrototype([SVGComposableEffect], SVGDropShadowEffect);

      SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
          }

          if (forceRender || this.filterManager.effectElements[0].p._mdf) {
            var col = this.filterManager.effectElements[0].p.v;
            this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
          }

          if (forceRender || this.filterManager.effectElements[1].p._mdf) {
            this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
          }

          if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
            var distance = this.filterManager.effectElements[3].p.v;
            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
            var x = distance * Math.cos(angle);
            var y = distance * Math.sin(angle);
            this.feOffset.setAttribute('dx', x);
            this.feOffset.setAttribute('dy', y);
          }
        }
      };

      var _svgMatteSymbols = [];

      function SVGMatte3Effect(filterElem, filterManager, elem) {
        this.initialized = false;
        this.filterManager = filterManager;
        this.filterElem = filterElem;
        this.elem = elem;
        elem.matteElement = createNS('g');
        elem.matteElement.appendChild(elem.layerElement);
        elem.matteElement.appendChild(elem.transformedElement);
        elem.baseElement = elem.matteElement;
      }

      SVGMatte3Effect.prototype.findSymbol = function (mask) {
        var i = 0;
        var len = _svgMatteSymbols.length;

        while (i < len) {
          if (_svgMatteSymbols[i] === mask) {
            return _svgMatteSymbols[i];
          }

          i += 1;
        }

        return null;
      };

      SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
        var parentNode = mask.layerElement.parentNode;

        if (!parentNode) {
          return;
        }

        var children = parentNode.children;
        var i = 0;
        var len = children.length;

        while (i < len) {
          if (children[i] === mask.layerElement) {
            break;
          }

          i += 1;
        }

        var nextChild;

        if (i <= len - 2) {
          nextChild = children[i + 1];
        }

        var useElem = createNS('use');
        useElem.setAttribute('href', '#' + symbolId);

        if (nextChild) {
          parentNode.insertBefore(useElem, nextChild);
        } else {
          parentNode.appendChild(useElem);
        }
      };

      SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
        if (!this.findSymbol(mask)) {
          var symbolId = createElementID();
          var masker = createNS('mask');
          masker.setAttribute('id', mask.layerId);
          masker.setAttribute('mask-type', 'alpha');

          _svgMatteSymbols.push(mask);

          var defs = elem.globalData.defs;
          defs.appendChild(masker);
          var symbol = createNS('symbol');
          symbol.setAttribute('id', symbolId);
          this.replaceInParent(mask, symbolId);
          symbol.appendChild(mask.layerElement);
          defs.appendChild(symbol);
          var useElem = createNS('use');
          useElem.setAttribute('href', '#' + symbolId);
          masker.appendChild(useElem);
          mask.data.hd = false;
          mask.show();
        }

        elem.setMatte(mask.layerId);
      };

      SVGMatte3Effect.prototype.initialize = function () {
        var ind = this.filterManager.effectElements[0].p.v;
        var elements = this.elem.comp.elements;
        var i = 0;
        var len = elements.length;

        while (i < len) {
          if (elements[i] && elements[i].data.ind === ind) {
            this.setElementAsMask(this.elem, elements[i]);
          }

          i += 1;
        }

        this.initialized = true;
      };

      SVGMatte3Effect.prototype.renderFrame = function () {
        if (!this.initialized) {
          this.initialize();
        }
      };

      function SVGGaussianBlurEffect(filter, filterManager, elem, id) {
        // Outset the filter region by 100% on all sides to accommodate blur expansion.
        filter.setAttribute('x', '-100%');
        filter.setAttribute('y', '-100%');
        filter.setAttribute('width', '300%');
        filter.setAttribute('height', '300%');
        this.filterManager = filterManager;
        var feGaussianBlur = createNS('feGaussianBlur');
        feGaussianBlur.setAttribute('result', id);
        filter.appendChild(feGaussianBlur);
        this.feGaussianBlur = feGaussianBlur;
      }

      SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
        if (forceRender || this.filterManager._mdf) {
          // Empirical value, matching AE's blur appearance.
          var kBlurrinessToSigma = 0.3;
          var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:
          //
          //   1 -> horizontal & vertical
          //   2 -> horizontal only
          //   3 -> vertical only
          //

          var dimensions = this.filterManager.effectElements[1].p.v;
          var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq

          var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq

          this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY); // Repeat edges mapping:
          //
          //   0 -> off -> duplicate
          //   1 -> on  -> wrap

          var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq

          this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
        }
      };

      registerRenderer('canvas', CanvasRenderer);
      registerRenderer('html', HybridRenderer);
      registerRenderer('svg', SVGRenderer); // Registering shape modifiers

      ShapeModifiers.registerModifier('tm', TrimModifier);
      ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);
      ShapeModifiers.registerModifier('rp', RepeaterModifier);
      ShapeModifiers.registerModifier('rd', RoundCornersModifier); // Registering expression plugin

      setExpressionsPlugin(Expressions);
      initialize$1();
      initialize(); // Registering svg effects

      registerEffect(20, SVGTintFilter, true);
      registerEffect(21, SVGFillFilter, true);
      registerEffect(22, SVGStrokeEffect, false);
      registerEffect(23, SVGTritoneFilter, true);
      registerEffect(24, SVGProLevelsFilter, true);
      registerEffect(25, SVGDropShadowEffect, true);
      registerEffect(28, SVGMatte3Effect, false);
      registerEffect(29, SVGGaussianBlurEffect, true);

      return lottie;

    }));
    });

    /* node_modules\@lottiefiles\svelte-lottie-player\src\components\ColorPicker.svelte generated by Svelte v3.48.0 */
    const file$o = "node_modules\\@lottiefiles\\svelte-lottie-player\\src\\components\\ColorPicker.svelte";

    function create_fragment$o(ctx) {
    	let div7;
    	let div3;
    	let div0;
    	let strong0;
    	let t1;
    	let input0;
    	let t2;
    	let input1;
    	let t3;
    	let div1;
    	let strong1;
    	let t5;
    	let input2;
    	let t6;
    	let input3;
    	let t7;
    	let div2;
    	let strong2;
    	let t9;
    	let input4;
    	let t10;
    	let input5;
    	let t11;
    	let div6;
    	let div4;
    	let t12;
    	let div5;
    	let input6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			strong0 = element("strong");
    			strong0.textContent = "Red";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			input1 = element("input");
    			t3 = space();
    			div1 = element("div");
    			strong1 = element("strong");
    			strong1.textContent = "Green";
    			t5 = space();
    			input2 = element("input");
    			t6 = space();
    			input3 = element("input");
    			t7 = space();
    			div2 = element("div");
    			strong2 = element("strong");
    			strong2.textContent = "Blue";
    			t9 = space();
    			input4 = element("input");
    			t10 = space();
    			input5 = element("input");
    			t11 = space();
    			div6 = element("div");
    			div4 = element("div");
    			t12 = space();
    			div5 = element("div");
    			input6 = element("input");
    			attr_dev(strong0, "class", "svelte-w9go3q");
    			add_location(strong0, file$o, 119, 6, 2291);
    			attr_dev(input0, "type", "range");
    			attr_dev(input0, "min", "0");
    			attr_dev(input0, "max", "255");
    			attr_dev(input0, "class", "svelte-w9go3q");
    			add_location(input0, file$o, 120, 6, 2318);
    			attr_dev(input1, "class", "text-input svelte-w9go3q");
    			attr_dev(input1, "type", "number");
    			add_location(input1, file$o, 121, 6, 2382);
    			attr_dev(div0, "class", "color-component svelte-w9go3q");
    			add_location(div0, file$o, 118, 4, 2255);
    			attr_dev(strong1, "class", "svelte-w9go3q");
    			add_location(strong1, file$o, 124, 6, 2493);
    			attr_dev(input2, "type", "range");
    			attr_dev(input2, "min", "0");
    			attr_dev(input2, "max", "255");
    			attr_dev(input2, "class", "svelte-w9go3q");
    			add_location(input2, file$o, 125, 6, 2522);
    			attr_dev(input3, "class", "text-input svelte-w9go3q");
    			attr_dev(input3, "type", "number");
    			add_location(input3, file$o, 126, 6, 2588);
    			attr_dev(div1, "class", "color-component svelte-w9go3q");
    			add_location(div1, file$o, 123, 4, 2457);
    			attr_dev(strong2, "class", "svelte-w9go3q");
    			add_location(strong2, file$o, 129, 6, 2701);
    			attr_dev(input4, "type", "range");
    			attr_dev(input4, "min", "0");
    			attr_dev(input4, "max", "255");
    			attr_dev(input4, "class", "svelte-w9go3q");
    			add_location(input4, file$o, 130, 6, 2729);
    			attr_dev(input5, "class", "text-input svelte-w9go3q");
    			attr_dev(input5, "type", "number");
    			add_location(input5, file$o, 131, 6, 2794);
    			attr_dev(div2, "class", "color-component svelte-w9go3q");
    			add_location(div2, file$o, 128, 4, 2665);
    			attr_dev(div3, "class", "color-selectors svelte-w9go3q");
    			add_location(div3, file$o, 117, 2, 2221);
    			attr_dev(div4, "class", "preview svelte-w9go3q");
    			set_style(div4, "background", /*rgb*/ ctx[4]);
    			add_location(div4, file$o, 135, 4, 2909);
    			attr_dev(input6, "class", "text-input svelte-w9go3q");
    			attr_dev(input6, "type", "text");
    			input6.value = /*hex*/ ctx[3];
    			add_location(input6, file$o, 137, 6, 2975);
    			add_location(div5, file$o, 136, 4, 2963);
    			attr_dev(div6, "class", "color-preview svelte-w9go3q");
    			add_location(div6, file$o, 134, 2, 2877);
    			attr_dev(div7, "class", "color-picker svelte-w9go3q");
    			add_location(div7, file$o, 116, 0, 2192);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div3);
    			append_dev(div3, div0);
    			append_dev(div0, strong0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			set_input_value(input0, /*red*/ ctx[0]);
    			append_dev(div0, t2);
    			append_dev(div0, input1);
    			set_input_value(input1, /*red*/ ctx[0]);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, strong1);
    			append_dev(div1, t5);
    			append_dev(div1, input2);
    			set_input_value(input2, /*green*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, input3);
    			set_input_value(input3, /*green*/ ctx[1]);
    			append_dev(div3, t7);
    			append_dev(div3, div2);
    			append_dev(div2, strong2);
    			append_dev(div2, t9);
    			append_dev(div2, input4);
    			set_input_value(input4, /*blue*/ ctx[2]);
    			append_dev(div2, t10);
    			append_dev(div2, input5);
    			set_input_value(input5, /*blue*/ ctx[2]);
    			append_dev(div7, t11);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			append_dev(div6, t12);
    			append_dev(div6, div5);
    			append_dev(div5, input6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_input_handler*/ ctx[7]),
    					listen_dev(input0, "input", /*input0_change_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input2, "change", /*input2_change_input_handler*/ ctx[9]),
    					listen_dev(input2, "input", /*input2_change_input_handler*/ ctx[9]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[10]),
    					listen_dev(input4, "change", /*input4_change_input_handler*/ ctx[11]),
    					listen_dev(input4, "input", /*input4_change_input_handler*/ ctx[11]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[12]),
    					listen_dev(input6, "change", /*change_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*red*/ 1) {
    				set_input_value(input0, /*red*/ ctx[0]);
    			}

    			if (dirty & /*red*/ 1 && to_number(input1.value) !== /*red*/ ctx[0]) {
    				set_input_value(input1, /*red*/ ctx[0]);
    			}

    			if (dirty & /*green*/ 2) {
    				set_input_value(input2, /*green*/ ctx[1]);
    			}

    			if (dirty & /*green*/ 2 && to_number(input3.value) !== /*green*/ ctx[1]) {
    				set_input_value(input3, /*green*/ ctx[1]);
    			}

    			if (dirty & /*blue*/ 4) {
    				set_input_value(input4, /*blue*/ ctx[2]);
    			}

    			if (dirty & /*blue*/ 4 && to_number(input5.value) !== /*blue*/ ctx[2]) {
    				set_input_value(input5, /*blue*/ ctx[2]);
    			}

    			if (dirty & /*rgb*/ 16) {
    				set_style(div4, "background", /*rgb*/ ctx[4]);
    			}

    			if (dirty & /*hex*/ 8 && input6.value !== /*hex*/ ctx[3]) {
    				prop_dev(input6, "value", /*hex*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let rgb;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ColorPicker', slots, []);
    	const dispatch = createEventDispatcher();
    	let { color } = $$props;
    	let red = 0;
    	let green = 0;
    	let blue = 0;
    	let rgba = null;
    	let hex = null;

    	const parseColor = input => {
    		if (typeof input !== "string") {
    			return;
    		}

    		let colorComponents = [];

    		if (input[0] === "#") {
    			colorComponents = input.length === 4
    			? [input.slice(1, 2), input.slice(2, 3), input.slice(3, 4)].map(n => parseInt(`${n}${n}`, 16))
    			: [input.slice(1, 3), input.slice(3, 5), input.slice(5, 7)].map(n => parseInt(n, 16));
    		} else if (input.startsWith("rgb")) {
    			colorComponents = input.match(/\d+/g).map(n => parseInt(n));
    		}

    		if (colorComponents.length) {
    			$$invalidate(0, red = colorComponents[0]);
    			$$invalidate(1, green = colorComponents[1]);
    			$$invalidate(2, blue = colorComponents[2]);
    		}
    	};

    	const writable_props = ['color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColorPicker> was created with unknown prop '${key}'`);
    	});

    	function input0_change_input_handler() {
    		red = to_number(this.value);
    		$$invalidate(0, red);
    	}

    	function input1_input_handler() {
    		red = to_number(this.value);
    		$$invalidate(0, red);
    	}

    	function input2_change_input_handler() {
    		green = to_number(this.value);
    		$$invalidate(1, green);
    	}

    	function input3_input_handler() {
    		green = to_number(this.value);
    		$$invalidate(1, green);
    	}

    	function input4_change_input_handler() {
    		blue = to_number(this.value);
    		$$invalidate(2, blue);
    	}

    	function input5_input_handler() {
    		blue = to_number(this.value);
    		$$invalidate(2, blue);
    	}

    	const change_handler = e => parseColor(e.target.value);

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		color,
    		red,
    		green,
    		blue,
    		rgba,
    		hex,
    		parseColor,
    		rgb
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('red' in $$props) $$invalidate(0, red = $$props.red);
    		if ('green' in $$props) $$invalidate(1, green = $$props.green);
    		if ('blue' in $$props) $$invalidate(2, blue = $$props.blue);
    		if ('rgba' in $$props) rgba = $$props.rgba;
    		if ('hex' in $$props) $$invalidate(3, hex = $$props.hex);
    		if ('rgb' in $$props) $$invalidate(4, rgb = $$props.rgb);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color*/ 64) {
    			parseColor(color);
    		}

    		if ($$self.$$.dirty & /*red, green, blue*/ 7) {
    			$$invalidate(3, hex = "#" + (red | 1 << 8).toString(16).slice(1) + (green | 1 << 8).toString(16).slice(1) + (blue | 1 << 8).toString(16).slice(1));
    		}

    		if ($$self.$$.dirty & /*red, green, blue*/ 7) {
    			$$invalidate(4, rgb = `rgb(${red}, ${green}, ${blue})`);
    		}

    		if ($$self.$$.dirty & /*hex, rgb*/ 24) {
    			{
    				dispatch("color", { hex, rgb });
    			}
    		}
    	};

    	return [
    		red,
    		green,
    		blue,
    		hex,
    		rgb,
    		parseColor,
    		color,
    		input0_change_input_handler,
    		input1_input_handler,
    		input2_change_input_handler,
    		input3_input_handler,
    		input4_change_input_handler,
    		input5_input_handler,
    		change_handler
    	];
    }

    class ColorPicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$o, safe_not_equal, { color: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorPicker",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*color*/ ctx[6] === undefined && !('color' in props)) {
    			console.warn("<ColorPicker> was created without expected prop 'color'");
    		}
    	}

    	get color() {
    		throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@lottiefiles\svelte-lottie-player\src\components\Info.svelte generated by Svelte v3.48.0 */

    const file$n = "node_modules\\@lottiefiles\\svelte-lottie-player\\src\\components\\Info.svelte";

    // (64:0) {#if version}
    function create_if_block_10$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Lottie Version";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*version*/ ctx[9]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 65, 4, 1272);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 66, 4, 1318);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 64, 2, 1245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*version*/ 512) set_data_dev(t2, /*version*/ ctx[9]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(64:0) {#if version}",
    		ctx
    	});

    	return block;
    }

    // (71:0) {#if numFrames}
    function create_if_block_9$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Frames";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numFrames*/ ctx[6]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 72, 4, 1416);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 73, 4, 1454);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 71, 2, 1389);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numFrames*/ 64) set_data_dev(t2, /*numFrames*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(71:0) {#if numFrames}",
    		ctx
    	});

    	return block;
    }

    // (78:0) {#if frameRate}
    function create_if_block_8$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Frame Rate";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*frameRate*/ ctx[1]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 79, 4, 1554);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 80, 4, 1596);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 78, 2, 1527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*frameRate*/ 2) set_data_dev(t2, /*frameRate*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(78:0) {#if frameRate}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if numLayers}
    function create_if_block_7$2(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Layers";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numLayers*/ ctx[7]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 86, 4, 1696);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 87, 4, 1734);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 85, 2, 1669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numLayers*/ 128) set_data_dev(t2, /*numLayers*/ ctx[7]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(85:0) {#if numLayers}",
    		ctx
    	});

    	return block;
    }

    // (92:0) {#if numAssets}
    function create_if_block_6$3(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Assets";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numAssets*/ ctx[4]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 93, 4, 1834);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 94, 4, 1872);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 92, 2, 1807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numAssets*/ 16) set_data_dev(t2, /*numAssets*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(92:0) {#if numAssets}",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if numFonts}
    function create_if_block_5$3(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Fonts";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numFonts*/ ctx[5]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 100, 4, 1971);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 101, 4, 2008);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 99, 2, 1944);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numFonts*/ 32) set_data_dev(t2, /*numFonts*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(99:0) {#if numFonts}",
    		ctx
    	});

    	return block;
    }

    // (106:0) {#if hasMeta}
    function create_if_block$8(ctx) {
    	let hr;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let if_block3_anchor;
    	let if_block0 = /*generator*/ ctx[2] && create_if_block_4$4(ctx);
    	let if_block1 = /*author*/ ctx[0] && create_if_block_3$4(ctx);
    	let if_block2 = /*keywords*/ ctx[3] && create_if_block_2$4(ctx);
    	let if_block3 = /*themeColor*/ ctx[8] && create_if_block_1$6(ctx);

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    			add_location(hr, file$n, 106, 2, 2078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*generator*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$4(ctx);
    					if_block0.c();
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*author*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$4(ctx);
    					if_block1.c();
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*keywords*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_2$4(ctx);
    					if_block2.c();
    					if_block2.m(t3.parentNode, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*themeColor*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$6(ctx);
    					if_block3.c();
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(106:0) {#if hasMeta}",
    		ctx
    	});

    	return block;
    }

    // (109:2) {#if generator}
    function create_if_block_4$4(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Generator";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*generator*/ ctx[2]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 110, 6, 2137);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 111, 6, 2180);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 109, 4, 2108);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*generator*/ 4) set_data_dev(t2, /*generator*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(109:2) {#if generator}",
    		ctx
    	});

    	return block;
    }

    // (116:2) {#if author}
    function create_if_block_3$4(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Author";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*author*/ ctx[0]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 117, 6, 2287);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 118, 6, 2327);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 116, 4, 2258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*author*/ 1) set_data_dev(t2, /*author*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(116:2) {#if author}",
    		ctx
    	});

    	return block;
    }

    // (123:2) {#if keywords}
    function create_if_block_2$4(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Keywords";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*keywords*/ ctx[3]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 124, 6, 2433);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 125, 6, 2475);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 123, 4, 2404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*keywords*/ 8) set_data_dev(t2, /*keywords*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(123:2) {#if keywords}",
    		ctx
    	});

    	return block;
    }

    // (130:2) {#if themeColor}
    function create_if_block_1$6(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Theme Color";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*themeColor*/ ctx[8]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$n, 131, 6, 2585);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$n, 132, 6, 2630);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$n, 130, 4, 2556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*themeColor*/ 256) set_data_dev(t2, /*themeColor*/ ctx[8]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(130:2) {#if themeColor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let h4;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let if_block6_anchor;
    	let if_block0 = /*version*/ ctx[9] && create_if_block_10$1(ctx);
    	let if_block1 = /*numFrames*/ ctx[6] && create_if_block_9$1(ctx);
    	let if_block2 = /*frameRate*/ ctx[1] && create_if_block_8$1(ctx);
    	let if_block3 = /*numLayers*/ ctx[7] && create_if_block_7$2(ctx);
    	let if_block4 = /*numAssets*/ ctx[4] && create_if_block_6$3(ctx);
    	let if_block5 = /*numFonts*/ ctx[5] && create_if_block_5$3(ctx);
    	let if_block6 = /*hasMeta*/ ctx[10] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Info";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (if_block5) if_block5.c();
    			t7 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(h4, "class", "svelte-1gm5gmt");
    			add_location(h4, file$n, 61, 0, 1214);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t7, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*version*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*numFrames*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$1(ctx);
    					if_block1.c();
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*frameRate*/ ctx[1]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8$1(ctx);
    					if_block2.c();
    					if_block2.m(t4.parentNode, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*numLayers*/ ctx[7]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_7$2(ctx);
    					if_block3.c();
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*numAssets*/ ctx[4]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_6$3(ctx);
    					if_block4.c();
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*numFonts*/ ctx[5]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_5$3(ctx);
    					if_block5.c();
    					if_block5.m(t7.parentNode, t7);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*hasMeta*/ ctx[10]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);
    				} else {
    					if_block6 = create_if_block$8(ctx);
    					if_block6.c();
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info', slots, []);
    	let { animationData } = $$props;
    	let author;
    	let frameRate;
    	let generator;
    	let keywords;
    	let numAssets;
    	let numFonts;
    	let numFrames;
    	let numLayers;
    	let themeColor;
    	let version;
    	let hasMeta = false;
    	const writable_props = ['animationData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('animationData' in $$props) $$invalidate(11, animationData = $$props.animationData);
    	};

    	$$self.$capture_state = () => ({
    		animationData,
    		author,
    		frameRate,
    		generator,
    		keywords,
    		numAssets,
    		numFonts,
    		numFrames,
    		numLayers,
    		themeColor,
    		version,
    		hasMeta
    	});

    	$$self.$inject_state = $$props => {
    		if ('animationData' in $$props) $$invalidate(11, animationData = $$props.animationData);
    		if ('author' in $$props) $$invalidate(0, author = $$props.author);
    		if ('frameRate' in $$props) $$invalidate(1, frameRate = $$props.frameRate);
    		if ('generator' in $$props) $$invalidate(2, generator = $$props.generator);
    		if ('keywords' in $$props) $$invalidate(3, keywords = $$props.keywords);
    		if ('numAssets' in $$props) $$invalidate(4, numAssets = $$props.numAssets);
    		if ('numFonts' in $$props) $$invalidate(5, numFonts = $$props.numFonts);
    		if ('numFrames' in $$props) $$invalidate(6, numFrames = $$props.numFrames);
    		if ('numLayers' in $$props) $$invalidate(7, numLayers = $$props.numLayers);
    		if ('themeColor' in $$props) $$invalidate(8, themeColor = $$props.themeColor);
    		if ('version' in $$props) $$invalidate(9, version = $$props.version);
    		if ('hasMeta' in $$props) $$invalidate(10, hasMeta = $$props.hasMeta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animationData*/ 2048) {
    			{
    				if (animationData) {
    					$$invalidate(1, frameRate = animationData.fr);
    					$$invalidate(4, numAssets = animationData.assets ? animationData.assets.length : 0);
    					$$invalidate(5, numFonts = animationData.fonts ? animationData.fonts.length : 0);
    					$$invalidate(6, numFrames = animationData.op - animationData.ip);
    					$$invalidate(7, numLayers = animationData.layers ? animationData.layers.length : 0);
    					$$invalidate(9, version = animationData.v);

    					if (animationData.meta) {
    						$$invalidate(10, hasMeta = true);
    						$$invalidate(0, author = animationData.meta.a);
    						$$invalidate(2, generator = animationData.meta.g);
    						$$invalidate(3, keywords = animationData.meta.k);
    						$$invalidate(8, themeColor = animationData.meta.tc);
    					}
    				}
    			}
    		}
    	};

    	return [
    		author,
    		frameRate,
    		generator,
    		keywords,
    		numAssets,
    		numFonts,
    		numFrames,
    		numLayers,
    		themeColor,
    		version,
    		hasMeta,
    		animationData
    	];
    }

    class Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$n, safe_not_equal, { animationData: 11 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*animationData*/ ctx[11] === undefined && !('animationData' in props)) {
    			console.warn("<Info> was created without expected prop 'animationData'");
    		}
    	}

    	get animationData() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animationData(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@lottiefiles\svelte-lottie-player\src\components\Popover.svelte generated by Svelte v3.48.0 */
    const file$m = "node_modules\\@lottiefiles\\svelte-lottie-player\\src\\components\\Popover.svelte";
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_target_slot_changes = dirty => ({});
    const get_target_slot_context = ctx => ({});

    function create_fragment$m(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let t1;
    	let div1;
    	let current;
    	let mounted;
    	let dispose;
    	const target_slot_template = /*#slots*/ ctx[8].target;
    	const target_slot = create_slot(target_slot_template, ctx, /*$$scope*/ ctx[7], get_target_slot_context);
    	const content_slot_template = /*#slots*/ ctx[8].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[7], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if (target_slot) target_slot.c();
    			t0 = space();
    			div2 = element("div");
    			if (content_slot) content_slot.c();
    			t1 = space();
    			div1 = element("div");
    			add_location(div0, file$m, 88, 2, 1540);
    			attr_dev(div1, "class", "arrow svelte-cq7jp3");
    			set_style(div1, "border-color", /*color*/ ctx[0] + " transparent transparent transparent");
    			add_location(div1, file$m, 98, 4, 1811);
    			attr_dev(div2, "class", "popover-content svelte-cq7jp3");
    			toggle_class(div2, "hidden", !/*_open*/ ctx[4]);
    			toggle_class(div2, "left-align", /*_alignment*/ ctx[3] !== -1);
    			toggle_class(div2, "right-align", /*_alignment*/ ctx[3] === -1);
    			add_location(div2, file$m, 91, 2, 1608);
    			attr_dev(div3, "class", "popover svelte-cq7jp3");
    			add_location(div3, file$m, 81, 0, 1427);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);

    			if (target_slot) {
    				target_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[12](div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div2_binding*/ ctx[13](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "mousedown", /*mousedown_handler*/ ctx[9], false, false, false),
    					listen_dev(div3, "mouseover", /*show*/ ctx[5], false, false, false),
    					listen_dev(div3, "mouseout", /*hide*/ ctx[6], false, false, false),
    					listen_dev(div3, "mouseup", /*mouseup_handler*/ ctx[10], false, false, false),
    					listen_dev(div3, "mousewheel", /*mousewheel_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (target_slot) {
    				if (target_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						target_slot,
    						target_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(target_slot_template, /*$$scope*/ ctx[7], dirty, get_target_slot_changes),
    						get_target_slot_context
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[7], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*color*/ 1) {
    				set_style(div1, "border-color", /*color*/ ctx[0] + " transparent transparent transparent");
    			}

    			if (dirty & /*_open*/ 16) {
    				toggle_class(div2, "hidden", !/*_open*/ ctx[4]);
    			}

    			if (dirty & /*_alignment*/ 8) {
    				toggle_class(div2, "left-align", /*_alignment*/ ctx[3] !== -1);
    			}

    			if (dirty & /*_alignment*/ 8) {
    				toggle_class(div2, "right-align", /*_alignment*/ ctx[3] === -1);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(target_slot, local);
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(target_slot, local);
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (target_slot) target_slot.d(detaching);
    			/*div0_binding*/ ctx[12](null);
    			if (content_slot) content_slot.d(detaching);
    			/*div2_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Popover', slots, ['target','content']);
    	let { color = "transparent" } = $$props;
    	let _triggerRef;
    	let _contentRef;
    	let _alignment;
    	let _open = true;

    	onMount(() => {
    		const triggerBounds = _triggerRef.getBoundingClientRect();
    		const contentBounds = _contentRef.getBoundingClientRect();

    		$$invalidate(3, _alignment = triggerBounds.left + contentBounds.width > window.innerWidth
    		? -1
    		: 0);

    		$$invalidate(2, _contentRef.style.bottom = triggerBounds.height + "px", _contentRef);

    		// Start with content box hidden
    		hide();
    	});

    	/**
     * Show content box
     */
    	const show = () => {
    		$$invalidate(4, _open = true);
    	};

    	/**
     * Hide content box
     */
    	const hide = () => {
    		$$invalidate(4, _open = false);
    	};

    	const writable_props = ['color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Popover> was created with unknown prop '${key}'`);
    	});

    	function mousedown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mouseup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mousewheel_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_triggerRef = $$value;
    			$$invalidate(1, _triggerRef);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_contentRef = $$value;
    			$$invalidate(2, _contentRef);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		color,
    		_triggerRef,
    		_contentRef,
    		_alignment,
    		_open,
    		show,
    		hide
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('_triggerRef' in $$props) $$invalidate(1, _triggerRef = $$props._triggerRef);
    		if ('_contentRef' in $$props) $$invalidate(2, _contentRef = $$props._contentRef);
    		if ('_alignment' in $$props) $$invalidate(3, _alignment = $$props._alignment);
    		if ('_open' in $$props) $$invalidate(4, _open = $$props._open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		color,
    		_triggerRef,
    		_contentRef,
    		_alignment,
    		_open,
    		show,
    		hide,
    		$$scope,
    		slots,
    		mousedown_handler,
    		mouseup_handler,
    		mousewheel_handler,
    		div0_binding,
    		div2_binding
    	];
    }

    class Popover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$m, safe_not_equal, { color: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popover",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get color() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const PlayerRender = {
      SVG: 'svg',
      Canvas: 'canvas'
    };

    // Define valid player states
    const PlayerState = {
      Loading: 'loading',
      Playing: 'playing',
      Paused: 'paused',
      Stopped: 'stopped',
      Frozen: 'frozen',
      Error: 'error',
    };

    // Define play modes
    const PlayMode = {
      Normal: 'normal',
      Bounce: 'bounce',
    };

    // Define player events
    const PlayerEvents = {
      Load: 'load',
      Error: 'error',
      Ready: 'ready',
      Play: 'play',
      Pause: 'pause',
      Stop: 'stop',
      Freeze: 'freeze',
      Loop: 'loop',
      Complete: 'complete',
      Frame: 'frame',
    };

    // Define controls layout options
    const ControlsLayoutOptions = [
      "previousFrame",
      "playpause",
      "stop",
      "nextFrame",
      "progress",
      "frame",
      "loop",
      "spacer",
      "background",
      "snapshot",
      "info",
      "zoom"
    ];

    /**
     * Parse a resource into a JSON object or a URL string
     */
    const parseSrc = src => {
      if (typeof src === 'object') {
        return src;
      }

      try {
        return JSON.parse(src);
      } catch (e) {
        // Try construct an absolute URL from the src URL
        const srcUrl = new URL(src, window.location.href);

        return srcUrl.toString();
      }
    };

    /**
     * Trigger the download of the given data URI as a file
     *
     * @param {string} dataUri
     * @param {string} name
     */
    const triggerDownload = (dataUri, filename) => {
      const element = document.createElement('a');
      element.href = dataUri;
      element.download = filename;
      document.body.appendChild(element);

      element.click();

      document.body.removeChild(element);
    };

    /* node_modules\@lottiefiles\svelte-lottie-player\src\components\Controls.svelte generated by Svelte v3.48.0 */
    const file$l = "node_modules\\@lottiefiles\\svelte-lottie-player\\src\\components\\Controls.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[40] = list[i];
    	return child_ctx;
    }

    // (426:32) 
    function create_if_block_13(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spacer svelte-9yox50");
    			add_location(div, file$l, 426, 6, 13905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(426:32) ",
    		ctx
    	});

    	return block;
    }

    // (419:39) 
    function create_if_block_12(ctx) {
    	let div;
    	let svg;
    	let path;
    	let rect;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			rect = svg_element("rect");
    			t = space();
    			attr_dev(path, "d", "M22 4.5a1.4 1.4 0 00-2.1-1.2l-13 7.5a1.4 1.4 0 000 2.4l13 7.5a1.4 1.4 0 002.1-1.2z");
    			add_location(path, file$l, 421, 10, 13641);
    			attr_dev(rect, "height", "17.1");
    			attr_dev(rect, "rx", "1.4");
    			attr_dev(rect, "transform", "matrix(-1 0 0 1 7.7 3.4)");
    			attr_dev(rect, "width", "5.7");
    			add_location(rect, file$l, 422, 10, 13752);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 420, 8, 13610);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$l, 419, 6, 13556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(svg, rect);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*oPreviousFrame*/ ctx[24], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(419:39) ",
    		ctx
    	});

    	return block;
    }

    // (409:35) 
    function create_if_block_11(ctx) {
    	let div;
    	let svg;
    	let path;
    	let rect;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			rect = svg_element("rect");
    			t = space();
    			attr_dev(path, "d", "M2 19.513a1.429 1.429 0 0 0 2.148 1.234l12.88-7.513a1.429 1.429 0 0 0 0-2.468L4.147 3.253A1.429 1.429 0 0\n            0 2 4.487z");
    			add_location(path, file$l, 411, 10, 13204);
    			attr_dev(rect, "height", "17.143");
    			attr_dev(rect, "rx", "1.429");
    			attr_dev(rect, "transform", "matrix(1 0 0 -1 16.286 20.571)");
    			attr_dev(rect, "width", "5.714");
    			add_location(rect, file$l, 415, 10, 13384);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 410, 8, 13173);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$l, 409, 6, 13122);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(svg, rect);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onNextFrame*/ ctx[23], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(409:35) ",
    		ctx
    	});

    	return block;
    }

    // (397:31) 
    function create_if_block_10(ctx) {
    	let div;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			attr_dev(input, "class", "frame-number svelte-9yox50");
    			attr_dev(input, "type", "text");
    			add_location(input, file$l, 398, 8, 12677);
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$l, 397, 6, 12654);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*formattedFrame*/ ctx[15]);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[34]),
    					listen_dev(input, "mouseout", /*mouseout_handler_1*/ ctx[35], false, false, false),
    					listen_dev(input, "mouseover", /*mouseover_handler_1*/ ctx[36], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[37], false, false, false),
    					listen_dev(input, "mousewheel", /*mousewheel_handler_1*/ ctx[38], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*formattedFrame*/ 32768 && input.value !== /*formattedFrame*/ ctx[15]) {
    				set_input_value(input, /*formattedFrame*/ ctx[15]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(397:31) ",
    		ctx
    	});

    	return block;
    }

    // (372:30) 
    function create_if_block_9(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot_2],
    					target: [create_target_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$l, 372, 6, 11620);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*animationData*/ 2 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(372:30) ",
    		ctx
    	});

    	return block;
    }

    // (350:30) 
    function create_if_block_7$1(ctx) {
    	let div;
    	let t;
    	let mounted;
    	let dispose;

    	function select_block_type_2(ctx, dirty) {
    		if (/*isZoomed*/ ctx[14]) return create_if_block_8;
    		return create_else_block_1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t = space();
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$l, 350, 6, 10627);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onToggleZoom*/ ctx[22], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(350:30) ",
    		ctx
    	});

    	return block;
    }

    // (316:34) 
    function create_if_block_6$2(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot_1],
    					target: [create_target_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	popover.$on("mousewheel", /*mousewheel_handler*/ ctx[31]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$l, 316, 6, 8924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseout", /*mouseout_handler*/ ctx[32], false, false, false),
    					listen_dev(div, "mouseover", /*mouseover_handler*/ ctx[33], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*snapshot, formattedFrame*/ 33792 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(316:34) ",
    		ctx
    	});

    	return block;
    }

    // (297:36) 
    function create_if_block_5$2(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot],
    					target: [create_target_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$l, 297, 6, 7986);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*background*/ 4 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(297:36) ",
    		ctx
    	});

    	return block;
    }

    // (268:30) 
    function create_if_block_4$3(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t = space();
    			attr_dev(path0, "d", "M12.5 16.8137h-.13v1.8939h4.9696c3.6455 0 6.6113-2.9658 6.6113-6.6116\n            0-3.64549-2.9658-6.61131-6.6113-6.61131-.5231 0-.947.42391-.947.94696 0 .52304.4239.94696.947.94696 2.6011 0\n            4.7174 2.11634 4.7174 4.71739 0 2.6014-2.1166 4.7177-4.7174 4.7177H12.5zM13.6025\n            5.61469v-.13H7.48137C3.83582 5.48469.87 8.45051.87 12.096c0 3.6509 3.17269 6.6117 6.81304 6.6117.52304 0\n            .94696-.424.94696-.947 0-.5231-.42392-.947-.94696-.947-2.60804 0-4.91907-2.1231-4.91907-4.7176 0-2.60115\n            2.11634-4.71744 4.7174-4.71744h6.12113V5.61469z");
    			attr_dev(path0, "stroke", "#8795A1");
    			attr_dev(path0, "stroke-width", ".26");
    			add_location(path0, file$l, 270, 10, 6259);
    			attr_dev(path1, "d", "M11.1482\n            2.20355h0l-.001-.00116c-.3412-.40061-.9405-.44558-1.33668-.0996h-.00001c-.39526.34519-.43936.94795-.09898\n            1.34767l2.51487 3.03683-2.51894 3.06468c-.33872.40088-.29282 1.00363.10347\n            1.34723l.08517-.0982-.08517.0982c.17853.1549.39807.2308.61647.2308.2671 0 .5328-.114.72-.3347h0l.0011-.0014\n            3.0435-3.68655.0006-.00068c.3035-.35872.3025-.88754-.0019-1.24526l-3.0425-3.65786zM13.9453\n            21.7965h0l.001.0011c.3413.4006.9407.4456 1.337.0996h0c.3953-.3452.4395-.9479.099-1.3477l-2.5154-3.0368\n            2.5195-3.0647c.3388-.4008.2929-1.0036-.1035-1.3472l-.0852.0982.0852-.0982c-.1786-.1549-.3981-.2308-.6166-.2308-.2671\n            0-.5329.114-.7202.3347h0l-.0011.0014-3.0442\n            3.6865c-.0001.0003-.0003.0005-.0005.0007-.3036.3587-.3027.8876.0019 1.2453l3.0431 3.6579z");
    			attr_dev(path1, "fill", "#8795A1");
    			attr_dev(path1, "stroke", "#8795A1");
    			attr_dev(path1, "stroke-width", ".26");
    			add_location(path1, file$l, 280, 10, 6948);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 269, 8, 6228);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*loop*/ ctx[7]);
    			add_location(div, file$l, 268, 6, 6153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*toggleLooping*/ ctx[12])) /*toggleLooping*/ ctx[12].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);

    			if (dirty[0] & /*loop*/ 128) {
    				toggle_class(div, "active", /*loop*/ ctx[7]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(268:30) ",
    		ctx
    	});

    	return block;
    }

    // (252:34) 
    function create_if_block_3$3(ctx) {
    	let input;
    	let input_style_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "progress svelte-9yox50");
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "0");
    			attr_dev(input, "step", "1");
    			attr_dev(input, "max", "100");

    			attr_dev(input, "style", input_style_value = `
          background-image: -webkit-gradient(linear, left top, right top, color-stop(${/*progress*/ ctx[0]}%, rgba(15, 204, 206, 0.4)), color-stop(${/*progress*/ ctx[0]}%, #DAE1E7));
          background-image: -moz-linear-gradient(left center, rgba(15, 204, 206, 0.4) 0%, rgba(15, 204, 206, 0.4) ${/*progress*/ ctx[0]}%, #DAE1E7 ${/*progress*/ ctx[0]}%, #DAE1E7 100%);
        `);

    			add_location(input, file$l, 252, 6, 5516);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*progress*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[28]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[28]),
    					listen_dev(input, "input", /*onHandleSeekChange*/ ctx[20], false, false, false),
    					listen_dev(
    						input,
    						"mousedown",
    						function () {
    							if (is_function(/*freeze*/ ctx[5])) /*freeze*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						input,
    						"mouseup",
    						function () {
    							if (is_function(/*play*/ ctx[8])) /*play*/ ctx[8].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*progress*/ 1 && input_style_value !== (input_style_value = `
          background-image: -webkit-gradient(linear, left top, right top, color-stop(${/*progress*/ ctx[0]}%, rgba(15, 204, 206, 0.4)), color-stop(${/*progress*/ ctx[0]}%, #DAE1E7));
          background-image: -moz-linear-gradient(left center, rgba(15, 204, 206, 0.4) 0%, rgba(15, 204, 206, 0.4) ${/*progress*/ ctx[0]}%, #DAE1E7 ${/*progress*/ ctx[0]}%, #DAE1E7 100%);
        `)) {
    				attr_dev(input, "style", input_style_value);
    			}

    			if (dirty[0] & /*progress*/ 1) {
    				set_input_value(input, /*progress*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(252:34) ",
    		ctx
    	});

    	return block;
    }

    // (243:30) 
    function create_if_block_2$3(ctx) {
    	let div;
    	let svg;
    	let path;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = space();
    			attr_dev(path, "d", "M2 3.667A1.67 1.67 0 0 1 3.667 2h16.666A1.67 1.67 0 0 1 22 3.667v16.666A1.67 1.67 0 0 1 20.333\n            22H3.667A1.67 1.67 0 0 1 2 20.333z");
    			add_location(path, file$l, 245, 10, 5264);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 244, 8, 5233);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*isStopped*/ ctx[16]);
    			add_location(div, file$l, 243, 6, 5162);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*stop*/ ctx[11])) /*stop*/ ctx[11].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);

    			if (dirty[0] & /*isStopped*/ 65536) {
    				toggle_class(div, "active", /*isStopped*/ ctx[16]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(243:30) ",
    		ctx
    	});

    	return block;
    }

    // (230:4) {#if item === 'playpause'}
    function create_if_block$7(ctx) {
    	let div;
    	let t;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isPlaying*/ ctx[18]) return create_if_block_1$5;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t = space();
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*isPlaying*/ ctx[18] || /*isPaused*/ ctx[17]);
    			add_location(div, file$l, 230, 6, 4611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*togglePlay*/ ctx[13])) /*togglePlay*/ ctx[13].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t);
    				}
    			}

    			if (dirty[0] & /*isPlaying, isPaused*/ 393216) {
    				toggle_class(div, "active", /*isPlaying*/ ctx[18] || /*isPaused*/ ctx[17]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(230:4) {#if item === 'playpause'}",
    		ctx
    	});

    	return block;
    }

    // (375:10) 
    function create_target_slot_2(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill-rule", "evenodd");
    			attr_dev(path0, "clip-rule", "evenodd");
    			attr_dev(path0, "d", "M3.15 0h17.7A3.12 3.12 0 0124 3.1v17.8c0 1.71-1.4 3.1-3.15 3.1H3.15A3.12 3.12 0 010 20.9V3.1C0 1.39\n                1.4 0 3.15 0zm0 2.05c-.6 0-1.07.47-1.07 1.05v17.8c0 .58.48 1.05 1.07 1.05h17.7c.6 0 1.07-.47\n                1.07-1.05V3.1c0-.58-.48-1.05-1.07-1.05H3.15z");
    			add_location(path0, file$l, 376, 14, 11755);
    			attr_dev(path1, "fill-rule", "evenodd");
    			attr_dev(path1, "clip-rule", "evenodd");
    			attr_dev(path1, "d", "M12 10c.55 0 1 .42 1 .94v6.12c0 .52-.45.94-1 .94s-1-.42-1-.94v-6.12c0-.52.45-.94 1-.94zM12 6a1 1 0\n                011 1v.42a1 1 0 11-2 0V7a1 1 0 011-1z");
    			add_location(path1, file$l, 383, 14, 12160);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 375, 12, 11720);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$l, 374, 10, 11676);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot_2.name,
    		type: "slot",
    		source: "(375:10) ",
    		ctx
    	});

    	return block;
    }

    // (392:10) 
    function create_content_slot_2(ctx) {
    	let div;
    	let info;
    	let current;

    	info = new Info({
    			props: { animationData: /*animationData*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(info.$$.fragment);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-info svelte-9yox50");
    			add_location(div, file$l, 391, 10, 12480);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(info, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const info_changes = {};
    			if (dirty[0] & /*animationData*/ 2) info_changes.animationData = /*animationData*/ ctx[1];
    			info.$set(info_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(info);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_2.name,
    		type: "slot",
    		source: "(392:10) ",
    		ctx
    	});

    	return block;
    }

    // (361:8) {:else}
    function create_else_block_1(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M21 8a1 1 0 102 0V4a3 3 0 00-3-3h-4a1 1 0 100 2h4a1 1 0 011 1v4zM1 8a1 1 0 102 0V4a1 1 0 011-1h4a1 1 0\n              100-2H4a3 3 0 00-3 3v4zm15 15h4a3 3 0 003-3v-4a1 1 0 10-2 0v4a1 1 0 01-1 1h-4a1 1 0 100 2zM4 23h4a1 1 0\n              100-2H4a1 1 0 01-1-1v-4a1 1 0 10-2 0v4a3 3 0 003 3z");
    			attr_dev(path, "stroke-width", ".2");
    			add_location(path, file$l, 362, 12, 11175);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 361, 10, 11142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(361:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (352:8) {#if isZoomed}
    function create_if_block_8(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M7 22a1 1 0 102 0v-4a3 3 0 00-3-3H2a1 1 0 100 2h4a1 1 0 011 1v4zm8 0a1 1 0 102 0v-4a1 1 0 011-1h4a1 1 0\n              100-2h-4a3 3 0 00-3 3v4zM2 9h4a3 3 0 003-3V2a1 1 0 10-2 0v4a1 1 0 01-1 1H2a1 1 0 100 2zm16 0h4a1 1 0\n              100-2h-4a1 1 0 01-1-1V2a1 1 0 10-2 0v4a3 3 0 003 3z");
    			attr_dev(path, "stroke-width", ".2");
    			add_location(path, file$l, 353, 12, 10737);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 352, 10, 10704);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(352:8) {#if isZoomed}",
    		ctx
    	});

    	return block;
    }

    // (323:10) 
    function create_target_slot_1(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let circle;
    	let path2;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			circle = svg_element("circle");
    			path2 = svg_element("path");
    			attr_dev(path0, "clip-rule", "evenodd");
    			attr_dev(path0, "d", "M0 3.01A2.983 2.983 0 012.983.027H16.99a2.983 2.983 0 012.983 2.983v14.008a2.982 2.982 0 01-2.983\n                2.983H2.983A2.983 2.983 0 010 17.018zm2.983-.941a.941.941 0 00-.942.94v14.01c0\n                .52.422.94.942.94H16.99a.94.94 0 00.941-.94V3.008a.941.941 0 00-.94-.94H2.981z");
    			attr_dev(path0, "fill-rule", "evenodd");
    			add_location(path0, file$l, 324, 14, 9290);
    			attr_dev(path1, "d", "M12.229 7.945l-2.07 4.598-2.586-2.605-2.414 2.758v2.146h9.656V11.93z");
    			add_location(path1, file$l, 331, 14, 9713);
    			attr_dev(circle, "cx", "7.444");
    			attr_dev(circle, "cy", "6.513");
    			attr_dev(circle, "r", "2.032");
    			add_location(circle, file$l, 332, 14, 9814);
    			attr_dev(path2, "d", "M9.561 23.916h11.25a2.929 2.929 0 002.926-2.927V9.954a1.06 1.06 0 10-2.122 0v11.035a.805.805 0\n                01-.803.804H9.562a1.061 1.061 0 100 2.123z");
    			attr_dev(path2, "stroke", "#8795a1");
    			attr_dev(path2, "stroke-width", ".215");
    			add_location(path2, file$l, 333, 14, 9878);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 323, 12, 9255);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$l, 322, 10, 9211);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, circle);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot_1.name,
    		type: "slot",
    		source: "(323:10) ",
    		ctx
    	});

    	return block;
    }

    // (342:10) 
    function create_content_slot_1(ctx) {
    	let div;
    	let h5;
    	let t0;
    	let t1;
    	let t2;
    	let a0;
    	let t4;
    	let a1;
    	let t6;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			t0 = text("Frame ");
    			t1 = text(/*formattedFrame*/ ctx[15]);
    			t2 = space();
    			a0 = element("a");
    			a0.textContent = "Download SVG";
    			t4 = space();
    			a1 = element("a");
    			a1.textContent = "Download PNG";
    			t6 = space();
    			i = element("i");
    			i.textContent = "Scroll with mousewheel to find exact frame";
    			attr_dev(h5, "class", "svelte-9yox50");
    			add_location(h5, file$l, 342, 12, 10262);
    			attr_dev(a0, "href", "#downloadsvg");
    			attr_dev(a0, "class", "svelte-9yox50");
    			add_location(a0, file$l, 343, 12, 10306);
    			attr_dev(a1, "href", "#downloadsvg");
    			attr_dev(a1, "class", "svelte-9yox50");
    			add_location(a1, file$l, 344, 12, 10392);
    			attr_dev(i, "class", "note svelte-9yox50");
    			add_location(i, file$l, 345, 12, 10478);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-snapshot svelte-9yox50");
    			add_location(div, file$l, 341, 10, 10196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			append_dev(h5, t0);
    			append_dev(h5, t1);
    			append_dev(div, t2);
    			append_dev(div, a0);
    			append_dev(div, t4);
    			append_dev(div, a1);
    			append_dev(div, t6);
    			append_dev(div, i);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[29], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[30], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*formattedFrame*/ 32768) set_data_dev(t1, /*formattedFrame*/ ctx[15]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1.name,
    		type: "slot",
    		source: "(342:10) ",
    		ctx
    	});

    	return block;
    }

    // (300:10) 
    function create_target_slot(ctx) {
    	let div;
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12 3.1L6.1 8.6a7.6 7.6 0 00-2.2 4 7.2 7.2 0 00.4 4.4 7.9 7.9 0 003 3.5 8.7 8.7 0 004.7 1.3c1.6 0\n                3.2-.5 4.6-1.3s2.4-2 3-3.5a7.2 7.2 0 00.5-4.5 7.6 7.6 0 00-2.2-4L12 3.2zM12 0l7.5 7a9.8 9.8 0 013 5.1\n                9.3 9.3 0 01-.6 5.8c-.9 1.8-2.2 3.3-4 4.4A11.2 11.2 0 0112 24a11.2 11.2 0\n                01-6-1.7c-1.7-1-3-2.6-3.9-4.4a9.3 9.3 0 01-.6-5.8c.4-2 1.5-3.7 3-5L12 0zM6 14h12c0 1.5-.7 3-1.8 4s-2.6\n                1.6-4.2 1.6S9 19 7.8 18s-1.7-2.5-1.7-4z");
    			add_location(path, file$l, 301, 14, 8121);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 300, 12, 8086);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$l, 299, 10, 8042);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot.name,
    		type: "slot",
    		source: "(300:10) ",
    		ctx
    	});

    	return block;
    }

    // (311:10) 
    function create_content_slot(ctx) {
    	let div;
    	let colorpicker;
    	let current;

    	colorpicker = new ColorPicker({
    			props: { color: /*background*/ ctx[2] },
    			$$inline: true
    		});

    	colorpicker.$on("color", /*onSelectBackground*/ ctx[21]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(colorpicker.$$.fragment);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-background svelte-9yox50");
    			add_location(div, file$l, 310, 10, 8697);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(colorpicker, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const colorpicker_changes = {};
    			if (dirty[0] & /*background*/ 4) colorpicker_changes.color = /*background*/ ctx[2];
    			colorpicker.$set(colorpicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(colorpicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(colorpicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(colorpicker);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(311:10) ",
    		ctx
    	});

    	return block;
    }

    // (237:8) {:else}
    function create_else_block(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M2 3.4C2 1.9 3.5 1 4.8 1.8l16.5 9.6c1.2.7 1.2 2.5 0 3.2L4.8 24.2C3.5 25 2 24.1 2 22.6V3.4z");
    			add_location(path, file$l, 238, 12, 4972);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 237, 10, 4939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(237:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (232:8) {#if isPlaying}
    function create_if_block_1$5(ctx) {
    	let svg;
    	let rect0;
    	let rect1;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "height", "22.9");
    			attr_dev(rect0, "rx", "1.9");
    			attr_dev(rect0, "width", "7.6");
    			attr_dev(rect0, "x", "14");
    			attr_dev(rect0, "y", ".5");
    			add_location(rect0, file$l, 233, 12, 4759);
    			attr_dev(rect1, "height", "22.9");
    			attr_dev(rect1, "rx", "1.9");
    			attr_dev(rect1, "width", "7.6");
    			attr_dev(rect1, "x", "2");
    			attr_dev(rect1, "y", ".5");
    			add_location(rect1, file$l, 234, 12, 4834);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$l, 232, 10, 4726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect0);
    			append_dev(svg, rect1);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(232:8) {#if isPlaying}",
    		ctx
    	});

    	return block;
    }

    // (229:2) {#each layout as item}
    function create_each_block$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block$7,
    		create_if_block_2$3,
    		create_if_block_3$3,
    		create_if_block_4$3,
    		create_if_block_5$2,
    		create_if_block_6$2,
    		create_if_block_7$1,
    		create_if_block_9,
    		create_if_block_10,
    		create_if_block_11,
    		create_if_block_12,
    		create_if_block_13
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[40] === 'playpause') return 0;
    		if (/*item*/ ctx[40] === 'stop') return 1;
    		if (/*item*/ ctx[40] === 'progress') return 2;
    		if (/*item*/ ctx[40] === 'loop') return 3;
    		if (/*item*/ ctx[40] === 'background') return 4;
    		if (/*item*/ ctx[40] === 'snapshot') return 5;
    		if (/*item*/ ctx[40] === 'zoom') return 6;
    		if (/*item*/ ctx[40] === 'info') return 7;
    		if (/*item*/ ctx[40] === 'frame') return 8;
    		if (/*item*/ ctx[40] === 'nextFrame') return 9;
    		if (/*item*/ ctx[40] === 'previousFrame') return 10;
    		if (/*item*/ ctx[40] === 'spacer') return 11;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(229:2) {#each layout as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div;
    	let current;
    	let each_value = /*layout*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "lottie-player-controls svelte-9yox50");
    			add_location(div, file$l, 227, 0, 4512);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*isPlaying, isPaused, togglePlay, ICON_SIZE, layout, isStopped, stop, progress, onHandleSeekChange, freeze, play, loop, toggleLooping, background, onSelectBackground, currentState, seek, frame, snapshot, formattedFrame, onToggleZoom, isZoomed, animationData, onNextFrame, oPreviousFrame*/ 33554431) {
    				each_value = /*layout*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$1($$self, $$props, $$invalidate) {
    	let isPlaying;
    	let isPaused;
    	let isStopped;
    	let formattedFrame;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Controls', slots, []);

    	const ICON_SIZE = {
    		width: 14,
    		height: 14,
    		viewBox: '0 0 24 24'
    	};

    	// Create event dispatcher
    	const dispatch = createEventDispatcher();

    	let { animationData } = $$props;
    	let { background } = $$props;
    	let { currentState } = $$props;
    	let { frame } = $$props;
    	let { freeze } = $$props;
    	let { instance } = $$props;
    	let { layout = ControlsLayoutOptions } = $$props;
    	let { loop } = $$props;
    	let { play } = $$props;
    	let { progress } = $$props;
    	let { seek } = $$props;
    	let { snapshot } = $$props;
    	let { stop } = $$props;
    	let { toggleZoom } = $$props;
    	let { toggleLooping } = $$props;
    	let { togglePlay } = $$props;
    	let { totalFrames = 0 } = $$props;
    	let isZoomed = false;

    	const onHandleSeekChange = e => {
    		if (!instance || isNaN(e.target.value)) {
    			return;
    		}

    		const frame = e.target.value / 100 * totalFrames;
    		seek(frame);
    	};

    	const onSelectBackground = e => {
    		dispatch('background', { color: e.detail.hex });
    	};

    	const onToggleZoom = () => {
    		$$invalidate(14, isZoomed = !isZoomed);
    		toggleZoom();
    	};

    	const onNextFrame = () => {
    		const nextFrame = frame + 1;

    		if (nextFrame <= totalFrames) {
    			seek(nextFrame);
    		}
    	};

    	const oPreviousFrame = () => {
    		const prevFrame = frame - 1;

    		if (prevFrame >= 0) {
    			seek(prevFrame);
    		}
    	};

    	const writable_props = [
    		'animationData',
    		'background',
    		'currentState',
    		'frame',
    		'freeze',
    		'instance',
    		'layout',
    		'loop',
    		'play',
    		'progress',
    		'seek',
    		'snapshot',
    		'stop',
    		'toggleZoom',
    		'toggleLooping',
    		'togglePlay',
    		'totalFrames'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Controls> was created with unknown prop '${key}'`);
    	});

    	function input_change_input_handler() {
    		progress = to_number(this.value);
    		$$invalidate(0, progress);
    	}

    	const click_handler = () => snapshot(true);
    	const click_handler_1 = () => snapshot(true);
    	const mousewheel_handler = e => seek(frame + (e.deltaY > 0 ? -1 : 1));
    	const mouseout_handler = () => currentState === PlayerState.Frozen && play();
    	const mouseover_handler = () => currentState !== PlayerState.Paused && freeze();

    	function input_input_handler() {
    		formattedFrame = this.value;
    		($$invalidate(15, formattedFrame), $$invalidate(4, frame));
    	}

    	const mouseout_handler_1 = () => currentState === PlayerState.Frozen && play();
    	const mouseover_handler_1 = () => currentState !== PlayerState.Paused && freeze();
    	const input_handler = e => seek(e.target.value);
    	const mousewheel_handler_1 = e => seek(frame + (e.deltaY > 0 ? -1 : 1));

    	$$self.$$set = $$props => {
    		if ('animationData' in $$props) $$invalidate(1, animationData = $$props.animationData);
    		if ('background' in $$props) $$invalidate(2, background = $$props.background);
    		if ('currentState' in $$props) $$invalidate(3, currentState = $$props.currentState);
    		if ('frame' in $$props) $$invalidate(4, frame = $$props.frame);
    		if ('freeze' in $$props) $$invalidate(5, freeze = $$props.freeze);
    		if ('instance' in $$props) $$invalidate(25, instance = $$props.instance);
    		if ('layout' in $$props) $$invalidate(6, layout = $$props.layout);
    		if ('loop' in $$props) $$invalidate(7, loop = $$props.loop);
    		if ('play' in $$props) $$invalidate(8, play = $$props.play);
    		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
    		if ('seek' in $$props) $$invalidate(9, seek = $$props.seek);
    		if ('snapshot' in $$props) $$invalidate(10, snapshot = $$props.snapshot);
    		if ('stop' in $$props) $$invalidate(11, stop = $$props.stop);
    		if ('toggleZoom' in $$props) $$invalidate(26, toggleZoom = $$props.toggleZoom);
    		if ('toggleLooping' in $$props) $$invalidate(12, toggleLooping = $$props.toggleLooping);
    		if ('togglePlay' in $$props) $$invalidate(13, togglePlay = $$props.togglePlay);
    		if ('totalFrames' in $$props) $$invalidate(27, totalFrames = $$props.totalFrames);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		ColorPicker,
    		Info,
    		Popover,
    		ControlsLayoutOptions,
    		PlayerState,
    		ICON_SIZE,
    		dispatch,
    		animationData,
    		background,
    		currentState,
    		frame,
    		freeze,
    		instance,
    		layout,
    		loop,
    		play,
    		progress,
    		seek,
    		snapshot,
    		stop,
    		toggleZoom,
    		toggleLooping,
    		togglePlay,
    		totalFrames,
    		isZoomed,
    		onHandleSeekChange,
    		onSelectBackground,
    		onToggleZoom,
    		onNextFrame,
    		oPreviousFrame,
    		formattedFrame,
    		isStopped,
    		isPaused,
    		isPlaying
    	});

    	$$self.$inject_state = $$props => {
    		if ('animationData' in $$props) $$invalidate(1, animationData = $$props.animationData);
    		if ('background' in $$props) $$invalidate(2, background = $$props.background);
    		if ('currentState' in $$props) $$invalidate(3, currentState = $$props.currentState);
    		if ('frame' in $$props) $$invalidate(4, frame = $$props.frame);
    		if ('freeze' in $$props) $$invalidate(5, freeze = $$props.freeze);
    		if ('instance' in $$props) $$invalidate(25, instance = $$props.instance);
    		if ('layout' in $$props) $$invalidate(6, layout = $$props.layout);
    		if ('loop' in $$props) $$invalidate(7, loop = $$props.loop);
    		if ('play' in $$props) $$invalidate(8, play = $$props.play);
    		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
    		if ('seek' in $$props) $$invalidate(9, seek = $$props.seek);
    		if ('snapshot' in $$props) $$invalidate(10, snapshot = $$props.snapshot);
    		if ('stop' in $$props) $$invalidate(11, stop = $$props.stop);
    		if ('toggleZoom' in $$props) $$invalidate(26, toggleZoom = $$props.toggleZoom);
    		if ('toggleLooping' in $$props) $$invalidate(12, toggleLooping = $$props.toggleLooping);
    		if ('togglePlay' in $$props) $$invalidate(13, togglePlay = $$props.togglePlay);
    		if ('totalFrames' in $$props) $$invalidate(27, totalFrames = $$props.totalFrames);
    		if ('isZoomed' in $$props) $$invalidate(14, isZoomed = $$props.isZoomed);
    		if ('formattedFrame' in $$props) $$invalidate(15, formattedFrame = $$props.formattedFrame);
    		if ('isStopped' in $$props) $$invalidate(16, isStopped = $$props.isStopped);
    		if ('isPaused' in $$props) $$invalidate(17, isPaused = $$props.isPaused);
    		if ('isPlaying' in $$props) $$invalidate(18, isPlaying = $$props.isPlaying);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(18, isPlaying = currentState === PlayerState.Playing);
    		}

    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(17, isPaused = currentState === PlayerState.Paused);
    		}

    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(16, isStopped = currentState === PlayerState.Stopped);
    		}

    		if ($$self.$$.dirty[0] & /*frame*/ 16) {
    			$$invalidate(15, formattedFrame = Math.round(frame));
    		}
    	};

    	return [
    		progress,
    		animationData,
    		background,
    		currentState,
    		frame,
    		freeze,
    		layout,
    		loop,
    		play,
    		seek,
    		snapshot,
    		stop,
    		toggleLooping,
    		togglePlay,
    		isZoomed,
    		formattedFrame,
    		isStopped,
    		isPaused,
    		isPlaying,
    		ICON_SIZE,
    		onHandleSeekChange,
    		onSelectBackground,
    		onToggleZoom,
    		onNextFrame,
    		oPreviousFrame,
    		instance,
    		toggleZoom,
    		totalFrames,
    		input_change_input_handler,
    		click_handler,
    		click_handler_1,
    		mousewheel_handler,
    		mouseout_handler,
    		mouseover_handler,
    		input_input_handler,
    		mouseout_handler_1,
    		mouseover_handler_1,
    		input_handler,
    		mousewheel_handler_1
    	];
    }

    class Controls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$1,
    			create_fragment$l,
    			safe_not_equal,
    			{
    				animationData: 1,
    				background: 2,
    				currentState: 3,
    				frame: 4,
    				freeze: 5,
    				instance: 25,
    				layout: 6,
    				loop: 7,
    				play: 8,
    				progress: 0,
    				seek: 9,
    				snapshot: 10,
    				stop: 11,
    				toggleZoom: 26,
    				toggleLooping: 12,
    				togglePlay: 13,
    				totalFrames: 27
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Controls",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*animationData*/ ctx[1] === undefined && !('animationData' in props)) {
    			console.warn("<Controls> was created without expected prop 'animationData'");
    		}

    		if (/*background*/ ctx[2] === undefined && !('background' in props)) {
    			console.warn("<Controls> was created without expected prop 'background'");
    		}

    		if (/*currentState*/ ctx[3] === undefined && !('currentState' in props)) {
    			console.warn("<Controls> was created without expected prop 'currentState'");
    		}

    		if (/*frame*/ ctx[4] === undefined && !('frame' in props)) {
    			console.warn("<Controls> was created without expected prop 'frame'");
    		}

    		if (/*freeze*/ ctx[5] === undefined && !('freeze' in props)) {
    			console.warn("<Controls> was created without expected prop 'freeze'");
    		}

    		if (/*instance*/ ctx[25] === undefined && !('instance' in props)) {
    			console.warn("<Controls> was created without expected prop 'instance'");
    		}

    		if (/*loop*/ ctx[7] === undefined && !('loop' in props)) {
    			console.warn("<Controls> was created without expected prop 'loop'");
    		}

    		if (/*play*/ ctx[8] === undefined && !('play' in props)) {
    			console.warn("<Controls> was created without expected prop 'play'");
    		}

    		if (/*progress*/ ctx[0] === undefined && !('progress' in props)) {
    			console.warn("<Controls> was created without expected prop 'progress'");
    		}

    		if (/*seek*/ ctx[9] === undefined && !('seek' in props)) {
    			console.warn("<Controls> was created without expected prop 'seek'");
    		}

    		if (/*snapshot*/ ctx[10] === undefined && !('snapshot' in props)) {
    			console.warn("<Controls> was created without expected prop 'snapshot'");
    		}

    		if (/*stop*/ ctx[11] === undefined && !('stop' in props)) {
    			console.warn("<Controls> was created without expected prop 'stop'");
    		}

    		if (/*toggleZoom*/ ctx[26] === undefined && !('toggleZoom' in props)) {
    			console.warn("<Controls> was created without expected prop 'toggleZoom'");
    		}

    		if (/*toggleLooping*/ ctx[12] === undefined && !('toggleLooping' in props)) {
    			console.warn("<Controls> was created without expected prop 'toggleLooping'");
    		}

    		if (/*togglePlay*/ ctx[13] === undefined && !('togglePlay' in props)) {
    			console.warn("<Controls> was created without expected prop 'togglePlay'");
    		}
    	}

    	get animationData() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animationData(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentState() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentState(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get frame() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set frame(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get freeze() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set freeze(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set instance(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get play() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set play(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get progress() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set progress(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seek() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seek(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get snapshot() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set snapshot(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stop() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stop(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleZoom() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleZoom(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleLooping() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleLooping(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get togglePlay() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set togglePlay(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get totalFrames() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set totalFrames(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\@lottiefiles\svelte-lottie-player\src\components\LottiePlayer.svelte generated by Svelte v3.48.0 */

    const file$k = "node_modules\\@lottiefiles\\svelte-lottie-player\\src\\components\\LottiePlayer.svelte";

    // (559:6) {#if currentState === PlayerState.Error}
    function create_if_block_1$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "⚠️";
    			attr_dev(div, "class", "lottie-player-error svelte-1aiskgp");
    			add_location(div, file$k, 559, 8, 12693);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(559:6) {#if currentState === PlayerState.Error}",
    		ctx
    	});

    	return block;
    }

    // (563:4) {#if controls}
    function create_if_block$6(ctx) {
    	let controls_1;
    	let current;

    	controls_1 = new Controls({
    			props: {
    				layout: /*controlsLayout*/ ctx[3],
    				animationData: /*animationData*/ ctx[22],
    				background: /*background*/ ctx[1],
    				controls: /*controls*/ ctx[2],
    				currentState: /*currentState*/ ctx[28],
    				frame: /*frame*/ ctx[26],
    				freeze: /*freeze*/ ctx[11],
    				instance: /*instance*/ ctx[21],
    				loop: /*loop*/ ctx[0],
    				lottie,
    				pause: /*pause*/ ctx[9],
    				play: /*play*/ ctx[8],
    				progress: /*progress*/ ctx[27],
    				seek: /*seek*/ ctx[12],
    				setDirection: /*setDirection*/ ctx[16],
    				setSpeed: /*setSpeed*/ ctx[15],
    				setLooping: /*setLooping*/ ctx[14],
    				snapshot: /*snapshot*/ ctx[13],
    				src: /*src*/ ctx[5],
    				stop: /*stop*/ ctx[10],
    				toggleZoom: /*toggleZoom*/ ctx[20],
    				toggleLooping: /*toggleLooping*/ ctx[18],
    				togglePlay: /*togglePlay*/ ctx[17],
    				totalFrames: /*totalFrames*/ ctx[32]
    			},
    			$$inline: true
    		});

    	controls_1.$on("background", /*background_handler*/ ctx[46]);

    	const block = {
    		c: function create() {
    			create_component(controls_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(controls_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const controls_1_changes = {};
    			if (dirty[0] & /*controlsLayout*/ 8) controls_1_changes.layout = /*controlsLayout*/ ctx[3];
    			if (dirty[0] & /*animationData*/ 4194304) controls_1_changes.animationData = /*animationData*/ ctx[22];
    			if (dirty[0] & /*background*/ 2) controls_1_changes.background = /*background*/ ctx[1];
    			if (dirty[0] & /*controls*/ 4) controls_1_changes.controls = /*controls*/ ctx[2];
    			if (dirty[0] & /*currentState*/ 268435456) controls_1_changes.currentState = /*currentState*/ ctx[28];
    			if (dirty[0] & /*frame*/ 67108864) controls_1_changes.frame = /*frame*/ ctx[26];
    			if (dirty[0] & /*instance*/ 2097152) controls_1_changes.instance = /*instance*/ ctx[21];
    			if (dirty[0] & /*loop*/ 1) controls_1_changes.loop = /*loop*/ ctx[0];
    			if (dirty[0] & /*progress*/ 134217728) controls_1_changes.progress = /*progress*/ ctx[27];
    			if (dirty[0] & /*src*/ 32) controls_1_changes.src = /*src*/ ctx[5];
    			if (dirty[1] & /*totalFrames*/ 2) controls_1_changes.totalFrames = /*totalFrames*/ ctx[32];
    			controls_1.$set(controls_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controls_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controls_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(controls_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(563:4) {#if controls}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t;
    	let div2_style_value;
    	let div2_resize_listener;
    	let current;
    	let if_block0 = /*currentState*/ ctx[28] === PlayerState.Error && create_if_block_1$4(ctx);
    	let if_block1 = /*controls*/ ctx[2] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			set_style(div0, "background", /*background*/ ctx[1]);
    			attr_dev(div0, "class", "svelte-1aiskgp");
    			toggle_class(div0, "animation", true);
    			add_location(div0, file$k, 554, 4, 12533);
    			attr_dev(div1, "class", "lottie-player svelte-1aiskgp");
    			toggle_class(div1, "with-controls", /*controls*/ ctx[2]);
    			toggle_class(div1, "is-zoomed", /*isZoomed*/ ctx[29]);
    			add_location(div1, file$k, 549, 2, 12405);

    			attr_dev(div2, "style", div2_style_value = "" + ((/*width*/ ctx[7] ? `width:${/*width*/ ctx[7]}px;` : '') + (/*height*/ ctx[4]
    			? `height:${/*height*/ ctx[4]}px;`
    			: '') + /*style*/ ctx[6]));

    			add_render_callback(() => /*div2_elementresize_handler*/ ctx[49].call(div2));
    			add_location(div2, file$k, 544, 0, 12215);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			/*div0_binding*/ ctx[45](div0);
    			append_dev(div1, t);
    			if (if_block1) if_block1.m(div1, null);
    			/*div1_binding*/ ctx[47](div1);
    			/*div2_binding*/ ctx[48](div2);
    			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[49].bind(div2));
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*currentState*/ ctx[28] === PlayerState.Error) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*background*/ 2) {
    				set_style(div0, "background", /*background*/ ctx[1]);
    			}

    			if (/*controls*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*controls*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*controls*/ 4) {
    				toggle_class(div1, "with-controls", /*controls*/ ctx[2]);
    			}

    			if (dirty[0] & /*isZoomed*/ 536870912) {
    				toggle_class(div1, "is-zoomed", /*isZoomed*/ ctx[29]);
    			}

    			if (!current || dirty[0] & /*width, height, style*/ 208 && div2_style_value !== (div2_style_value = "" + ((/*width*/ ctx[7] ? `width:${/*width*/ ctx[7]}px;` : '') + (/*height*/ ctx[4]
    			? `height:${/*height*/ ctx[4]}px;`
    			: '') + /*style*/ ctx[6]))) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			/*div0_binding*/ ctx[45](null);
    			if (if_block1) if_block1.d();
    			/*div1_binding*/ ctx[47](null);
    			/*div2_binding*/ ctx[48](null);
    			div2_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LottiePlayer', slots, []);
    	let { autoplay = false } = $$props;
    	let { background } = $$props;
    	let { controls } = $$props;
    	let { controlsLayout } = $$props;
    	let { count = undefined } = $$props;
    	let { defaultFrame = 0 } = $$props;
    	let { direction = 1 } = $$props;
    	let { height } = $$props;
    	let { hover = false } = $$props;
    	let { loop = false } = $$props;
    	let { mode = PlayMode.Normal } = $$props;
    	let { onToggleZoom = undefined } = $$props;
    	let { renderer = PlayerRender.SVG } = $$props;
    	let { speed = 1 } = $$props;
    	let { src = "" } = $$props;
    	let { style = "" } = $$props;
    	let { width } = $$props;
    	let animationData;
    	let animationRef;
    	let playerRef;
    	let wrapperRef;
    	let instance;
    	let frame = 0;
    	let progress = 0;
    	let io;
    	let currentState = PlayerState.Loading;
    	let isZoomed = false;
    	let playerHeight;
    	let playerWidth;
    	let totalFrames;

    	/**
     * Handle visibility change events.
     */
    	const onVisibilityChange = () => {
    		if (document.hidden === true && currentState === PlayerState.Playing) {
    			freeze();
    		} else if (currentState === PlayerState.Frozen) {
    			play();
    		}
    	};

    	/**
     * Initialize everything on component mount.
     */
    	onMount(() => {
    		if ("IntersectionObserver" in window) {
    			io = new IntersectionObserver(entries => {
    					if (entries[0].isIntersecting) {
    						if (currentState === PlayerState.Frozen) {
    							play();
    						}
    					} else if (currentState === PlayerState.Playing) {
    						freeze();
    					}
    				});

    			io.observe(animationRef);
    		}

    		// Add listener for Visibility API's change event.
    		if (typeof document.hidden !== "undefined") {
    			document.addEventListener("visibilitychange", onVisibilityChange);
    		}

    		// Setup lottie player
    		if (src) {
    			load(src);
    		}
    	});

    	/**
     * Cleanup on component destroy.
     */
    	onDestroy(() => {
    		// Remove intersection observer for detecting component being out-of-view.
    		if (io) {
    			io.disconnect();
    			io = undefined;
    		}

    		// Remove the attached Visibility API's change event listener.
    		document.removeEventListener("visibilitychange", onVisibilityChange);
    	});

    	const load = srcValue => {
    		if (!animationRef) {
    			return;
    		}

    		// Clear previous animation, if any
    		if (instance) {
    			instance.destroy();
    		}

    		const options = {
    			container: animationRef,
    			loop,
    			autoplay,
    			renderer,
    			rendererSettings: {
    				preserveAspectRatio: "xMidYMid meet",
    				clearCanvas: true,
    				progressiveLoad: true,
    				hideOnTransparent: true
    			}
    		};

    		// Load the resource information
    		try {
    			const srcParsed = parseSrc(srcValue);
    			const srcAttrib = typeof srcParsed === "string" ? "path" : "animationData";

    			// Initialize lottie player and load animation
    			$$invalidate(21, instance = lottie.loadAnimation({ ...options, [srcAttrib]: srcParsed }));
    		} catch(err) {
    			$$invalidate(28, currentState = PlayerState.Error);
    			dispatchEvent(new CustomEvent(PlayerEvents.Error));
    		}

    		if (instance) {
    			// Calculate and save the current progress of the animation
    			instance.addEventListener("enterFrame", () => {
    				$$invalidate(26, frame = instance.currentFrame);
    				$$invalidate(27, progress = instance.currentFrame / instance.totalFrames * 100);

    				dispatchEvent(new CustomEvent(PlayerEvents.Frame,
    				{
    						detail: { frame: instance.currentFrame, progress }
    					}));
    			});

    			instance.addEventListener("complete", () => {
    				if (currentState !== PlayerState.Playing) {
    					dispatchEvent(new CustomEvent(PlayerEvents.Complete));
    					return;
    				}

    				if (!loop || count && _counter >= count) {
    					dispatchEvent(new CustomEvent(PlayerEvents.Complete));
    					return;
    				}

    				if (mode === PlayMode.Bounce) {
    					if (count) {
    						_counter += 0.5;
    					}

    					setTimeout(
    						() => {
    							dispatchEvent(new CustomEvent(PlayerEvents.Loop));

    							if (currentState === PlayerState.Playing) {
    								instance.setDirection(instance.playDirection * -1);
    								instance.play();
    							}
    						},
    						intermission
    					);
    				} else {
    					if (count) {
    						_counter += 1;
    					}

    					window.setTimeout(
    						() => {
    							dispatchEvent(new CustomEvent(PlayerEvents.Loop));

    							if (currentState === PlayerState.Playing) {
    								instance.stop();
    								instance.play();
    							}
    						},
    						intermission
    					);
    				}
    			});

    			// Handle animation data load complete
    			instance.addEventListener("data_ready", () => {
    				$$invalidate(22, animationData = instance.animationData);
    				$$invalidate(32, totalFrames = instance.totalFrames);
    			});

    			// Set error state when animation load fail event triggers
    			instance.addEventListener("data_failed", () => {
    				$$invalidate(28, currentState = PlayerState.Error);
    				dispatchEvent(new CustomEvent(PlayerEvents.Error));
    			});

    			// Set handlers to auto play animation on hover if enabled
    			animationRef.addEventListener("mouseenter", () => {
    				if (hover && currentState !== PlayerState.Playing) {
    					play();
    				}
    			});

    			animationRef.addEventListener("mouseleave", () => {
    				if (hover && currentState === PlayerState.Playing) {
    					stop();
    				}
    			});

    			// Set initial playback speed and direction
    			setSpeed(speed);

    			setDirection(direction);

    			// Start playing if autoplay is enabled
    			if (autoplay) {
    				play();
    			} else if (!isNaN(defaultFrame)) {
    				instance.goToAndStop(defaultFrame, true);
    			}
    		}
    	};

    	const getLottie = () => {
    		return instance;
    	};

    	const play = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Playing);
    		instance.play();
    		dispatchEvent(new CustomEvent(PlayerEvents.Play));
    	};

    	const pause = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Paused);
    		instance.pause();
    		dispatchEvent(new CustomEvent(PlayerEvents.Pause));
    	};

    	const stop = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Stopped);
    		instance.stop();
    		dispatchEvent(new CustomEvent(PlayerEvents.Stop));
    	};

    	const freeze = () => {
    		if (!instance) {
    			return;
    		}

    		instance.pause();
    		$$invalidate(28, currentState = PlayerState.Frozen);
    		dispatchEvent(new CustomEvent(PlayerEvents.Freeze));
    	};

    	const resize = () => {
    		if (!instance) {
    			return;
    		}

    		instance.resize();
    	};

    	const seek = value => {
    		if (!instance) {
    			return;
    		}

    		// Extract frame number from either number or percentage value
    		const matches = value.toString().match(/^([0-9\.]+)(%?)$/);

    		if (!matches) {
    			return;
    		}

    		// Calculate and set the frame number
    		const resolvedFrame = matches[2] === "%"
    		? instance.totalFrames * Number(matches[1]) / 100
    		: Number(matches[1]);

    		// Send lottie player to the new frame
    		if (currentState === PlayerState.Playing) {
    			instance.goToAndPlay(resolvedFrame, true);
    		} else {
    			instance.goToAndStop(resolvedFrame, true);
    			instance.pause();
    		}
    	};

    	const snapshot = (download = true) => {
    		let data;

    		if (renderer === PlayerRender.SVG) {
    			// Get SVG element and serialize markup
    			const svgElement = animationRef.querySelector("svg");

    			const serializedSvg = new XMLSerializer().serializeToString(svgElement);
    			data = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(serializedSvg);

    			// Trigger file download if needed
    			if (download) {
    				triggerDownload(data, `snapshot_${progress}.svg`);
    			}
    		} else if (renderer === PlayerRender.Canvas) {
    			const canvas = animationRef.querySelector("canvas");
    			data = canvas.toDataURL("image/png");

    			// Trigger file download if needed
    			if (download) {
    				triggerDownload(data, `snapshot_${progress}.png`);
    			}
    		}

    		return data;
    	};

    	const setLooping = value => {
    		if (instance) {
    			$$invalidate(0, loop = value);
    		}
    	};

    	const setSpeed = value => {
    		if (instance) {
    			$$invalidate(34, speed = value);
    		}
    	};

    	const setDirection = value => {
    		if (instance) {
    			$$invalidate(33, direction = value);
    		}
    	};

    	const togglePlay = () => {
    		return currentState === PlayerState.Playing ? pause() : play();
    	};

    	const toggleLooping = () => {
    		setLooping(!loop);
    	};

    	const setBackground = value => {
    		$$invalidate(1, background = value);
    	};

    	const toggleZoom = () => {
    		// Check if custom handler for zoom toggle is set
    		if (typeof onToggleZoom === "function") {
    			// Call the custom zoom toggle handler with current zoom status
    			// Set return value as the zoom status
    			$$invalidate(29, isZoomed = Boolean(onToggleZoom(isZoomed)));

    			return;
    		}

    		if (!isZoomed) {
    			$$invalidate(25, wrapperRef.style.height = playerHeight + "px", wrapperRef);
    			$$invalidate(25, wrapperRef.style.width = playerWidth + "px", wrapperRef);
    			document.body.appendChild(playerRef);
    		} else {
    			wrapperRef.appendChild(playerRef);
    			$$invalidate(25, wrapperRef.style.height = undefined, wrapperRef);
    			$$invalidate(25, wrapperRef.style.width = undefined, wrapperRef);
    		}

    		$$invalidate(29, isZoomed = !isZoomed);
    		setTimeout(() => resize(), 100);
    	};

    	const writable_props = [
    		'autoplay',
    		'background',
    		'controls',
    		'controlsLayout',
    		'count',
    		'defaultFrame',
    		'direction',
    		'height',
    		'hover',
    		'loop',
    		'mode',
    		'onToggleZoom',
    		'renderer',
    		'speed',
    		'src',
    		'style',
    		'width'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LottiePlayer> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			animationRef = $$value;
    			$$invalidate(23, animationRef);
    		});
    	}

    	const background_handler = e => setBackground(e.detail.color);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playerRef = $$value;
    			$$invalidate(24, playerRef);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrapperRef = $$value;
    			$$invalidate(25, wrapperRef);
    		});
    	}

    	function div2_elementresize_handler() {
    		playerHeight = this.clientHeight;
    		playerWidth = this.clientWidth;
    		$$invalidate(30, playerHeight);
    		$$invalidate(31, playerWidth);
    	}

    	$$self.$$set = $$props => {
    		if ('autoplay' in $$props) $$invalidate(35, autoplay = $$props.autoplay);
    		if ('background' in $$props) $$invalidate(1, background = $$props.background);
    		if ('controls' in $$props) $$invalidate(2, controls = $$props.controls);
    		if ('controlsLayout' in $$props) $$invalidate(3, controlsLayout = $$props.controlsLayout);
    		if ('count' in $$props) $$invalidate(36, count = $$props.count);
    		if ('defaultFrame' in $$props) $$invalidate(37, defaultFrame = $$props.defaultFrame);
    		if ('direction' in $$props) $$invalidate(33, direction = $$props.direction);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('hover' in $$props) $$invalidate(38, hover = $$props.hover);
    		if ('loop' in $$props) $$invalidate(0, loop = $$props.loop);
    		if ('mode' in $$props) $$invalidate(39, mode = $$props.mode);
    		if ('onToggleZoom' in $$props) $$invalidate(40, onToggleZoom = $$props.onToggleZoom);
    		if ('renderer' in $$props) $$invalidate(41, renderer = $$props.renderer);
    		if ('speed' in $$props) $$invalidate(34, speed = $$props.speed);
    		if ('src' in $$props) $$invalidate(5, src = $$props.src);
    		if ('style' in $$props) $$invalidate(6, style = $$props.style);
    		if ('width' in $$props) $$invalidate(7, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		lottie,
    		Controls,
    		PlayerEvents,
    		PlayerRender,
    		PlayerState,
    		PlayMode,
    		parseSrc,
    		triggerDownload,
    		autoplay,
    		background,
    		controls,
    		controlsLayout,
    		count,
    		defaultFrame,
    		direction,
    		height,
    		hover,
    		loop,
    		mode,
    		onToggleZoom,
    		renderer,
    		speed,
    		src,
    		style,
    		width,
    		animationData,
    		animationRef,
    		playerRef,
    		wrapperRef,
    		instance,
    		frame,
    		progress,
    		io,
    		currentState,
    		isZoomed,
    		playerHeight,
    		playerWidth,
    		totalFrames,
    		onVisibilityChange,
    		load,
    		getLottie,
    		play,
    		pause,
    		stop,
    		freeze,
    		resize,
    		seek,
    		snapshot,
    		setLooping,
    		setSpeed,
    		setDirection,
    		togglePlay,
    		toggleLooping,
    		setBackground,
    		toggleZoom
    	});

    	$$self.$inject_state = $$props => {
    		if ('autoplay' in $$props) $$invalidate(35, autoplay = $$props.autoplay);
    		if ('background' in $$props) $$invalidate(1, background = $$props.background);
    		if ('controls' in $$props) $$invalidate(2, controls = $$props.controls);
    		if ('controlsLayout' in $$props) $$invalidate(3, controlsLayout = $$props.controlsLayout);
    		if ('count' in $$props) $$invalidate(36, count = $$props.count);
    		if ('defaultFrame' in $$props) $$invalidate(37, defaultFrame = $$props.defaultFrame);
    		if ('direction' in $$props) $$invalidate(33, direction = $$props.direction);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('hover' in $$props) $$invalidate(38, hover = $$props.hover);
    		if ('loop' in $$props) $$invalidate(0, loop = $$props.loop);
    		if ('mode' in $$props) $$invalidate(39, mode = $$props.mode);
    		if ('onToggleZoom' in $$props) $$invalidate(40, onToggleZoom = $$props.onToggleZoom);
    		if ('renderer' in $$props) $$invalidate(41, renderer = $$props.renderer);
    		if ('speed' in $$props) $$invalidate(34, speed = $$props.speed);
    		if ('src' in $$props) $$invalidate(5, src = $$props.src);
    		if ('style' in $$props) $$invalidate(6, style = $$props.style);
    		if ('width' in $$props) $$invalidate(7, width = $$props.width);
    		if ('animationData' in $$props) $$invalidate(22, animationData = $$props.animationData);
    		if ('animationRef' in $$props) $$invalidate(23, animationRef = $$props.animationRef);
    		if ('playerRef' in $$props) $$invalidate(24, playerRef = $$props.playerRef);
    		if ('wrapperRef' in $$props) $$invalidate(25, wrapperRef = $$props.wrapperRef);
    		if ('instance' in $$props) $$invalidate(21, instance = $$props.instance);
    		if ('frame' in $$props) $$invalidate(26, frame = $$props.frame);
    		if ('progress' in $$props) $$invalidate(27, progress = $$props.progress);
    		if ('io' in $$props) io = $$props.io;
    		if ('currentState' in $$props) $$invalidate(28, currentState = $$props.currentState);
    		if ('isZoomed' in $$props) $$invalidate(29, isZoomed = $$props.isZoomed);
    		if ('playerHeight' in $$props) $$invalidate(30, playerHeight = $$props.playerHeight);
    		if ('playerWidth' in $$props) $$invalidate(31, playerWidth = $$props.playerWidth);
    		if ('totalFrames' in $$props) $$invalidate(32, totalFrames = $$props.totalFrames);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*src*/ 32) {
    			// Try load new animation when the src value changes
    			load(src);
    		}

    		if ($$self.$$.dirty[0] & /*instance, loop*/ 2097153) {
    			// Update the player with loop prop changes
    			{
    				if (instance) {
    					$$invalidate(21, instance.loop = loop, instance);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*instance*/ 2097152 | $$self.$$.dirty[1] & /*speed*/ 8) {
    			// Update the player with speed prop changes
    			{
    				if (instance) {
    					instance.setSpeed(speed);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*instance*/ 2097152 | $$self.$$.dirty[1] & /*direction*/ 4) {
    			// Update the player with direction prop changes
    			{
    				if (instance) {
    					instance.setDirection(direction);
    				}
    			}
    		}
    	};

    	return [
    		loop,
    		background,
    		controls,
    		controlsLayout,
    		height,
    		src,
    		style,
    		width,
    		play,
    		pause,
    		stop,
    		freeze,
    		seek,
    		snapshot,
    		setLooping,
    		setSpeed,
    		setDirection,
    		togglePlay,
    		toggleLooping,
    		setBackground,
    		toggleZoom,
    		instance,
    		animationData,
    		animationRef,
    		playerRef,
    		wrapperRef,
    		frame,
    		progress,
    		currentState,
    		isZoomed,
    		playerHeight,
    		playerWidth,
    		totalFrames,
    		direction,
    		speed,
    		autoplay,
    		count,
    		defaultFrame,
    		hover,
    		mode,
    		onToggleZoom,
    		renderer,
    		load,
    		getLottie,
    		resize,
    		div0_binding,
    		background_handler,
    		div1_binding,
    		div2_binding,
    		div2_elementresize_handler
    	];
    }

    class LottiePlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1,
    			create_fragment$k,
    			safe_not_equal,
    			{
    				autoplay: 35,
    				background: 1,
    				controls: 2,
    				controlsLayout: 3,
    				count: 36,
    				defaultFrame: 37,
    				direction: 33,
    				height: 4,
    				hover: 38,
    				loop: 0,
    				mode: 39,
    				onToggleZoom: 40,
    				renderer: 41,
    				speed: 34,
    				src: 5,
    				style: 6,
    				width: 7,
    				load: 42,
    				getLottie: 43,
    				play: 8,
    				pause: 9,
    				stop: 10,
    				freeze: 11,
    				resize: 44,
    				seek: 12,
    				snapshot: 13,
    				setLooping: 14,
    				setSpeed: 15,
    				setDirection: 16,
    				togglePlay: 17,
    				toggleLooping: 18,
    				setBackground: 19,
    				toggleZoom: 20
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LottiePlayer",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*background*/ ctx[1] === undefined && !('background' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'background'");
    		}

    		if (/*controls*/ ctx[2] === undefined && !('controls' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'controls'");
    		}

    		if (/*controlsLayout*/ ctx[3] === undefined && !('controlsLayout' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'controlsLayout'");
    		}

    		if (/*height*/ ctx[4] === undefined && !('height' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'height'");
    		}

    		if (/*width*/ ctx[7] === undefined && !('width' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'width'");
    		}
    	}

    	get autoplay() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoplay(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get controls() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set controls(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get controlsLayout() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set controlsLayout(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultFrame() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultFrame(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hover() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hover(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onToggleZoom() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onToggleZoom(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderer() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderer(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get speed() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set speed(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get src() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get load() {
    		return this.$$.ctx[42];
    	}

    	set load(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getLottie() {
    		return this.$$.ctx[43];
    	}

    	set getLottie(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get play() {
    		return this.$$.ctx[8];
    	}

    	set play(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pause() {
    		return this.$$.ctx[9];
    	}

    	set pause(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stop() {
    		return this.$$.ctx[10];
    	}

    	set stop(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get freeze() {
    		return this.$$.ctx[11];
    	}

    	set freeze(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resize() {
    		return this.$$.ctx[44];
    	}

    	set resize(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seek() {
    		return this.$$.ctx[12];
    	}

    	set seek(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get snapshot() {
    		return this.$$.ctx[13];
    	}

    	set snapshot(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setLooping() {
    		return this.$$.ctx[14];
    	}

    	set setLooping(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setSpeed() {
    		return this.$$.ctx[15];
    	}

    	set setSpeed(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setDirection() {
    		return this.$$.ctx[16];
    	}

    	set setDirection(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get togglePlay() {
    		return this.$$.ctx[17];
    	}

    	set togglePlay(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleLooping() {
    		return this.$$.ctx[18];
    	}

    	set toggleLooping(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setBackground() {
    		return this.$$.ctx[19];
    	}

    	set setBackground(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleZoom() {
    		return this.$$.ctx[20];
    	}

    	set toggleZoom(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\plans\PlanModal.svelte generated by Svelte v3.48.0 */
    const file$j = "src\\components\\plans\\PlanModal.svelte";

    function create_fragment$j(ctx) {
    	let div7;
    	let div3;
    	let div2;
    	let div0;
    	let t0_value = /*$plansModalData*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*$plansModalData*/ ctx[1].desc + "";
    	let t2;
    	let t3;
    	let div5;
    	let div4;
    	let lottieplayer;
    	let t4;
    	let div6;
    	let svg;
    	let path;
    	let div7_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	lottieplayer = new LottiePlayer({
    			props: {
    				src: /*$plansModalData*/ ctx[1].lottie,
    				autoplay: true,
    				loop: true,
    				renderer: "svg",
    				background: "transparent",
    				width: /*lottieWidth*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			create_component(lottieplayer.$$.fragment);
    			t4 = space();
    			div6 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(div0, "class", "content__head svelte-q9liij");
    			add_location(div0, file$j, 13, 6, 372);
    			attr_dev(div1, "class", "content__text svelte-q9liij");
    			add_location(div1, file$j, 14, 6, 435);
    			attr_dev(div2, "class", "content svelte-q9liij");
    			add_location(div2, file$j, 12, 4, 343);
    			attr_dev(div3, "class", "column");
    			add_location(div3, file$j, 11, 2, 317);
    			attr_dev(div4, "class", "littie__wrapper svelte-q9liij");
    			add_location(div4, file$j, 18, 4, 542);
    			attr_dev(div5, "class", "column");
    			add_location(div5, file$j, 17, 2, 516);
    			attr_dev(path, "fill-rule", "evenodd");
    			attr_dev(path, "clip-rule", "evenodd");
    			attr_dev(path, "d", "M10.6739 11.9999L3.83691 18.8369L5.16291 20.1629L11.9999 13.3259L18.8369 20.1629L20.1629 18.8369L13.3259 11.9999L20.1629 5.16291L18.8369 3.83691L11.9999 10.6739L5.16291 3.83691L3.83691 5.16291L10.6739 11.9999Z");
    			attr_dev(path, "fill", "white");
    			add_location(path, file$j, 37, 6, 1018);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			add_location(svg, file$j, 30, 4, 874);
    			attr_dev(div6, "class", "close__icon svelte-q9liij");
    			add_location(div6, file$j, 29, 2, 799);
    			attr_dev(div7, "class", div7_class_value = "pop_up " + /*$plansModalData*/ ctx[1].class + " svelte-q9liij");
    			add_location(div7, file$j, 10, 0, 269);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div3);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div7, t3);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			mount_component(lottieplayer, div4, null);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			append_dev(div6, svg);
    			append_dev(svg, path);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div6, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$plansModalData*/ 2) && t0_value !== (t0_value = /*$plansModalData*/ ctx[1].name + "")) set_data_dev(t0, t0_value);
    			if ((!current || dirty & /*$plansModalData*/ 2) && t2_value !== (t2_value = /*$plansModalData*/ ctx[1].desc + "")) set_data_dev(t2, t2_value);
    			const lottieplayer_changes = {};
    			if (dirty & /*$plansModalData*/ 2) lottieplayer_changes.src = /*$plansModalData*/ ctx[1].lottie;
    			if (dirty & /*lottieWidth*/ 1) lottieplayer_changes.width = /*lottieWidth*/ ctx[0];
    			lottieplayer.$set(lottieplayer_changes);

    			if (!current || dirty & /*$plansModalData*/ 2 && div7_class_value !== (div7_class_value = "pop_up " + /*$plansModalData*/ ctx[1].class + " svelte-q9liij")) {
    				attr_dev(div7, "class", div7_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lottieplayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lottieplayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_component(lottieplayer);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $plansModalData;
    	let $plansModalState;
    	validate_store(plansModalData, 'plansModalData');
    	component_subscribe($$self, plansModalData, $$value => $$invalidate(1, $plansModalData = $$value));
    	validate_store(plansModalState, 'plansModalState');
    	component_subscribe($$self, plansModalState, $$value => $$invalidate(2, $plansModalState = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PlanModal', slots, []);
    	let lottieWidth = 450;

    	if ($plansModalData.class === "safe") {
    		lottieWidth = 370;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlanModal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => set_store_value(plansModalState, $plansModalState = false, $plansModalState);

    	$$self.$capture_state = () => ({
    		plansModalState,
    		plansModalData,
    		lottieWidth,
    		LottiePlayer,
    		$plansModalData,
    		$plansModalState
    	});

    	$$self.$inject_state = $$props => {
    		if ('lottieWidth' in $$props) $$invalidate(0, lottieWidth = $$props.lottieWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [lottieWidth, $plansModalData, $plansModalState, click_handler];
    }

    class PlanModal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PlanModal",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* src\components\plans\Plan.svelte generated by Svelte v3.48.0 */

    const { console: console_1$3 } = globals;
    const file$i = "src\\components\\plans\\Plan.svelte";

    // (130:2) {#if $plansModalState}
    function create_if_block$5(ctx) {
    	let planmodal;
    	let current;
    	planmodal = new PlanModal({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(planmodal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(planmodal, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(planmodal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(planmodal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(planmodal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(130:2) {#if $plansModalState}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let div9;
    	let div1;
    	let h20;
    	let t0;
    	let span0;
    	let t2;
    	let span1;
    	let t4;
    	let div0;
    	let t5;
    	let span2;
    	let t7;
    	let span3;
    	let t9;
    	let planhead;
    	let t10;
    	let div7;
    	let div6;
    	let h21;
    	let t11;
    	let span4;
    	let t13;
    	let span5;
    	let t15;
    	let div2;
    	let t17;
    	let div5;
    	let div3;
    	let svg;
    	let path;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let t18;
    	let div4;
    	let t20;
    	let planitems;
    	let t21;
    	let t22;
    	let div8;
    	let buttonleft;
    	let t23;
    	let buttonright;
    	let current;
    	let mounted;
    	let dispose;
    	planhead = new PlanHead({ $$inline: true });
    	planitems = new PlanItems({ $$inline: true });
    	let if_block = /*$plansModalState*/ ctx[1] && create_if_block$5(ctx);
    	buttonleft = new ButtonLeft({ $$inline: true });
    	buttonleft.$on("click", /*prevStep*/ ctx[2]);
    	buttonright = new ButtonRight({ $$inline: true });
    	buttonright.$on("click", /*nextStep*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div1 = element("div");
    			h20 = element("h2");
    			t0 = text("Plans ");
    			span0 = element("span");
    			span0.textContent = "Selector";
    			t2 = text(" and\r\n      ");
    			span1 = element("span");
    			span1.textContent = "Distributor";
    			t4 = space();
    			div0 = element("div");
    			t5 = text("Choose any ");
    			span2 = element("span");
    			span2.textContent = "plan";
    			t7 = text(" and allocate you\r\n      ");
    			span3 = element("span");
    			span3.textContent = "contribution";
    			t9 = space();
    			create_component(planhead.$$.fragment);
    			t10 = space();
    			div7 = element("div");
    			div6 = element("div");
    			h21 = element("h2");
    			t11 = text("Please allocate you ");
    			span4 = element("span");
    			span4.textContent = "contribution";
    			t13 = text(" between our\r\n        ");
    			span5 = element("span");
    			span5.textContent = "plans";
    			t15 = space();
    			div2 = element("div");
    			div2.textContent = "Select plans";
    			t17 = space();
    			div5 = element("div");
    			div3 = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			t18 = space();
    			div4 = element("div");
    			div4.textContent = "Subscribe to All Plan";
    			t20 = space();
    			create_component(planitems.$$.fragment);
    			t21 = space();
    			if (if_block) if_block.c();
    			t22 = space();
    			div8 = element("div");
    			create_component(buttonleft.$$.fragment);
    			t23 = space();
    			create_component(buttonright.$$.fragment);
    			attr_dev(span0, "class", "green svelte-blze0n");
    			add_location(span0, file$i, 77, 12, 2265);
    			attr_dev(span1, "class", "green svelte-blze0n");
    			add_location(span1, file$i, 78, 6, 2312);
    			add_location(h20, file$i, 76, 4, 2247);
    			attr_dev(span2, "class", "green svelte-blze0n");
    			add_location(span2, file$i, 81, 17, 2412);
    			attr_dev(span3, "class", "green svelte-blze0n");
    			add_location(span3, file$i, 82, 6, 2468);
    			attr_dev(div0, "class", "main__mob_h2 svelte-blze0n");
    			add_location(div0, file$i, 80, 4, 2367);
    			attr_dev(div1, "class", "plans__main__wrapper svelte-blze0n");
    			add_location(div1, file$i, 75, 2, 2207);
    			attr_dev(span4, "class", "green svelte-blze0n");
    			add_location(span4, file$i, 90, 28, 2663);
    			attr_dev(span5, "class", "green svelte-blze0n");
    			add_location(span5, file$i, 91, 8, 2724);
    			attr_dev(h21, "class", "svelte-blze0n");
    			add_location(h21, file$i, 89, 6, 2629);
    			attr_dev(div2, "class", "mob__plan__h2 svelte-blze0n");
    			add_location(div2, file$i, 93, 6, 2777);
    			attr_dev(path, "d", "M7.08286 13.8212L3.92203 10.6604C3.76486 10.5086 3.55436 10.4246 3.33586 10.4265C3.11736 10.4284 2.90835 10.516 2.75384 10.6705C2.59934 10.825 2.5117 11.034 2.5098 11.2525C2.5079 11.471 2.59189 11.6815 2.74369 11.8387L6.49369 15.5887C6.64997 15.7449 6.86189 15.8327 7.08286 15.8327C7.30383 15.8327 7.51575 15.7449 7.67203 15.5887L16.8387 6.42203C16.9905 6.26486 17.0745 6.05436 17.0726 5.83586C17.0707 5.61736 16.983 5.40835 16.8285 5.25384C16.674 5.09934 16.465 5.0117 16.2465 5.0098C16.028 5.0079 15.8175 5.09189 15.6604 5.24369L7.08286 13.8212Z");
    			attr_dev(path, "fill", "url(#paint0_linear_2960_1067)");
    			add_location(path, file$i, 103, 12, 3162);
    			attr_dev(stop0, "stop-color", "#FF2E00");
    			add_location(stop0, file$i, 116, 16, 4102);
    			attr_dev(stop1, "offset", "1");
    			attr_dev(stop1, "stop-color", "#FF6B00");
    			add_location(stop1, file$i, 117, 16, 4149);
    			attr_dev(linearGradient, "id", "paint0_linear_2960_1067");
    			attr_dev(linearGradient, "x1", "17.0726");
    			attr_dev(linearGradient, "y1", "5.00977");
    			attr_dev(linearGradient, "x2", "1.10357");
    			attr_dev(linearGradient, "y2", "13.0343");
    			attr_dev(linearGradient, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient, file$i, 108, 14, 3838);
    			add_location(defs, file$i, 107, 12, 3816);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "20");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-blze0n");
    			add_location(svg, file$i, 96, 10, 2976);
    			attr_dev(div3, "class", "subscribe__checkbox svelte-blze0n");
    			toggle_class(div3, "active", /*$subscribeAllState*/ ctx[0]);
    			add_location(div3, file$i, 95, 8, 2897);
    			attr_dev(div4, "class", "subscribe__text svelte-blze0n");
    			add_location(div4, file$i, 123, 8, 4289);
    			attr_dev(div5, "class", "subscribe__all svelte-blze0n");
    			add_location(div5, file$i, 94, 6, 2830);
    			attr_dev(div6, "class", "plans__wrapper__head svelte-blze0n");
    			add_location(div6, file$i, 88, 4, 2587);
    			attr_dev(div7, "class", "plans__wrapper svelte-blze0n");
    			add_location(div7, file$i, 87, 2, 2553);
    			attr_dev(div8, "class", "bottom__btns");
    			add_location(div8, file$i, 133, 2, 4462);
    			attr_dev(div9, "class", "plans__main svelte-blze0n");
    			add_location(div9, file$i, 74, 0, 2178);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div1);
    			append_dev(div1, h20);
    			append_dev(h20, t0);
    			append_dev(h20, span0);
    			append_dev(h20, t2);
    			append_dev(h20, span1);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			append_dev(div0, t5);
    			append_dev(div0, span2);
    			append_dev(div0, t7);
    			append_dev(div0, span3);
    			append_dev(div1, t9);
    			mount_component(planhead, div1, null);
    			append_dev(div9, t10);
    			append_dev(div9, div7);
    			append_dev(div7, div6);
    			append_dev(div6, h21);
    			append_dev(h21, t11);
    			append_dev(h21, span4);
    			append_dev(h21, t13);
    			append_dev(h21, span5);
    			append_dev(div6, t15);
    			append_dev(div6, div2);
    			append_dev(div6, t17);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, svg);
    			append_dev(svg, path);
    			append_dev(svg, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(div5, t18);
    			append_dev(div5, div4);
    			append_dev(div7, t20);
    			mount_component(planitems, div7, null);
    			append_dev(div9, t21);
    			if (if_block) if_block.m(div9, null);
    			append_dev(div9, t22);
    			append_dev(div9, div8);
    			mount_component(buttonleft, div8, null);
    			append_dev(div8, t23);
    			mount_component(buttonright, div8, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div5, "click", /*subscribeAllPlans*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$subscribeAllState*/ 1) {
    				toggle_class(div3, "active", /*$subscribeAllState*/ ctx[0]);
    			}

    			if (/*$plansModalState*/ ctx[1]) {
    				if (if_block) {
    					if (dirty & /*$plansModalState*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div9, t22);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(planhead.$$.fragment, local);
    			transition_in(planitems.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(buttonleft.$$.fragment, local);
    			transition_in(buttonright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(planhead.$$.fragment, local);
    			transition_out(planitems.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(buttonleft.$$.fragment, local);
    			transition_out(buttonright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			destroy_component(planhead);
    			destroy_component(planitems);
    			if (if_block) if_block.d();
    			destroy_component(buttonleft);
    			destroy_component(buttonright);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $subscribeAllState;
    	let $allocatedContributions;
    	let $disableAllDropdown;
    	let $headSteps;
    	let $plansModalState;
    	validate_store(subscribeAllState, 'subscribeAllState');
    	component_subscribe($$self, subscribeAllState, $$value => $$invalidate(0, $subscribeAllState = $$value));
    	validate_store(allocatedContributions, 'allocatedContributions');
    	component_subscribe($$self, allocatedContributions, $$value => $$invalidate(6, $allocatedContributions = $$value));
    	validate_store(disableAllDropdown, 'disableAllDropdown');
    	component_subscribe($$self, disableAllDropdown, $$value => $$invalidate(7, $disableAllDropdown = $$value));
    	validate_store(headSteps, 'headSteps');
    	component_subscribe($$self, headSteps, $$value => $$invalidate(8, $headSteps = $$value));
    	validate_store(plansModalState, 'plansModalState');
    	component_subscribe($$self, plansModalState, $$value => $$invalidate(1, $plansModalState = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Plan', slots, []);
    	let changeCounter = 0;

    	let prevStep = () => {
    		decrementStep();
    	};

    	let nextStep = () => {
    		if (validate()) {
    			set_store_value(headSteps, $headSteps.thirdStep = true, $headSteps);

    			if (changeCounter === 0) {
    				incrementStep();
    				changeCounter += 1;
    			}
    		} else {
    			alert("Chouse all 100% of your money");
    		}
    	};

    	let validate = () => {
    		let sumOfPlans = $allocatedContributions.safe + $allocatedContributions.adventure + $allocatedContributions.founder;
    		console.log(sumOfPlans);

    		if (sumOfPlans > 99 && sumOfPlans <= 100) {
    			return true;
    		} else {
    			return false;
    		}
    	};

    	function subscribeAllPlans() {
    		if (!$subscribeAllState) {
    			set_store_value(disableAllDropdown, $disableAllDropdown = true, $disableAllDropdown);
    			set_store_value(allocatedContributions, $allocatedContributions.safe = 33.33, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.safeName = "1/3 of Total Contribution", $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.adventure = 33.33, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.adventureName = "1/3 of Total Contribution", $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.founder = 33.33, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.founderName = "1/3 of Total Contribution", $allocatedContributions);
    			set_store_value(subscribeAllState, $subscribeAllState = true, $subscribeAllState);
    		} else {
    			set_store_value(disableAllDropdown, $disableAllDropdown = false, $disableAllDropdown);
    			set_store_value(allocatedContributions, $allocatedContributions.safe = 0, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.safeName = "0 of Total Contribution", $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.adventure = 0, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.adventureName = "0 of Total Contribution", $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.founder = 0, $allocatedContributions);
    			set_store_value(allocatedContributions, $allocatedContributions.founderName = "0 of Total Contribution", $allocatedContributions);
    			set_store_value(subscribeAllState, $subscribeAllState = false, $subscribeAllState);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<Plan> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		headSteps,
    		incrementStep,
    		decrementStep,
    		subscribeAllState,
    		disableAllDropdown,
    		plansModalState,
    		allocatedContributions,
    		PlanHead,
    		ButtonLeft,
    		ButtonRight,
    		PlanItems,
    		PlanModal,
    		changeCounter,
    		prevStep,
    		nextStep,
    		validate,
    		subscribeAllPlans,
    		$subscribeAllState,
    		$allocatedContributions,
    		$disableAllDropdown,
    		$headSteps,
    		$plansModalState
    	});

    	$$self.$inject_state = $$props => {
    		if ('changeCounter' in $$props) changeCounter = $$props.changeCounter;
    		if ('prevStep' in $$props) $$invalidate(2, prevStep = $$props.prevStep);
    		if ('nextStep' in $$props) $$invalidate(3, nextStep = $$props.nextStep);
    		if ('validate' in $$props) validate = $$props.validate;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$subscribeAllState, $plansModalState, prevStep, nextStep, subscribeAllPlans];
    }

    class Plan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Plan",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    const allowItemIndex = writable (1);

    const confirmPopUpState = writable(false);
    // export const confirmPopUpSubmited = writable(false)
     
    const infoFormErrorMessage = writable({
        userName: '',
        email: '',
        phone: '',
        password: '',
    });

    const infoFormErrorState = writable(false);
    const infoFormErrorStates = writable({
        userName: false,
        email: false,
        phone: false,
        password: false,
        confirmPassword: false
    });

    const infoFormData = writable({
        userName: '',
        email: '',
        phone: '',
        password: '',
        confirmPassword: ''
    });

    /* src\components\FinalReview.svelte generated by Svelte v3.48.0 */
    const file$h = "src\\components\\FinalReview.svelte";

    function create_fragment$h(ctx) {
    	let div52;
    	let div51;
    	let div2;
    	let div0;
    	let t0_value = /*$infoFormData*/ ctx[6].userName + "";
    	let t0;
    	let t1;
    	let t2;
    	let div1;
    	let span0;
    	let t3;
    	let div50;
    	let h3;
    	let t5;
    	let div49;
    	let div10;
    	let div7;
    	let div5;
    	let div3;
    	let svg0;
    	let path0;
    	let t6;
    	let div4;
    	let t8;
    	let div6;
    	let t10;
    	let div9;
    	let div8;
    	let t11_value = /*$contributionData*/ ctx[4].currencySymbol + "";
    	let t11;
    	let t12_value = /*$contributionData*/ ctx[4].monthlyValue + "";
    	let t12;
    	let t13;
    	let t14_value = /*$contributionData*/ ctx[4].nextPaymentDay + "";
    	let t14;
    	let t15;
    	let t16_value = /*$contributionData*/ ctx[4].nextPaymentMonth + "";
    	let t16;
    	let t17;
    	let t18;
    	let t19;
    	let div29;
    	let div15;
    	let div13;
    	let div11;
    	let svg1;
    	let path1;
    	let t20;
    	let div12;
    	let t22;
    	let div14;
    	let t24;
    	let div28;
    	let div19;
    	let div16;
    	let t26;
    	let div17;
    	let t27_value = /*$allocatedContributions*/ ctx[5].safe + "";
    	let t27;
    	let t28;
    	let t29;
    	let div18;
    	let t30_value = /*$contributionData*/ ctx[4].currencySymbol + "";
    	let t30;
    	let t31_value = Math.round(/*safePrice*/ ctx[1]) + "";
    	let t31;
    	let t32;
    	let div23;
    	let div20;
    	let t34;
    	let div21;
    	let t35_value = /*$allocatedContributions*/ ctx[5].adventure + "";
    	let t35;
    	let t36;
    	let t37;
    	let div22;
    	let t38_value = /*$contributionData*/ ctx[4].currencySymbol + "";
    	let t38;
    	let t39_value = Math.round(/*adventurePrice*/ ctx[2]) + "";
    	let t39;
    	let t40;
    	let div27;
    	let div24;
    	let t42;
    	let div25;
    	let t43_value = /*$allocatedContributions*/ ctx[5].founder + "";
    	let t43;
    	let t44;
    	let t45;
    	let div26;
    	let t46_value = /*$contributionData*/ ctx[4].currencySymbol + "";
    	let t46;
    	let t47_value = Math.round(/*founderPrice*/ ctx[3]) + "";
    	let t47;
    	let t48;
    	let div38;
    	let div34;
    	let div32;
    	let div30;
    	let svg2;
    	let path2;
    	let t49;
    	let div31;
    	let t51;
    	let div33;
    	let t53;
    	let div37;
    	let div36;
    	let svg3;
    	let g;
    	let path3;
    	let path4;
    	let path5;
    	let defs;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let t54;
    	let div35;
    	let t56;
    	let div48;
    	let div43;
    	let div41;
    	let div39;
    	let svg4;
    	let path6;
    	let t57;
    	let div40;
    	let t59;
    	let div42;
    	let t61;
    	let div47;
    	let div44;
    	let t62;
    	let t63_value = /*$infoFormData*/ ctx[6].userName + "";
    	let t63;
    	let t64;
    	let div45;
    	let t65;
    	let t66_value = /*$infoFormData*/ ctx[6].phone + "";
    	let t66;
    	let t67;
    	let div46;
    	let t68;
    	let t69_value = /*$infoFormData*/ ctx[6].email + "";
    	let t69;
    	let t70;
    	let button;
    	let span1;
    	let svg5;
    	let path7;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div52 = element("div");
    			div51 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = text(" LET'S MAKE SURE WE'VE GOT EVERYTHING RIGHT!");
    			t2 = space();
    			div1 = element("div");
    			span0 = element("span");
    			t3 = space();
    			div50 = element("div");
    			h3 = element("h3");
    			h3.textContent = "Final Review";
    			t5 = space();
    			div49 = element("div");
    			div10 = element("div");
    			div7 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t6 = space();
    			div4 = element("div");
    			div4.textContent = "Contribution";
    			t8 = space();
    			div6 = element("div");
    			div6.textContent = "Change";
    			t10 = space();
    			div9 = element("div");
    			div8 = element("div");
    			t11 = text(t11_value);
    			t12 = text(t12_value);
    			t13 = text("\r\n              USD per Month Starting ");
    			t14 = text(t14_value);
    			t15 = text("th ");
    			t16 = text(t16_value);
    			t17 = space();
    			t18 = text(/*currentYear*/ ctx[0]);
    			t19 = space();
    			div29 = element("div");
    			div15 = element("div");
    			div13 = element("div");
    			div11 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t20 = space();
    			div12 = element("div");
    			div12.textContent = "Plan";
    			t22 = space();
    			div14 = element("div");
    			div14.textContent = "Change";
    			t24 = space();
    			div28 = element("div");
    			div19 = element("div");
    			div16 = element("div");
    			div16.textContent = "Safe";
    			t26 = space();
    			div17 = element("div");
    			t27 = text(t27_value);
    			t28 = text("%");
    			t29 = space();
    			div18 = element("div");
    			t30 = text(t30_value);
    			t31 = text(t31_value);
    			t32 = space();
    			div23 = element("div");
    			div20 = element("div");
    			div20.textContent = "Adventure";
    			t34 = space();
    			div21 = element("div");
    			t35 = text(t35_value);
    			t36 = text("%");
    			t37 = space();
    			div22 = element("div");
    			t38 = text(t38_value);
    			t39 = text(t39_value);
    			t40 = space();
    			div27 = element("div");
    			div24 = element("div");
    			div24.textContent = "Founder";
    			t42 = space();
    			div25 = element("div");
    			t43 = text(t43_value);
    			t44 = text("%");
    			t45 = space();
    			div26 = element("div");
    			t46 = text(t46_value);
    			t47 = text(t47_value);
    			t48 = space();
    			div38 = element("div");
    			div34 = element("div");
    			div32 = element("div");
    			div30 = element("div");
    			svg2 = svg_element("svg");
    			path2 = svg_element("path");
    			t49 = space();
    			div31 = element("div");
    			div31.textContent = "Legal";
    			t51 = space();
    			div33 = element("div");
    			div33.textContent = "Change";
    			t53 = space();
    			div37 = element("div");
    			div36 = element("div");
    			svg3 = svg_element("svg");
    			g = svg_element("g");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			defs = svg_element("defs");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			t54 = space();
    			div35 = element("div");
    			div35.textContent = "You agreed to all Terms & Conditions, Contract Agreement,\r\n                Privacy & Cookie";
    			t56 = space();
    			div48 = element("div");
    			div43 = element("div");
    			div41 = element("div");
    			div39 = element("div");
    			svg4 = svg_element("svg");
    			path6 = svg_element("path");
    			t57 = space();
    			div40 = element("div");
    			div40.textContent = "Information";
    			t59 = space();
    			div42 = element("div");
    			div42.textContent = "Change";
    			t61 = space();
    			div47 = element("div");
    			div44 = element("div");
    			t62 = text("N: ");
    			t63 = text(t63_value);
    			t64 = space();
    			div45 = element("div");
    			t65 = text("P: ");
    			t66 = text(t66_value);
    			t67 = space();
    			div46 = element("div");
    			t68 = text("E: ");
    			t69 = text(t69_value);
    			t70 = space();
    			button = element("button");
    			span1 = element("span");
    			span1.textContent = "Open Account";
    			svg5 = svg_element("svg");
    			path7 = svg_element("path");
    			attr_dev(div0, "class", "pop__up_head__text svelte-16igcsk");
    			add_location(div0, file$h, 54, 6, 1575);
    			attr_dev(span0, "class", "svelte-16igcsk");
    			add_location(span0, file$h, 57, 56, 1757);
    			attr_dev(div1, "class", "pop__up__close svelte-16igcsk");
    			add_location(div1, file$h, 57, 6, 1707);
    			attr_dev(div2, "class", "pop__up__head svelte-16igcsk");
    			add_location(div2, file$h, 53, 4, 1540);
    			attr_dev(h3, "class", "svelte-16igcsk");
    			add_location(h3, file$h, 60, 6, 1824);
    			attr_dev(path0, "d", "M21 18V19C21 20.1 20.1 21 19 21H5C3.89 21 3 20.1 3 19V5C3 3.9 3.89 3 5 3H19C20.1 3 21 3.9 21 5V6H12C10.89 6 10 6.9 10 8V16C10 17.1 10.89 18 12 18H21ZM12 16H22V8H12V16ZM16 13.5C15.17 13.5 14.5 12.83 14.5 12C14.5 11.17 15.17 10.5 16 10.5C16.83 10.5 17.5 11.17 17.5 12C17.5 12.83 16.83 13.5 16 13.5Z");
    			attr_dev(path0, "fill", "#3E6B2C");
    			add_location(path0, file$h, 74, 18, 2309);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svg__icon");
    			add_location(svg0, file$h, 66, 16, 2044);
    			attr_dev(div3, "class", "step__icon svelte-16igcsk");
    			add_location(div3, file$h, 65, 14, 2002);
    			attr_dev(div4, "class", "step__name svelte-16igcsk");
    			add_location(div4, file$h, 80, 14, 2756);
    			attr_dev(div5, "class", "step svelte-16igcsk");
    			add_location(div5, file$h, 64, 12, 1968);
    			attr_dev(div6, "class", "change__btn svelte-16igcsk");
    			add_location(div6, file$h, 82, 12, 2832);
    			attr_dev(div7, "class", "item__head svelte-16igcsk");
    			add_location(div7, file$h, 63, 10, 1930);
    			attr_dev(div8, "class", "text svelte-16igcsk");
    			add_location(div8, file$h, 85, 12, 2937);
    			attr_dev(div9, "class", "item__body svelte-16igcsk");
    			add_location(div9, file$h, 84, 10, 2899);
    			attr_dev(div10, "class", "pop__up__item svelte-16igcsk");
    			add_location(div10, file$h, 62, 8, 1891);
    			attr_dev(path1, "d", "M19 3H14.82C14.4 1.84 13.3 1 12 1C10.7 1 9.6 1.84 9.18 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM12 3C12.55 3 13 3.45 13 4C13 4.55 12.55 5 12 5C11.45 5 11 4.55 11 4C11 3.45 11.45 3 12 3ZM14 17H7V15H14V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z");
    			attr_dev(path1, "fill", "#3E6B2C");
    			add_location(path1, file$h, 104, 18, 3660);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "svg__icon");
    			add_location(svg1, file$h, 96, 16, 3395);
    			attr_dev(div11, "class", "step__icon svelte-16igcsk");
    			add_location(div11, file$h, 95, 14, 3353);
    			attr_dev(div12, "class", "step__name svelte-16igcsk");
    			add_location(div12, file$h, 110, 14, 4095);
    			attr_dev(div13, "class", "step svelte-16igcsk");
    			add_location(div13, file$h, 94, 12, 3319);
    			attr_dev(div14, "class", "change__btn svelte-16igcsk");
    			add_location(div14, file$h, 112, 12, 4163);
    			attr_dev(div15, "class", "item__head svelte-16igcsk");
    			add_location(div15, file$h, 93, 10, 3281);
    			attr_dev(div16, "class", "name svelte-16igcsk");
    			add_location(div16, file$h, 116, 14, 4313);
    			attr_dev(div17, "class", "persentage svelte-16igcsk");
    			add_location(div17, file$h, 117, 14, 4357);
    			attr_dev(div18, "class", "money svelte-16igcsk");
    			add_location(div18, file$h, 118, 14, 4434);
    			attr_dev(div19, "class", "item__plan save svelte-16igcsk");
    			add_location(div19, file$h, 115, 12, 4268);
    			attr_dev(div20, "class", "name svelte-16igcsk");
    			add_location(div20, file$h, 123, 14, 4634);
    			attr_dev(div21, "class", "persentage svelte-16igcsk");
    			add_location(div21, file$h, 124, 14, 4683);
    			attr_dev(div22, "class", "money svelte-16igcsk");
    			add_location(div22, file$h, 125, 14, 4765);
    			attr_dev(div23, "class", "item__plan adventure svelte-16igcsk");
    			add_location(div23, file$h, 122, 12, 4584);
    			attr_dev(div24, "class", "name svelte-16igcsk");
    			add_location(div24, file$h, 130, 14, 4968);
    			attr_dev(div25, "class", "persentage svelte-16igcsk");
    			add_location(div25, file$h, 131, 14, 5015);
    			attr_dev(div26, "class", "money svelte-16igcsk");
    			add_location(div26, file$h, 132, 14, 5095);
    			attr_dev(div27, "class", "item__plan founder svelte-16igcsk");
    			add_location(div27, file$h, 129, 12, 4920);
    			attr_dev(div28, "class", "item__body svelte-16igcsk");
    			add_location(div28, file$h, 114, 10, 4230);
    			attr_dev(div29, "class", "pop__up__item svelte-16igcsk");
    			add_location(div29, file$h, 92, 8, 3242);
    			attr_dev(path2, "d", "M19 3H5C3.9 3 3 3.9 3 5V19C3 20.1 3.9 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM14 17H7V15H14V17ZM17 13H7V11H17V13ZM17 9H7V7H17V9Z");
    			attr_dev(path2, "fill", "#3E6B2C");
    			add_location(path2, file$h, 150, 18, 5696);
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "width", "24");
    			attr_dev(svg2, "height", "24");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "class", "svg__icon");
    			add_location(svg2, file$h, 142, 16, 5431);
    			attr_dev(div30, "class", "step__icon svelte-16igcsk");
    			add_location(div30, file$h, 141, 14, 5389);
    			attr_dev(div31, "class", "step__name svelte-16igcsk");
    			add_location(div31, file$h, 156, 14, 5990);
    			attr_dev(div32, "class", "step svelte-16igcsk");
    			add_location(div32, file$h, 140, 12, 5355);
    			attr_dev(div33, "class", "change__btn svelte-16igcsk");
    			add_location(div33, file$h, 158, 12, 6059);
    			attr_dev(div34, "class", "item__head svelte-16igcsk");
    			add_location(div34, file$h, 139, 10, 5317);
    			attr_dev(path3, "d", "M0 3C0 1.34315 1.34315 0 3 0H21C22.6569 0 24 1.34315 24 3V21C24 22.6569 22.6569 24 21 24H3C1.34315 24 0 22.6569 0 21V3Z");
    			attr_dev(path3, "fill", "white");
    			add_location(path3, file$h, 170, 18, 6456);
    			attr_dev(path4, "d", "M9.08286 15.8212L5.92203 12.6604C5.76486 12.5086 5.55436 12.4246 5.33586 12.4265C5.11736 12.4284 4.90835 12.516 4.75384 12.6705C4.59934 12.825 4.5117 13.034 4.5098 13.2525C4.5079 13.471 4.59189 13.6815 4.74369 13.8387L8.49369 17.5887C8.64997 17.7449 8.86189 17.8327 9.08286 17.8327C9.30383 17.8327 9.51575 17.7449 9.67203 17.5887L18.8387 8.42203C18.9905 8.26486 19.0745 8.05436 19.0726 7.83586C19.0707 7.61736 18.983 7.40835 18.8285 7.25384C18.674 7.09934 18.465 7.0117 18.2465 7.0098C18.028 7.0079 17.8175 7.09189 17.6604 7.24369L9.08286 15.8212Z");
    			attr_dev(path4, "fill", "url(#paint0_linear_3580_15632)");
    			add_location(path4, file$h, 174, 18, 6682);
    			attr_dev(path5, "d", "M3 1H21V-1H3V1ZM23 3V21H25V3H23ZM21 23H3V25H21V23ZM1 21V3H-1V21H1ZM3 23C1.89543 23 1 22.1046 1 21H-1C-1 23.2091 0.790861 25 3 25V23ZM23 21C23 22.1046 22.1046 23 21 23V25C23.2091 25 25 23.2091 25 21H23ZM21 1C22.1046 1 23 1.89543 23 3H25C25 0.790861 23.2091 -1 21 -1V1ZM3 -1C0.790861 -1 -1 0.790861 -1 3H1C1 1.89543 1.89543 1 3 1V-1Z");
    			attr_dev(path5, "fill", "#DDDDDD");
    			add_location(path5, file$h, 178, 18, 7361);
    			attr_dev(g, "opacity", "0.5");
    			add_location(g, file$h, 169, 16, 6419);
    			attr_dev(stop0, "stop-color", "#FF2E00");
    			add_location(stop0, file$h, 192, 20, 8144);
    			attr_dev(stop1, "offset", "1");
    			attr_dev(stop1, "stop-color", "#FF6B00");
    			add_location(stop1, file$h, 193, 20, 8195);
    			attr_dev(linearGradient, "id", "paint0_linear_3580_15632");
    			attr_dev(linearGradient, "x1", "19.0726");
    			attr_dev(linearGradient, "y1", "7.00977");
    			attr_dev(linearGradient, "x2", "3.10357");
    			attr_dev(linearGradient, "y2", "15.0343");
    			attr_dev(linearGradient, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient, file$h, 184, 18, 7847);
    			add_location(defs, file$h, 183, 16, 7821);
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "width", "24");
    			attr_dev(svg3, "height", "24");
    			attr_dev(svg3, "viewBox", "0 0 24 24");
    			attr_dev(svg3, "fill", "none");
    			add_location(svg3, file$h, 162, 14, 6205);
    			attr_dev(div35, "class", "text svelte-16igcsk");
    			add_location(div35, file$h, 197, 14, 8335);
    			attr_dev(div36, "class", "legal__item svelte-16igcsk");
    			add_location(div36, file$h, 161, 12, 6164);
    			attr_dev(div37, "class", "item__body svelte-16igcsk");
    			add_location(div37, file$h, 160, 10, 6126);
    			attr_dev(div38, "class", "pop__up__item svelte-16igcsk");
    			add_location(div38, file$h, 138, 8, 5278);
    			attr_dev(path6, "d", "M10 0C4.48 0 0 4.48 0 10C0 15.52 4.48 20 10 20C15.52 20 20 15.52 20 10C20 4.48 15.52 0 10 0ZM11 15H9V9H11V15ZM11 7H9V5H11V7Z");
    			attr_dev(path6, "fill", "#3E6B2C");
    			add_location(path6, file$h, 216, 18, 8966);
    			attr_dev(svg4, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg4, "width", "20");
    			attr_dev(svg4, "height", "20");
    			attr_dev(svg4, "viewBox", "0 0 20 20");
    			attr_dev(svg4, "fill", "none");
    			attr_dev(svg4, "class", "svg__icon");
    			add_location(svg4, file$h, 208, 16, 8701);
    			attr_dev(div39, "class", "step__icon svelte-16igcsk");
    			add_location(div39, file$h, 207, 14, 8659);
    			attr_dev(div40, "class", "step__name svelte-16igcsk");
    			add_location(div40, file$h, 222, 14, 9241);
    			attr_dev(div41, "class", "step svelte-16igcsk");
    			add_location(div41, file$h, 206, 12, 8625);
    			attr_dev(div42, "class", "change__btn svelte-16igcsk");
    			add_location(div42, file$h, 224, 12, 9316);
    			attr_dev(div43, "class", "item__head svelte-16igcsk");
    			add_location(div43, file$h, 205, 10, 8587);
    			attr_dev(div44, "class", "text svelte-16igcsk");
    			add_location(div44, file$h, 227, 12, 9421);
    			attr_dev(div45, "class", "text svelte-16igcsk");
    			add_location(div45, file$h, 228, 12, 9486);
    			attr_dev(div46, "class", "text svelte-16igcsk");
    			add_location(div46, file$h, 229, 12, 9548);
    			attr_dev(div47, "class", "item__body svelte-16igcsk");
    			add_location(div47, file$h, 226, 10, 9383);
    			attr_dev(div48, "class", "pop__up__item svelte-16igcsk");
    			add_location(div48, file$h, 204, 8, 8548);
    			attr_dev(div49, "class", "pop__up__items svelte-16igcsk");
    			add_location(div49, file$h, 61, 6, 1853);
    			add_location(span1, file$h, 234, 9, 9715);
    			attr_dev(path7, "d", "M5.13119 1.43197C4.96715 1.59606 4.875 1.81858 4.875 2.05059C4.875 2.28261 4.96715 2.50513 5.13119 2.66922L9.46244 7.00047L5.13119 11.3317C4.9718 11.4967 4.8836 11.7178 4.8856 11.9472C4.88759 12.1766 4.97961 12.3961 5.14185 12.5583C5.30408 12.7205 5.52354 12.8126 5.75296 12.8146C5.98238 12.8166 6.20341 12.7284 6.36844 12.569L11.3183 7.61909C11.4823 7.45501 11.5745 7.23249 11.5745 7.00047C11.5745 6.76845 11.4823 6.54593 11.3183 6.38184L6.36844 1.43197C6.20435 1.26793 5.98183 1.17578 5.74981 1.17578C5.51779 1.17578 5.29527 1.26793 5.13119 1.43197Z");
    			attr_dev(path7, "fill", "white");
    			add_location(path7, file$h, 241, 10, 9912);
    			attr_dev(svg5, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg5, "width", "15");
    			attr_dev(svg5, "height", "14");
    			attr_dev(svg5, "viewBox", "0 0 15 14");
    			attr_dev(svg5, "fill", "none");
    			attr_dev(svg5, "class", "svelte-16igcsk");
    			add_location(svg5, file$h, 234, 34, 9740);
    			attr_dev(button, "class", "submt__btn svelte-16igcsk");
    			add_location(button, file$h, 233, 6, 9652);
    			attr_dev(div50, "class", "pop__up__body svelte-16igcsk");
    			add_location(div50, file$h, 59, 4, 1789);
    			attr_dev(div51, "class", "pop__up__wrapper svelte-16igcsk");
    			add_location(div51, file$h, 52, 2, 1504);
    			attr_dev(div52, "class", "pop__up svelte-16igcsk");
    			add_location(div52, file$h, 51, 0, 1479);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div52, anchor);
    			append_dev(div52, div51);
    			append_dev(div51, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, span0);
    			append_dev(div51, t3);
    			append_dev(div51, div50);
    			append_dev(div50, h3);
    			append_dev(div50, t5);
    			append_dev(div50, div49);
    			append_dev(div49, div10);
    			append_dev(div10, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div3);
    			append_dev(div3, svg0);
    			append_dev(svg0, path0);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    			append_dev(div10, t10);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			append_dev(div8, t11);
    			append_dev(div8, t12);
    			append_dev(div8, t13);
    			append_dev(div8, t14);
    			append_dev(div8, t15);
    			append_dev(div8, t16);
    			append_dev(div8, t17);
    			append_dev(div8, t18);
    			append_dev(div49, t19);
    			append_dev(div49, div29);
    			append_dev(div29, div15);
    			append_dev(div15, div13);
    			append_dev(div13, div11);
    			append_dev(div11, svg1);
    			append_dev(svg1, path1);
    			append_dev(div13, t20);
    			append_dev(div13, div12);
    			append_dev(div15, t22);
    			append_dev(div15, div14);
    			append_dev(div29, t24);
    			append_dev(div29, div28);
    			append_dev(div28, div19);
    			append_dev(div19, div16);
    			append_dev(div19, t26);
    			append_dev(div19, div17);
    			append_dev(div17, t27);
    			append_dev(div17, t28);
    			append_dev(div19, t29);
    			append_dev(div19, div18);
    			append_dev(div18, t30);
    			append_dev(div18, t31);
    			append_dev(div28, t32);
    			append_dev(div28, div23);
    			append_dev(div23, div20);
    			append_dev(div23, t34);
    			append_dev(div23, div21);
    			append_dev(div21, t35);
    			append_dev(div21, t36);
    			append_dev(div23, t37);
    			append_dev(div23, div22);
    			append_dev(div22, t38);
    			append_dev(div22, t39);
    			append_dev(div28, t40);
    			append_dev(div28, div27);
    			append_dev(div27, div24);
    			append_dev(div27, t42);
    			append_dev(div27, div25);
    			append_dev(div25, t43);
    			append_dev(div25, t44);
    			append_dev(div27, t45);
    			append_dev(div27, div26);
    			append_dev(div26, t46);
    			append_dev(div26, t47);
    			append_dev(div49, t48);
    			append_dev(div49, div38);
    			append_dev(div38, div34);
    			append_dev(div34, div32);
    			append_dev(div32, div30);
    			append_dev(div30, svg2);
    			append_dev(svg2, path2);
    			append_dev(div32, t49);
    			append_dev(div32, div31);
    			append_dev(div34, t51);
    			append_dev(div34, div33);
    			append_dev(div38, t53);
    			append_dev(div38, div37);
    			append_dev(div37, div36);
    			append_dev(div36, svg3);
    			append_dev(svg3, g);
    			append_dev(g, path3);
    			append_dev(g, path4);
    			append_dev(g, path5);
    			append_dev(svg3, defs);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(div36, t54);
    			append_dev(div36, div35);
    			append_dev(div49, t56);
    			append_dev(div49, div48);
    			append_dev(div48, div43);
    			append_dev(div43, div41);
    			append_dev(div41, div39);
    			append_dev(div39, svg4);
    			append_dev(svg4, path6);
    			append_dev(div41, t57);
    			append_dev(div41, div40);
    			append_dev(div43, t59);
    			append_dev(div43, div42);
    			append_dev(div48, t61);
    			append_dev(div48, div47);
    			append_dev(div47, div44);
    			append_dev(div44, t62);
    			append_dev(div44, t63);
    			append_dev(div47, t64);
    			append_dev(div47, div45);
    			append_dev(div45, t65);
    			append_dev(div45, t66);
    			append_dev(div47, t67);
    			append_dev(div47, div46);
    			append_dev(div46, t68);
    			append_dev(div46, t69);
    			append_dev(div50, t70);
    			append_dev(div50, button);
    			append_dev(button, span1);
    			append_dev(button, svg5);
    			append_dev(svg5, path7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*closePopUp*/ ctx[8], false, false, false),
    					listen_dev(button, "click", /*confirmAllData*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$infoFormData*/ 64 && t0_value !== (t0_value = /*$infoFormData*/ ctx[6].userName + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$contributionData*/ 16 && t11_value !== (t11_value = /*$contributionData*/ ctx[4].currencySymbol + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*$contributionData*/ 16 && t12_value !== (t12_value = /*$contributionData*/ ctx[4].monthlyValue + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$contributionData*/ 16 && t14_value !== (t14_value = /*$contributionData*/ ctx[4].nextPaymentDay + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$contributionData*/ 16 && t16_value !== (t16_value = /*$contributionData*/ ctx[4].nextPaymentMonth + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*currentYear*/ 1) set_data_dev(t18, /*currentYear*/ ctx[0]);
    			if (dirty & /*$allocatedContributions*/ 32 && t27_value !== (t27_value = /*$allocatedContributions*/ ctx[5].safe + "")) set_data_dev(t27, t27_value);
    			if (dirty & /*$contributionData*/ 16 && t30_value !== (t30_value = /*$contributionData*/ ctx[4].currencySymbol + "")) set_data_dev(t30, t30_value);
    			if (dirty & /*safePrice*/ 2 && t31_value !== (t31_value = Math.round(/*safePrice*/ ctx[1]) + "")) set_data_dev(t31, t31_value);
    			if (dirty & /*$allocatedContributions*/ 32 && t35_value !== (t35_value = /*$allocatedContributions*/ ctx[5].adventure + "")) set_data_dev(t35, t35_value);
    			if (dirty & /*$contributionData*/ 16 && t38_value !== (t38_value = /*$contributionData*/ ctx[4].currencySymbol + "")) set_data_dev(t38, t38_value);
    			if (dirty & /*adventurePrice*/ 4 && t39_value !== (t39_value = Math.round(/*adventurePrice*/ ctx[2]) + "")) set_data_dev(t39, t39_value);
    			if (dirty & /*$allocatedContributions*/ 32 && t43_value !== (t43_value = /*$allocatedContributions*/ ctx[5].founder + "")) set_data_dev(t43, t43_value);
    			if (dirty & /*$contributionData*/ 16 && t46_value !== (t46_value = /*$contributionData*/ ctx[4].currencySymbol + "")) set_data_dev(t46, t46_value);
    			if (dirty & /*founderPrice*/ 8 && t47_value !== (t47_value = Math.round(/*founderPrice*/ ctx[3]) + "")) set_data_dev(t47, t47_value);
    			if (dirty & /*$infoFormData*/ 64 && t63_value !== (t63_value = /*$infoFormData*/ ctx[6].userName + "")) set_data_dev(t63, t63_value);
    			if (dirty & /*$infoFormData*/ 64 && t66_value !== (t66_value = /*$infoFormData*/ ctx[6].phone + "")) set_data_dev(t66, t66_value);
    			if (dirty & /*$infoFormData*/ 64 && t69_value !== (t69_value = /*$infoFormData*/ ctx[6].email + "")) set_data_dev(t69, t69_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div52);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $contributionData;
    	let $allocatedContributions;
    	let $confirmPopUpState;
    	let $headSteps;
    	let $infoFormData;
    	validate_store(contributionData, 'contributionData');
    	component_subscribe($$self, contributionData, $$value => $$invalidate(4, $contributionData = $$value));
    	validate_store(allocatedContributions, 'allocatedContributions');
    	component_subscribe($$self, allocatedContributions, $$value => $$invalidate(5, $allocatedContributions = $$value));
    	validate_store(confirmPopUpState, 'confirmPopUpState');
    	component_subscribe($$self, confirmPopUpState, $$value => $$invalidate(10, $confirmPopUpState = $$value));
    	validate_store(headSteps, 'headSteps');
    	component_subscribe($$self, headSteps, $$value => $$invalidate(11, $headSteps = $$value));
    	validate_store(infoFormData, 'infoFormData');
    	component_subscribe($$self, infoFormData, $$value => $$invalidate(6, $infoFormData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinalReview', slots, []);
    	let changeCounter = 0;
    	let currentDate = new Date();
    	let currentYear = currentDate.getFullYear();
    	let currentDay = currentDate.getDate();

    	if ($contributionData.nextPaymentMonth === "January") {
    		if ($contributionData.period === "Monthly") {
    			currentYear = currentYear + 1;
    		} else if ($contributionData.period === "Bi-Monthly" && currentDay >= 15) {
    			currentYear = currentYear + 1;
    		}
    	}

    	let confirmAllData = () => {
    		set_store_value(confirmPopUpState, $confirmPopUpState = false, $confirmPopUpState);
    		set_store_value(headSteps, $headSteps.fifthStep = true, $headSteps);

    		if (changeCounter === 0) {
    			incrementStep();
    			changeCounter += 1;
    		}
    	};

    	let closePopUp = () => {
    		set_store_value(confirmPopUpState, $confirmPopUpState = false, $confirmPopUpState);
    	};

    	let safePrice = 0, adventurePrice = 0, founderPrice = 0;

    	beforeUpdate(() => {
    		$$invalidate(1, safePrice = $allocatedContributions.safe * $contributionData.monthlyValue / 100);
    		$$invalidate(2, adventurePrice = $allocatedContributions.adventure * $contributionData.monthlyValue / 100);
    		$$invalidate(3, founderPrice = $allocatedContributions.founder * $contributionData.monthlyValue / 100);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FinalReview> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		contributionData,
    		allocatedContributions,
    		infoFormData,
    		confirmPopUpState,
    		headSteps,
    		incrementStep,
    		beforeUpdate,
    		changeCounter,
    		currentDate,
    		currentYear,
    		currentDay,
    		confirmAllData,
    		closePopUp,
    		safePrice,
    		adventurePrice,
    		founderPrice,
    		$contributionData,
    		$allocatedContributions,
    		$confirmPopUpState,
    		$headSteps,
    		$infoFormData
    	});

    	$$self.$inject_state = $$props => {
    		if ('changeCounter' in $$props) changeCounter = $$props.changeCounter;
    		if ('currentDate' in $$props) currentDate = $$props.currentDate;
    		if ('currentYear' in $$props) $$invalidate(0, currentYear = $$props.currentYear);
    		if ('currentDay' in $$props) currentDay = $$props.currentDay;
    		if ('confirmAllData' in $$props) $$invalidate(7, confirmAllData = $$props.confirmAllData);
    		if ('closePopUp' in $$props) $$invalidate(8, closePopUp = $$props.closePopUp);
    		if ('safePrice' in $$props) $$invalidate(1, safePrice = $$props.safePrice);
    		if ('adventurePrice' in $$props) $$invalidate(2, adventurePrice = $$props.adventurePrice);
    		if ('founderPrice' in $$props) $$invalidate(3, founderPrice = $$props.founderPrice);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*currentYear*/ 1) ;
    	};

    	return [
    		currentYear,
    		safePrice,
    		adventurePrice,
    		founderPrice,
    		$contributionData,
    		$allocatedContributions,
    		$infoFormData,
    		confirmAllData,
    		closePopUp
    	];
    }

    class FinalReview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinalReview",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    function collapse (node, params) {

        const defaultParams = {
            open: true,
            duration: 0.2,
            easing: 'ease'
        };

        params = Object.assign(defaultParams, params);

        const noop = () => {};
        let transitionEndResolve = noop;
        let transitionEndReject = noop;

        const listener = node.addEventListener('transitionend', () => {
            transitionEndResolve();
            transitionEndResolve = noop;
            transitionEndReject = noop;
        });

        // convenience functions
        async function asyncTransitionEnd () {
            return new Promise((resolve, reject) => {
                transitionEndResolve = resolve;
                transitionEndReject = reject;
            })
        }

        async function nextFrame () {
            return new Promise(requestAnimationFrame)
        }

        function transition () {
            return `height ${params.duration}s ${params.easing}`
        }

        // set initial styles
        node.style.overflow = 'hidden';
        node.style.transition = transition();
        node.style.height = params.open ? 'auto' : '0px';

        async function enter () {

            // height is already in pixels
            // start the transition
            node.style.height = node.scrollHeight + 'px';

            // wait for transition to end,
            // then switch back to height auto
            try {
                await asyncTransitionEnd();
                node.style.height = 'auto';
            } catch(err) {
                // interrupted by a leave transition
            }

        }

        async function leave () {

            if (node.style.height === 'auto') {

                // temporarily turn transitions off
                node.style.transition = 'none';
                await nextFrame();

                // set height to pixels, and turn transition back on
                node.style.height = node.scrollHeight + 'px';
                node.style.transition = transition();
                await nextFrame();

                // start the transition
                node.style.height = '0px';

            }
            else {

                // we are interrupting an enter transition
                transitionEndReject();
                node.style.height = '0px';

            }

        }

        function update (newParams) {
            params = Object.assign(params, newParams);
            params.open ? enter() : leave();
        }

        function destroy () {
            node.removeEventListener('transitionend', listener);
        }

        return { update, destroy }

    }

    /* node_modules\svelte-collapsible\src\components\Accordion.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1$2 } = globals;
    const file$g = "node_modules\\svelte-collapsible\\src\\components\\Accordion.svelte";

    function create_fragment$g(ctx) {
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", "accordion svelte-da9j5z");
    			add_location(ul, file$g, 34, 0, 829);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accordion', slots, ['default']);
    	let { duration = 0.2 } = $$props;
    	let { easing = 'ease' } = $$props;
    	let { key = null } = $$props;
    	const dispatch = createEventDispatcher();

    	// create a store for the children to access
    	const store = writable({ key, duration, easing });

    	// when the store changes, update the key prop
    	const unsubscribe = store.subscribe(s => {
    		$$invalidate(0, key = s.key);
    		dispatch('change', { key });
    	});

    	// make the store available to children
    	setContext('svelte-collapsible-accordion', store);

    	onDestroy(unsubscribe);
    	const writable_props = ['duration', 'easing', 'key'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accordion> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('duration' in $$props) $$invalidate(1, duration = $$props.duration);
    		if ('easing' in $$props) $$invalidate(2, easing = $$props.easing);
    		if ('key' in $$props) $$invalidate(0, key = $$props.key);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		setContext,
    		createEventDispatcher,
    		writable,
    		duration,
    		easing,
    		key,
    		dispatch,
    		store,
    		unsubscribe
    	});

    	$$self.$inject_state = $$props => {
    		if ('duration' in $$props) $$invalidate(1, duration = $$props.duration);
    		if ('easing' in $$props) $$invalidate(2, easing = $$props.easing);
    		if ('key' in $$props) $$invalidate(0, key = $$props.key);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*key*/ 1) {
    			// when the key prop changes, update the store
    			store.update(s => Object.assign(s, { key }));
    		}
    	};

    	return [key, duration, easing, $$scope, slots];
    }

    class Accordion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { duration: 1, easing: 2, key: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accordion",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get duration() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set duration(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get easing() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set easing(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<Accordion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Accordion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-collapsible\src\components\AccordionItem.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1$1 } = globals;
    const file$f = "node_modules\\svelte-collapsible\\src\\components\\AccordionItem.svelte";
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_header_slot_changes = dirty => ({});
    const get_header_slot_context = ctx => ({});

    function create_fragment$f(ctx) {
    	let li;
    	let div0;
    	let t0;
    	let div1;
    	let collapse_action;
    	let t1;
    	let li_aria_expanded_value;
    	let current;
    	let mounted;
    	let dispose;
    	const header_slot_template = /*#slots*/ ctx[6].header;
    	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[5], get_header_slot_context);
    	const body_slot_template = /*#slots*/ ctx[6].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[5], get_body_slot_context);
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			li = element("li");
    			div0 = element("div");
    			if (header_slot) header_slot.c();
    			t0 = space();
    			div1 = element("div");
    			if (body_slot) body_slot.c();
    			t1 = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "accordion-item-header svelte-13br4ya");
    			add_location(div0, file$f, 32, 4, 598);
    			attr_dev(div1, "class", "accordion-item-body");
    			add_location(div1, file$f, 36, 4, 705);
    			attr_dev(li, "class", "accordion-item");
    			attr_dev(li, "aria-expanded", li_aria_expanded_value = /*params*/ ctx[0].open);
    			add_location(li, file$f, 30, 0, 537);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div0);

    			if (header_slot) {
    				header_slot.m(div0, null);
    			}

    			append_dev(li, t0);
    			append_dev(li, div1);

    			if (body_slot) {
    				body_slot.m(div1, null);
    			}

    			append_dev(li, t1);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*handleToggle*/ ctx[2], false, false, false),
    					action_destroyer(collapse_action = collapse.call(null, div1, /*params*/ ctx[0]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (header_slot) {
    				if (header_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						header_slot,
    						header_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[5], dirty, get_header_slot_changes),
    						get_header_slot_context
    					);
    				}
    			}

    			if (body_slot) {
    				if (body_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						body_slot,
    						body_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(body_slot_template, /*$$scope*/ ctx[5], dirty, get_body_slot_changes),
    						get_body_slot_context
    					);
    				}
    			}

    			if (collapse_action && is_function(collapse_action.update) && dirty & /*params*/ 1) collapse_action.update.call(null, /*params*/ ctx[0]);

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[5],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*params*/ 1 && li_aria_expanded_value !== (li_aria_expanded_value = /*params*/ ctx[0].open)) {
    				attr_dev(li, "aria-expanded", li_aria_expanded_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header_slot, local);
    			transition_in(body_slot, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header_slot, local);
    			transition_out(body_slot, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (header_slot) header_slot.d(detaching);
    			if (body_slot) body_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let params;
    	let $store;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AccordionItem', slots, ['header','body','default']);
    	let { key } = $$props;
    	const store = getContext('svelte-collapsible-accordion');
    	validate_store(store, 'store');
    	component_subscribe($$self, store, value => $$invalidate(4, $store = value));

    	function handleToggle() {
    		if (params.open) {
    			store.update(s => Object.assign(s, { key: null }));
    		} else {
    			store.update(s => Object.assign(s, { key }));
    		}
    	}

    	const writable_props = ['key'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AccordionItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('key' in $$props) $$invalidate(3, key = $$props.key);
    		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		collapse,
    		key,
    		store,
    		handleToggle,
    		params,
    		$store
    	});

    	$$self.$inject_state = $$props => {
    		if ('key' in $$props) $$invalidate(3, key = $$props.key);
    		if ('params' in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$store, key*/ 24) {
    			$$invalidate(0, params = {
    				open: $store.key === key,
    				duration: $store.duration,
    				easing: $store.easing
    			});
    		}
    	};

    	return [params, store, handleToggle, key, $store, $$scope, slots];
    }

    class AccordionItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { key: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AccordionItem",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[3] === undefined && !('key' in props)) {
    			console.warn("<AccordionItem> was created without expected prop 'key'");
    		}
    	}

    	get key() {
    		throw new Error("<AccordionItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<AccordionItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const legalItems = [
      {
        key: "a",
        checked: false,
        name: "Terms & Condition",
        title: "Terms and Conditions",
        text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ultricies gravida enim, ac congue diam. Cras faucibus lorem et velit tempus viverra. Nulla facilisi. Nulla neque neque, bibendum sit amet consequat id, dapibus at purus. Etiam cursus varius turpis, vitae efficitur erat facilisis ut. Quisque fringilla in purus non posuere. Mauris lobortis et orci at scelerisque. Curabitur elementum consectetur eros eget congue. Morbi aliquet eleifend elementum. Ut et tempor quam, id sodales mi. Nullam eget placerat orci. Suspendisse rhoncus, sem eu interdum facilisis, ipsum mi egestas purus, in vulputate erat neque eget nibh. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Integer sit amet eros nec arcu vestibulum mattis. Pellentesque vitae mauris nunc. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at.",
      },
      {
        key: "b",
        checked: false,
        name: "Contract Agreement",
        title: "Terms and Conditions",
        text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ultricies gravida enim, ac congue diam. Cras faucibus lorem et velit tempus viverra. Nulla facilisi. Nulla neque neque, bibendum sit amet consequat id, dapibus at purus. Etiam cursus varius turpis, vitae efficitur erat facilisis ut. Quisque fringilla in purus non posuere. Mauris lobortis et orci at scelerisque. Curabitur elementum consectetur eros eget congue. Morbi aliquet eleifend elementum. Ut et tempor quam, id sodales mi. Nullam eget placerat orci. Suspendisse rhoncus, sem eu interdum facilisis, ipsum mi egestas purus, in vulputate erat neque eget nibh. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Integer sit amet eros nec arcu vestibulum mattis. Pellentesque vitae mauris nunc. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at.",
      },
      {
        key: "c",
        checked: false,
        name: "Privacy & Cookie",
        title: "Terms and Conditions",
        text: "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean ultricies gravida enim, ac congue diam. Cras faucibus lorem et velit tempus viverra. Nulla facilisi. Nulla neque neque, bibendum sit amet consequat id, dapibus at purus. Etiam cursus varius turpis, vitae efficitur erat facilisis ut. Quisque fringilla in purus non posuere. Mauris lobortis et orci at scelerisque. Curabitur elementum consectetur eros eget congue. Morbi aliquet eleifend elementum. Ut et tempor quam, id sodales mi. Nullam eget placerat orci. Suspendisse rhoncus, sem eu interdum facilisis, ipsum mi egestas purus, in vulputate erat neque eget nibh. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Integer sit amet eros nec arcu vestibulum mattis. Pellentesque vitae mauris nunc. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at. Mauris sed tortor ac nibh tempor gravida. Donec cursus, nulla et auctor sollicitudin, nibh orci accumsan nunc, ultricies malesuada risus lectus vitae mauris. Ut eu tortor porttitor ligula venenatis sodales. Morbi sollicitudin nulla vel neque hendrerit euismod non eget purus. Donec non nisi quis urna sagittis sagittis. Fusce ut varius velit. Fusce ac sollicitudin tellus. Integer finibus, purus quis volutpat dignissim, velit leo interdum est, vel auctor neque odio vel lectus. Vivamus ac tortor nulla. Suspendisse tempor imperdiet eros, placerat maximus augue elementum vel. Aliquam varius leo magna, ut finibus ipsum ullamcorper at.",
      },
    ];
    const checkboxStates = writable({
      a:false,
      b:false,
      c:false
    });

    /* src\components\legal\Legal.svelte generated by Svelte v3.48.0 */

    const { Object: Object_1, console: console_1$2 } = globals;
    const file$e = "src\\components\\legal\\Legal.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[12] = list;
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (46:10) 
    function create_header_slot(ctx) {
    	let div1;
    	let div0;
    	let input;
    	let t0;
    	let p;
    	let t1;
    	let t2_value = /*item*/ ctx[11].name + "";
    	let t2;
    	let t3;
    	let svg;
    	let path;
    	let t4;
    	let mounted;
    	let dispose;

    	function input_change_handler() {
    		/*input_change_handler*/ ctx[6].call(input, /*item*/ ctx[11]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			p = element("p");
    			t1 = text("I agree to ");
    			t2 = text(t2_value);
    			t3 = space();
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t4 = space();
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-1gxwax");
    			add_location(input, file$e, 47, 14, 1388);
    			attr_dev(p, "class", "svelte-1gxwax");
    			add_location(p, file$e, 55, 14, 1658);
    			attr_dev(div0, "class", "column svelte-1gxwax");
    			add_location(div0, file$e, 46, 12, 1352);
    			attr_dev(path, "d", "M4.29279 7.30529C4.48031 7.11782 4.73462 7.0125 4.99979 7.0125C5.26495 7.0125 5.51926 7.11782 5.70679 7.30529L11.9998 13.5983L18.2928 7.30529C18.385 7.20978 18.4954 7.1336 18.6174 7.08119C18.7394 7.02878 18.8706 7.00119 19.0034 7.00004C19.1362 6.99888 19.2678 7.02419 19.3907 7.07447C19.5136 7.12475 19.6253 7.199 19.7192 7.29289C19.8131 7.38679 19.8873 7.49844 19.9376 7.62133C19.9879 7.74423 20.0132 7.87591 20.012 8.00869C20.0109 8.14147 19.9833 8.27269 19.9309 8.39469C19.8785 8.5167 19.8023 8.62704 19.7068 8.71929L12.7068 15.7193C12.5193 15.9068 12.265 16.0121 11.9998 16.0121C11.7346 16.0121 11.4803 15.9068 11.2928 15.7193L4.29279 8.71929C4.10532 8.53176 4 8.27745 4 8.01229C4 7.74712 4.10532 7.49282 4.29279 7.30529Z");
    			attr_dev(path, "fill", "white");
    			add_location(path, file$e, 65, 14, 1950);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "arrow");
    			add_location(svg, file$e, 57, 12, 1721);
    			attr_dev(div1, "slot", "header");
    			attr_dev(div1, "class", "header svelte-1gxwax");
    			add_location(div1, file$e, 45, 10, 1304);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			input.checked = /*$checkboxStates*/ ctx[1][/*item*/ ctx[11].key];
    			append_dev(div0, t0);
    			append_dev(div0, p);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(div1, t3);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(div1, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "click", /*click_handler*/ ctx[5], false, false, false),
    					listen_dev(input, "change", input_change_handler)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$checkboxStates, legalItems*/ 2) {
    				input.checked = /*$checkboxStates*/ ctx[1][/*item*/ ctx[11].key];
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_header_slot.name,
    		type: "slot",
    		source: "(46:10) ",
    		ctx
    	});

    	return block;
    }

    // (72:10) 
    function create_body_slot(ctx) {
    	let div;
    	let h3;
    	let t0_value = /*item*/ ctx[11].title + "";
    	let t0;
    	let t1;
    	let p;
    	let t2_value = /*item*/ ctx[11].text + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = space();
    			p = element("p");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(h3, "class", "body__head svelte-1gxwax");
    			add_location(h3, file$e, 72, 12, 2844);
    			attr_dev(p, "class", "svelte-1gxwax");
    			add_location(p, file$e, 73, 12, 2898);
    			attr_dev(div, "slot", "body");
    			attr_dev(div, "class", "body svelte-1gxwax");
    			add_location(div, file$e, 71, 10, 2800);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, t0);
    			append_dev(div, t1);
    			append_dev(div, p);
    			append_dev(p, t2);
    			append_dev(div, t3);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(72:10) ",
    		ctx
    	});

    	return block;
    }

    // (44:6) {#each legalItems as item}
    function create_each_block$2(ctx) {
    	let accordionitem;
    	let current;

    	accordionitem = new AccordionItem({
    			props: {
    				key: /*item*/ ctx[11].key,
    				$$slots: {
    					body: [create_body_slot],
    					header: [create_header_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(accordionitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accordionitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const accordionitem_changes = {};

    			if (dirty & /*$$scope, $checkboxStates*/ 16386) {
    				accordionitem_changes.$$scope = { dirty, ctx };
    			}

    			accordionitem.$set(accordionitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accordionitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accordionitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accordionitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(44:6) {#each legalItems as item}",
    		ctx
    	});

    	return block;
    }

    // (43:4) <Accordion bind:key={openedKey}>
    function create_default_slot(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = legalItems;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*legalItems, $checkboxStates, console*/ 2) {
    				each_value = legalItems;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(43:4) <Accordion bind:key={openedKey}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div3;
    	let div1;
    	let h2;
    	let t0;
    	let span;
    	let t2;
    	let accordion;
    	let updating_key;
    	let t3;
    	let div0;
    	let input;
    	let t4;
    	let p;
    	let t6;
    	let div2;
    	let buttonleft;
    	let t7;
    	let buttonright;
    	let current;
    	let mounted;
    	let dispose;

    	function accordion_key_binding(value) {
    		/*accordion_key_binding*/ ctx[7](value);
    	}

    	let accordion_props = {
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	if (/*openedKey*/ ctx[0] !== void 0) {
    		accordion_props.key = /*openedKey*/ ctx[0];
    	}

    	accordion = new Accordion({ props: accordion_props, $$inline: true });
    	binding_callbacks.push(() => bind(accordion, 'key', accordion_key_binding));
    	buttonleft = new ButtonLeft({ $$inline: true });
    	buttonleft.$on("click", /*prevStep*/ ctx[3]);
    	buttonright = new ButtonRight({ $$inline: true });
    	buttonright.$on("click", /*nextStep*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div1 = element("div");
    			h2 = element("h2");
    			t0 = text("Legal ");
    			span = element("span");
    			span.textContent = "Agreement";
    			t2 = space();
    			create_component(accordion.$$.fragment);
    			t3 = space();
    			div0 = element("div");
    			input = element("input");
    			t4 = space();
    			p = element("p");
    			p.textContent = "I agree to all Terms & Conditions, Contract Agreement, Privacy & Cookie";
    			t6 = space();
    			div2 = element("div");
    			create_component(buttonleft.$$.fragment);
    			t7 = space();
    			create_component(buttonright.$$.fragment);
    			attr_dev(span, "class", "green svelte-1gxwax");
    			add_location(span, file$e, 41, 30, 1139);
    			attr_dev(h2, "class", "heading svelte-1gxwax");
    			add_location(h2, file$e, 41, 4, 1113);
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "svelte-1gxwax");
    			add_location(input, file$e, 81, 6, 3061);
    			add_location(p, file$e, 87, 6, 3180);
    			attr_dev(div0, "class", "agree__all svelte-1gxwax");
    			add_location(div0, file$e, 80, 4, 3029);
    			add_location(div1, file$e, 40, 2, 1102);
    			attr_dev(div2, "class", "bottom__btns");
    			add_location(div2, file$e, 93, 2, 3304);
    			attr_dev(div3, "class", "legal__wrapper svelte-1gxwax");
    			add_location(div3, file$e, 39, 0, 1070);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, h2);
    			append_dev(h2, t0);
    			append_dev(h2, span);
    			append_dev(div1, t2);
    			mount_component(accordion, div1, null);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			append_dev(div0, t4);
    			append_dev(div0, p);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			mount_component(buttonleft, div2, null);
    			append_dev(div2, t7);
    			mount_component(buttonright, div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*change_handler*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const accordion_changes = {};

    			if (dirty & /*$$scope, $checkboxStates*/ 16386) {
    				accordion_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_key && dirty & /*openedKey*/ 1) {
    				updating_key = true;
    				accordion_changes.key = /*openedKey*/ ctx[0];
    				add_flush_callback(() => updating_key = false);
    			}

    			accordion.$set(accordion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accordion.$$.fragment, local);
    			transition_in(buttonleft.$$.fragment, local);
    			transition_in(buttonright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accordion.$$.fragment, local);
    			transition_out(buttonleft.$$.fragment, local);
    			transition_out(buttonright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(accordion);
    			destroy_component(buttonleft);
    			destroy_component(buttonright);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $headSteps;
    	let $checkboxStates;
    	validate_store(headSteps, 'headSteps');
    	component_subscribe($$self, headSteps, $$value => $$invalidate(10, $headSteps = $$value));
    	validate_store(checkboxStates, 'checkboxStates');
    	component_subscribe($$self, checkboxStates, $$value => $$invalidate(1, $checkboxStates = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Legal', slots, []);
    	let openedKey = "a";
    	let changeCounter = 0;

    	function agreeAllTerms(e) {
    		if (e.target.checked) {
    			set_store_value(checkboxStates, $checkboxStates.a = true, $checkboxStates);
    			set_store_value(checkboxStates, $checkboxStates.b = true, $checkboxStates);
    			set_store_value(checkboxStates, $checkboxStates.c = true, $checkboxStates);
    		} else {
    			set_store_value(checkboxStates, $checkboxStates.a = false, $checkboxStates);
    			set_store_value(checkboxStates, $checkboxStates.b = false, $checkboxStates);
    			set_store_value(checkboxStates, $checkboxStates.c = false, $checkboxStates);
    		}
    	}

    	let prevStep = () => {
    		decrementStep();
    	};

    	let nextStep = () => {
    		let state = Object.values($checkboxStates).every(value => value === true);

    		if (state) {
    			set_store_value(headSteps, $headSteps.fourthStep = true, $headSteps);

    			if (changeCounter === 0) {
    				incrementStep();
    				changeCounter += 1;
    			}
    		} else {
    			alert("fill all checkbox");
    		}
    	};

    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<Legal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = e => {
    		e.stopPropagation();
    		console.log("clicked");
    	};

    	function input_change_handler(item) {
    		$checkboxStates[item.key] = this.checked;
    		checkboxStates.set($checkboxStates);
    	}

    	function accordion_key_binding(value) {
    		openedKey = value;
    		$$invalidate(0, openedKey);
    	}

    	const change_handler = e => {
    		agreeAllTerms(e);
    	};

    	$$self.$capture_state = () => ({
    		Accordion,
    		AccordionItem,
    		openedKey,
    		checkboxStates,
    		legalItems,
    		headSteps,
    		incrementStep,
    		decrementStep,
    		ButtonLeft,
    		ButtonRight,
    		changeCounter,
    		agreeAllTerms,
    		prevStep,
    		nextStep,
    		$headSteps,
    		$checkboxStates
    	});

    	$$self.$inject_state = $$props => {
    		if ('openedKey' in $$props) $$invalidate(0, openedKey = $$props.openedKey);
    		if ('changeCounter' in $$props) changeCounter = $$props.changeCounter;
    		if ('prevStep' in $$props) $$invalidate(3, prevStep = $$props.prevStep);
    		if ('nextStep' in $$props) $$invalidate(4, nextStep = $$props.nextStep);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		openedKey,
    		$checkboxStates,
    		agreeAllTerms,
    		prevStep,
    		nextStep,
    		click_handler,
    		input_change_handler,
    		accordion_key_binding,
    		change_handler
    	];
    }

    class Legal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Legal",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* src\components\information\TabForms\NameForm.svelte generated by Svelte v3.48.0 */

    const file$d = "src\\components\\information\\TabForms\\NameForm.svelte";

    function create_fragment$d(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let input0;
    	let t4;
    	let input1;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Name";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Please put your legal name and choose a username";
    			t3 = space();
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			input1 = element("input");
    			attr_dev(div0, "class", "tab__head");
    			add_location(div0, file$d, 1, 4, 32);
    			attr_dev(div1, "class", "tab__subhead");
    			add_location(div1, file$d, 2, 4, 71);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "input");
    			attr_dev(input0, "placeholder", "First Name");
    			attr_dev(input0, "autocomplete", "");
    			add_location(input0, file$d, 6, 6, 210);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "input");
    			attr_dev(input1, "placeholder", "Last Name");
    			attr_dev(input1, "autocomplete", "");
    			add_location(input1, file$d, 7, 6, 290);
    			attr_dev(div2, "class", "tab__form__fields");
    			add_location(div2, file$d, 5, 4, 171);
    			attr_dev(div3, "class", "tab__wrapper");
    			add_location(div3, file$d, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			append_dev(div2, t4);
    			append_dev(div2, input1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NameForm', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NameForm> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class NameForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NameForm",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /*
     * International Telephone Input v17.0.16
     * https://github.com/jackocnr/intl-tel-input.git
     * Licensed under the MIT license
     */

    var intlTelInput$1 = createCommonjsModule(function (module) {
    // wrap in UMD
    (function(factory) {
        if (module.exports) module.exports = factory(); else window.intlTelInput = factory();
    })(function(undefined$1) {
        return function() {
            // Array of country objects for the flag dropdown.
            // Here is the criteria for the plugin to support a given country/territory
            // - It has an iso2 code: https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
            // - It has it's own country calling code (it is not a sub-region of another country): https://en.wikipedia.org/wiki/List_of_country_calling_codes
            // - It has a flag in the region-flags project: https://github.com/behdad/region-flags/tree/gh-pages/png
            // - It is supported by libphonenumber (it must be listed on this page): https://github.com/googlei18n/libphonenumber/blob/master/resources/ShortNumberMetadata.xml
            // Each country array has the following information:
            // [
            //    Country name,
            //    iso2 code,
            //    International dial code,
            //    Order (if >1 country with same dial code),
            //    Area codes
            // ]
            var allCountries = [ [ "Afghanistan (‫افغانستان‬‎)", "af", "93" ], [ "Albania (Shqipëri)", "al", "355" ], [ "Algeria (‫الجزائر‬‎)", "dz", "213" ], [ "American Samoa", "as", "1", 5, [ "684" ] ], [ "Andorra", "ad", "376" ], [ "Angola", "ao", "244" ], [ "Anguilla", "ai", "1", 6, [ "264" ] ], [ "Antigua and Barbuda", "ag", "1", 7, [ "268" ] ], [ "Argentina", "ar", "54" ], [ "Armenia (Հայաստան)", "am", "374" ], [ "Aruba", "aw", "297" ], [ "Ascension Island", "ac", "247" ], [ "Australia", "au", "61", 0 ], [ "Austria (Österreich)", "at", "43" ], [ "Azerbaijan (Azərbaycan)", "az", "994" ], [ "Bahamas", "bs", "1", 8, [ "242" ] ], [ "Bahrain (‫البحرين‬‎)", "bh", "973" ], [ "Bangladesh (বাংলাদেশ)", "bd", "880" ], [ "Barbados", "bb", "1", 9, [ "246" ] ], [ "Belarus (Беларусь)", "by", "375" ], [ "Belgium (België)", "be", "32" ], [ "Belize", "bz", "501" ], [ "Benin (Bénin)", "bj", "229" ], [ "Bermuda", "bm", "1", 10, [ "441" ] ], [ "Bhutan (འབྲུག)", "bt", "975" ], [ "Bolivia", "bo", "591" ], [ "Bosnia and Herzegovina (Босна и Херцеговина)", "ba", "387" ], [ "Botswana", "bw", "267" ], [ "Brazil (Brasil)", "br", "55" ], [ "British Indian Ocean Territory", "io", "246" ], [ "British Virgin Islands", "vg", "1", 11, [ "284" ] ], [ "Brunei", "bn", "673" ], [ "Bulgaria (България)", "bg", "359" ], [ "Burkina Faso", "bf", "226" ], [ "Burundi (Uburundi)", "bi", "257" ], [ "Cambodia (កម្ពុជា)", "kh", "855" ], [ "Cameroon (Cameroun)", "cm", "237" ], [ "Canada", "ca", "1", 1, [ "204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905" ] ], [ "Cape Verde (Kabu Verdi)", "cv", "238" ], [ "Caribbean Netherlands", "bq", "599", 1, [ "3", "4", "7" ] ], [ "Cayman Islands", "ky", "1", 12, [ "345" ] ], [ "Central African Republic (République centrafricaine)", "cf", "236" ], [ "Chad (Tchad)", "td", "235" ], [ "Chile", "cl", "56" ], [ "China (中国)", "cn", "86" ], [ "Christmas Island", "cx", "61", 2, [ "89164" ] ], [ "Cocos (Keeling) Islands", "cc", "61", 1, [ "89162" ] ], [ "Colombia", "co", "57" ], [ "Comoros (‫جزر القمر‬‎)", "km", "269" ], [ "Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243" ], [ "Congo (Republic) (Congo-Brazzaville)", "cg", "242" ], [ "Cook Islands", "ck", "682" ], [ "Costa Rica", "cr", "506" ], [ "Côte d’Ivoire", "ci", "225" ], [ "Croatia (Hrvatska)", "hr", "385" ], [ "Cuba", "cu", "53" ], [ "Curaçao", "cw", "599", 0 ], [ "Cyprus (Κύπρος)", "cy", "357" ], [ "Czech Republic (Česká republika)", "cz", "420" ], [ "Denmark (Danmark)", "dk", "45" ], [ "Djibouti", "dj", "253" ], [ "Dominica", "dm", "1", 13, [ "767" ] ], [ "Dominican Republic (República Dominicana)", "do", "1", 2, [ "809", "829", "849" ] ], [ "Ecuador", "ec", "593" ], [ "Egypt (‫مصر‬‎)", "eg", "20" ], [ "El Salvador", "sv", "503" ], [ "Equatorial Guinea (Guinea Ecuatorial)", "gq", "240" ], [ "Eritrea", "er", "291" ], [ "Estonia (Eesti)", "ee", "372" ], [ "Eswatini", "sz", "268" ], [ "Ethiopia", "et", "251" ], [ "Falkland Islands (Islas Malvinas)", "fk", "500" ], [ "Faroe Islands (Føroyar)", "fo", "298" ], [ "Fiji", "fj", "679" ], [ "Finland (Suomi)", "fi", "358", 0 ], [ "France", "fr", "33" ], [ "French Guiana (Guyane française)", "gf", "594" ], [ "French Polynesia (Polynésie française)", "pf", "689" ], [ "Gabon", "ga", "241" ], [ "Gambia", "gm", "220" ], [ "Georgia (საქართველო)", "ge", "995" ], [ "Germany (Deutschland)", "de", "49" ], [ "Ghana (Gaana)", "gh", "233" ], [ "Gibraltar", "gi", "350" ], [ "Greece (Ελλάδα)", "gr", "30" ], [ "Greenland (Kalaallit Nunaat)", "gl", "299" ], [ "Grenada", "gd", "1", 14, [ "473" ] ], [ "Guadeloupe", "gp", "590", 0 ], [ "Guam", "gu", "1", 15, [ "671" ] ], [ "Guatemala", "gt", "502" ], [ "Guernsey", "gg", "44", 1, [ "1481", "7781", "7839", "7911" ] ], [ "Guinea (Guinée)", "gn", "224" ], [ "Guinea-Bissau (Guiné Bissau)", "gw", "245" ], [ "Guyana", "gy", "592" ], [ "Haiti", "ht", "509" ], [ "Honduras", "hn", "504" ], [ "Hong Kong (香港)", "hk", "852" ], [ "Hungary (Magyarország)", "hu", "36" ], [ "Iceland (Ísland)", "is", "354" ], [ "India (भारत)", "in", "91" ], [ "Indonesia", "id", "62" ], [ "Iran (‫ایران‬‎)", "ir", "98" ], [ "Iraq (‫العراق‬‎)", "iq", "964" ], [ "Ireland", "ie", "353" ], [ "Isle of Man", "im", "44", 2, [ "1624", "74576", "7524", "7924", "7624" ] ], [ "Israel (‫ישראל‬‎)", "il", "972" ], [ "Italy (Italia)", "it", "39", 0 ], [ "Jamaica", "jm", "1", 4, [ "876", "658" ] ], [ "Japan (日本)", "jp", "81" ], [ "Jersey", "je", "44", 3, [ "1534", "7509", "7700", "7797", "7829", "7937" ] ], [ "Jordan (‫الأردن‬‎)", "jo", "962" ], [ "Kazakhstan (Казахстан)", "kz", "7", 1, [ "33", "7" ] ], [ "Kenya", "ke", "254" ], [ "Kiribati", "ki", "686" ], [ "Kosovo", "xk", "383" ], [ "Kuwait (‫الكويت‬‎)", "kw", "965" ], [ "Kyrgyzstan (Кыргызстан)", "kg", "996" ], [ "Laos (ລາວ)", "la", "856" ], [ "Latvia (Latvija)", "lv", "371" ], [ "Lebanon (‫لبنان‬‎)", "lb", "961" ], [ "Lesotho", "ls", "266" ], [ "Liberia", "lr", "231" ], [ "Libya (‫ليبيا‬‎)", "ly", "218" ], [ "Liechtenstein", "li", "423" ], [ "Lithuania (Lietuva)", "lt", "370" ], [ "Luxembourg", "lu", "352" ], [ "Macau (澳門)", "mo", "853" ], [ "North Macedonia (Македонија)", "mk", "389" ], [ "Madagascar (Madagasikara)", "mg", "261" ], [ "Malawi", "mw", "265" ], [ "Malaysia", "my", "60" ], [ "Maldives", "mv", "960" ], [ "Mali", "ml", "223" ], [ "Malta", "mt", "356" ], [ "Marshall Islands", "mh", "692" ], [ "Martinique", "mq", "596" ], [ "Mauritania (‫موريتانيا‬‎)", "mr", "222" ], [ "Mauritius (Moris)", "mu", "230" ], [ "Mayotte", "yt", "262", 1, [ "269", "639" ] ], [ "Mexico (México)", "mx", "52" ], [ "Micronesia", "fm", "691" ], [ "Moldova (Republica Moldova)", "md", "373" ], [ "Monaco", "mc", "377" ], [ "Mongolia (Монгол)", "mn", "976" ], [ "Montenegro (Crna Gora)", "me", "382" ], [ "Montserrat", "ms", "1", 16, [ "664" ] ], [ "Morocco (‫المغرب‬‎)", "ma", "212", 0 ], [ "Mozambique (Moçambique)", "mz", "258" ], [ "Myanmar (Burma) (မြန်မာ)", "mm", "95" ], [ "Namibia (Namibië)", "na", "264" ], [ "Nauru", "nr", "674" ], [ "Nepal (नेपाल)", "np", "977" ], [ "Netherlands (Nederland)", "nl", "31" ], [ "New Caledonia (Nouvelle-Calédonie)", "nc", "687" ], [ "New Zealand", "nz", "64" ], [ "Nicaragua", "ni", "505" ], [ "Niger (Nijar)", "ne", "227" ], [ "Nigeria", "ng", "234" ], [ "Niue", "nu", "683" ], [ "Norfolk Island", "nf", "672" ], [ "North Korea (조선 민주주의 인민 공화국)", "kp", "850" ], [ "Northern Mariana Islands", "mp", "1", 17, [ "670" ] ], [ "Norway (Norge)", "no", "47", 0 ], [ "Oman (‫عُمان‬‎)", "om", "968" ], [ "Pakistan (‫پاکستان‬‎)", "pk", "92" ], [ "Palau", "pw", "680" ], [ "Palestine (‫فلسطين‬‎)", "ps", "970" ], [ "Panama (Panamá)", "pa", "507" ], [ "Papua New Guinea", "pg", "675" ], [ "Paraguay", "py", "595" ], [ "Peru (Perú)", "pe", "51" ], [ "Philippines", "ph", "63" ], [ "Poland (Polska)", "pl", "48" ], [ "Portugal", "pt", "351" ], [ "Puerto Rico", "pr", "1", 3, [ "787", "939" ] ], [ "Qatar (‫قطر‬‎)", "qa", "974" ], [ "Réunion (La Réunion)", "re", "262", 0 ], [ "Romania (România)", "ro", "40" ], [ "Russia (Россия)", "ru", "7", 0 ], [ "Rwanda", "rw", "250" ], [ "Saint Barthélemy", "bl", "590", 1 ], [ "Saint Helena", "sh", "290" ], [ "Saint Kitts and Nevis", "kn", "1", 18, [ "869" ] ], [ "Saint Lucia", "lc", "1", 19, [ "758" ] ], [ "Saint Martin (Saint-Martin (partie française))", "mf", "590", 2 ], [ "Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508" ], [ "Saint Vincent and the Grenadines", "vc", "1", 20, [ "784" ] ], [ "Samoa", "ws", "685" ], [ "San Marino", "sm", "378" ], [ "São Tomé and Príncipe (São Tomé e Príncipe)", "st", "239" ], [ "Saudi Arabia (‫المملكة العربية السعودية‬‎)", "sa", "966" ], [ "Senegal (Sénégal)", "sn", "221" ], [ "Serbia (Србија)", "rs", "381" ], [ "Seychelles", "sc", "248" ], [ "Sierra Leone", "sl", "232" ], [ "Singapore", "sg", "65" ], [ "Sint Maarten", "sx", "1", 21, [ "721" ] ], [ "Slovakia (Slovensko)", "sk", "421" ], [ "Slovenia (Slovenija)", "si", "386" ], [ "Solomon Islands", "sb", "677" ], [ "Somalia (Soomaaliya)", "so", "252" ], [ "South Africa", "za", "27" ], [ "South Korea (대한민국)", "kr", "82" ], [ "South Sudan (‫جنوب السودان‬‎)", "ss", "211" ], [ "Spain (España)", "es", "34" ], [ "Sri Lanka (ශ්‍රී ලංකාව)", "lk", "94" ], [ "Sudan (‫السودان‬‎)", "sd", "249" ], [ "Suriname", "sr", "597" ], [ "Svalbard and Jan Mayen", "sj", "47", 1, [ "79" ] ], [ "Sweden (Sverige)", "se", "46" ], [ "Switzerland (Schweiz)", "ch", "41" ], [ "Syria (‫سوريا‬‎)", "sy", "963" ], [ "Taiwan (台灣)", "tw", "886" ], [ "Tajikistan", "tj", "992" ], [ "Tanzania", "tz", "255" ], [ "Thailand (ไทย)", "th", "66" ], [ "Timor-Leste", "tl", "670" ], [ "Togo", "tg", "228" ], [ "Tokelau", "tk", "690" ], [ "Tonga", "to", "676" ], [ "Trinidad and Tobago", "tt", "1", 22, [ "868" ] ], [ "Tunisia (‫تونس‬‎)", "tn", "216" ], [ "Turkey (Türkiye)", "tr", "90" ], [ "Turkmenistan", "tm", "993" ], [ "Turks and Caicos Islands", "tc", "1", 23, [ "649" ] ], [ "Tuvalu", "tv", "688" ], [ "U.S. Virgin Islands", "vi", "1", 24, [ "340" ] ], [ "Uganda", "ug", "256" ], [ "Ukraine (Україна)", "ua", "380" ], [ "United Arab Emirates (‫الإمارات العربية المتحدة‬‎)", "ae", "971" ], [ "United Kingdom", "gb", "44", 0 ], [ "United States", "us", "1", 0 ], [ "Uruguay", "uy", "598" ], [ "Uzbekistan (Oʻzbekiston)", "uz", "998" ], [ "Vanuatu", "vu", "678" ], [ "Vatican City (Città del Vaticano)", "va", "39", 1, [ "06698" ] ], [ "Venezuela", "ve", "58" ], [ "Vietnam (Việt Nam)", "vn", "84" ], [ "Wallis and Futuna (Wallis-et-Futuna)", "wf", "681" ], [ "Western Sahara (‫الصحراء الغربية‬‎)", "eh", "212", 1, [ "5288", "5289" ] ], [ "Yemen (‫اليمن‬‎)", "ye", "967" ], [ "Zambia", "zm", "260" ], [ "Zimbabwe", "zw", "263" ], [ "Åland Islands", "ax", "358", 1, [ "18" ] ] ];
            // loop over all of the countries above, restructuring the data to be objects with named keys
            for (var i = 0; i < allCountries.length; i++) {
                var c = allCountries[i];
                allCountries[i] = {
                    name: c[0],
                    iso2: c[1],
                    dialCode: c[2],
                    priority: c[3] || 0,
                    areaCodes: c[4] || null
                };
            }
            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            }
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            function _createClass(Constructor, protoProps, staticProps) {
                if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                if (staticProps) _defineProperties(Constructor, staticProps);
                return Constructor;
            }
            var intlTelInputGlobals = {
                getInstance: function getInstance(input) {
                    var id = input.getAttribute("data-intl-tel-input-id");
                    return window.intlTelInputGlobals.instances[id];
                },
                instances: {},
                // using a global like this allows us to mock it in the tests
                documentReady: function documentReady() {
                    return document.readyState === "complete";
                }
            };
            if (typeof window === "object") window.intlTelInputGlobals = intlTelInputGlobals;
            // these vars persist through all instances of the plugin
            var id = 0;
            var defaults = {
                // whether or not to allow the dropdown
                allowDropdown: true,
                // if there is just a dial code in the input: remove it on blur
                autoHideDialCode: true,
                // add a placeholder in the input with an example number for the selected country
                autoPlaceholder: "polite",
                // modify the parentClass
                customContainer: "",
                // modify the auto placeholder
                customPlaceholder: null,
                // append menu to specified element
                dropdownContainer: null,
                // don't display these countries
                excludeCountries: [],
                // format the input value during initialisation and on setNumber
                formatOnDisplay: true,
                // geoIp lookup function
                geoIpLookup: null,
                // inject a hidden input with this name, and on submit, populate it with the result of getNumber
                hiddenInput: "",
                // initial country
                initialCountry: "",
                // localized country names e.g. { 'de': 'Deutschland' }
                localizedCountries: null,
                // don't insert international dial codes
                nationalMode: true,
                // display only these countries
                onlyCountries: [],
                // number type to use for placeholders
                placeholderNumberType: "MOBILE",
                // the countries at the top of the list. defaults to united states and united kingdom
                preferredCountries: [ "us", "gb" ],
                // display the country dial code next to the selected flag so it's not part of the typed number
                separateDialCode: false,
                // specify the path to the libphonenumber script to enable validation/formatting
                utilsScript: ""
            };
            // https://en.wikipedia.org/wiki/List_of_North_American_Numbering_Plan_area_codes#Non-geographic_area_codes
            var regionlessNanpNumbers = [ "800", "822", "833", "844", "855", "866", "877", "880", "881", "882", "883", "884", "885", "886", "887", "888", "889" ];
            // utility function to iterate over an object. can't use Object.entries or native forEach because
            // of IE11
            var forEachProp = function forEachProp(obj, callback) {
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; i++) {
                    callback(keys[i], obj[keys[i]]);
                }
            };
            // run a method on each instance of the plugin
            var forEachInstance = function forEachInstance(method) {
                forEachProp(window.intlTelInputGlobals.instances, function(key) {
                    window.intlTelInputGlobals.instances[key][method]();
                });
            };
            // this is our plugin class that we will create an instance of
            // eslint-disable-next-line no-unused-vars
            var Iti = /*#__PURE__*/
            function() {
                function Iti(input, options) {
                    var _this = this;
                    _classCallCheck(this, Iti);
                    this.id = id++;
                    this.telInput = input;
                    this.activeItem = null;
                    this.highlightedItem = null;
                    // process specified options / defaults
                    // alternative to Object.assign, which isn't supported by IE11
                    var customOptions = options || {};
                    this.options = {};
                    forEachProp(defaults, function(key, value) {
                        _this.options[key] = customOptions.hasOwnProperty(key) ? customOptions[key] : value;
                    });
                    this.hadInitialPlaceholder = Boolean(input.getAttribute("placeholder"));
                }
                _createClass(Iti, [ {
                    key: "_init",
                    value: function _init() {
                        var _this2 = this;
                        // if in nationalMode, disable options relating to dial codes
                        if (this.options.nationalMode) this.options.autoHideDialCode = false;
                        // if separateDialCode then doesn't make sense to A) insert dial code into input
                        // (autoHideDialCode), and B) display national numbers (because we're displaying the country
                        // dial code next to them)
                        if (this.options.separateDialCode) {
                            this.options.autoHideDialCode = this.options.nationalMode = false;
                        }
                        // we cannot just test screen size as some smartphones/website meta tags will report desktop
                        // resolutions
                        // Note: for some reason jasmine breaks if you put this in the main Plugin function with the
                        // rest of these declarations
                        // Note: to target Android Mobiles (and not Tablets), we must find 'Android' and 'Mobile'
                        this.isMobile = /Android.+Mobile|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                        if (this.isMobile) {
                            // trigger the mobile dropdown css
                            document.body.classList.add("iti-mobile");
                            // on mobile, we want a full screen dropdown, so we must append it to the body
                            if (!this.options.dropdownContainer) this.options.dropdownContainer = document.body;
                        }
                        // these promises get resolved when their individual requests complete
                        // this way the dev can do something like iti.promise.then(...) to know when all requests are
                        // complete
                        if (typeof Promise !== "undefined") {
                            var autoCountryPromise = new Promise(function(resolve, reject) {
                                _this2.resolveAutoCountryPromise = resolve;
                                _this2.rejectAutoCountryPromise = reject;
                            });
                            var utilsScriptPromise = new Promise(function(resolve, reject) {
                                _this2.resolveUtilsScriptPromise = resolve;
                                _this2.rejectUtilsScriptPromise = reject;
                            });
                            this.promise = Promise.all([ autoCountryPromise, utilsScriptPromise ]);
                        } else {
                            // prevent errors when Promise doesn't exist
                            this.resolveAutoCountryPromise = this.rejectAutoCountryPromise = function() {};
                            this.resolveUtilsScriptPromise = this.rejectUtilsScriptPromise = function() {};
                        }
                        // in various situations there could be no country selected initially, but we need to be able
                        // to assume this variable exists
                        this.selectedCountryData = {};
                        // process all the data: onlyCountries, excludeCountries, preferredCountries etc
                        this._processCountryData();
                        // generate the markup
                        this._generateMarkup();
                        // set the initial state of the input value and the selected flag
                        this._setInitialState();
                        // start all of the event listeners: autoHideDialCode, input keydown, selectedFlag click
                        this._initListeners();
                        // utils script, and auto country
                        this._initRequests();
                    }
                }, {
                    key: "_processCountryData",
                    value: function _processCountryData() {
                        // process onlyCountries or excludeCountries array if present
                        this._processAllCountries();
                        // process the countryCodes map
                        this._processCountryCodes();
                        // process the preferredCountries
                        this._processPreferredCountries();
                        // translate countries according to localizedCountries option
                        if (this.options.localizedCountries) this._translateCountriesByLocale();
                        // sort countries by name
                        if (this.options.onlyCountries.length || this.options.localizedCountries) {
                            this.countries.sort(this._countryNameSort);
                        }
                    }
                }, {
                    key: "_addCountryCode",
                    value: function _addCountryCode(iso2, countryCode, priority) {
                        if (countryCode.length > this.countryCodeMaxLen) {
                            this.countryCodeMaxLen = countryCode.length;
                        }
                        if (!this.countryCodes.hasOwnProperty(countryCode)) {
                            this.countryCodes[countryCode] = [];
                        }
                        // bail if we already have this country for this countryCode
                        for (var i = 0; i < this.countryCodes[countryCode].length; i++) {
                            if (this.countryCodes[countryCode][i] === iso2) return;
                        }
                        // check for undefined as 0 is falsy
                        var index = priority !== undefined$1 ? priority : this.countryCodes[countryCode].length;
                        this.countryCodes[countryCode][index] = iso2;
                    }
                }, {
                    key: "_processAllCountries",
                    value: function _processAllCountries() {
                        if (this.options.onlyCountries.length) {
                            var lowerCaseOnlyCountries = this.options.onlyCountries.map(function(country) {
                                return country.toLowerCase();
                            });
                            this.countries = allCountries.filter(function(country) {
                                return lowerCaseOnlyCountries.indexOf(country.iso2) > -1;
                            });
                        } else if (this.options.excludeCountries.length) {
                            var lowerCaseExcludeCountries = this.options.excludeCountries.map(function(country) {
                                return country.toLowerCase();
                            });
                            this.countries = allCountries.filter(function(country) {
                                return lowerCaseExcludeCountries.indexOf(country.iso2) === -1;
                            });
                        } else {
                            this.countries = allCountries;
                        }
                    }
                }, {
                    key: "_translateCountriesByLocale",
                    value: function _translateCountriesByLocale() {
                        for (var i = 0; i < this.countries.length; i++) {
                            var iso = this.countries[i].iso2.toLowerCase();
                            if (this.options.localizedCountries.hasOwnProperty(iso)) {
                                this.countries[i].name = this.options.localizedCountries[iso];
                            }
                        }
                    }
                }, {
                    key: "_countryNameSort",
                    value: function _countryNameSort(a, b) {
                        return a.name.localeCompare(b.name);
                    }
                }, {
                    key: "_processCountryCodes",
                    value: function _processCountryCodes() {
                        this.countryCodeMaxLen = 0;
                        // here we store just dial codes
                        this.dialCodes = {};
                        // here we store "country codes" (both dial codes and their area codes)
                        this.countryCodes = {};
                        // first: add dial codes
                        for (var i = 0; i < this.countries.length; i++) {
                            var c = this.countries[i];
                            if (!this.dialCodes[c.dialCode]) this.dialCodes[c.dialCode] = true;
                            this._addCountryCode(c.iso2, c.dialCode, c.priority);
                        }
                        // next: add area codes
                        // this is a second loop over countries, to make sure we have all of the "root" countries
                        // already in the map, so that we can access them, as each time we add an area code substring
                        // to the map, we also need to include the "root" country's code, as that also matches
                        for (var _i = 0; _i < this.countries.length; _i++) {
                            var _c = this.countries[_i];
                            // area codes
                            if (_c.areaCodes) {
                                var rootCountryCode = this.countryCodes[_c.dialCode][0];
                                // for each area code
                                for (var j = 0; j < _c.areaCodes.length; j++) {
                                    var areaCode = _c.areaCodes[j];
                                    // for each digit in the area code to add all partial matches as well
                                    for (var k = 1; k < areaCode.length; k++) {
                                        var partialDialCode = _c.dialCode + areaCode.substr(0, k);
                                        // start with the root country, as that also matches this dial code
                                        this._addCountryCode(rootCountryCode, partialDialCode);
                                        this._addCountryCode(_c.iso2, partialDialCode);
                                    }
                                    // add the full area code
                                    this._addCountryCode(_c.iso2, _c.dialCode + areaCode);
                                }
                            }
                        }
                    }
                }, {
                    key: "_processPreferredCountries",
                    value: function _processPreferredCountries() {
                        this.preferredCountries = [];
                        for (var i = 0; i < this.options.preferredCountries.length; i++) {
                            var countryCode = this.options.preferredCountries[i].toLowerCase();
                            var countryData = this._getCountryData(countryCode, false, true);
                            if (countryData) this.preferredCountries.push(countryData);
                        }
                    }
                }, {
                    key: "_createEl",
                    value: function _createEl(name, attrs, container) {
                        var el = document.createElement(name);
                        if (attrs) forEachProp(attrs, function(key, value) {
                            return el.setAttribute(key, value);
                        });
                        if (container) container.appendChild(el);
                        return el;
                    }
                }, {
                    key: "_generateMarkup",
                    value: function _generateMarkup() {
                        // if autocomplete does not exist on the element and its form, then
                        // prevent autocomplete as there's no safe, cross-browser event we can react to, so it can
                        // easily put the plugin in an inconsistent state e.g. the wrong flag selected for the
                        // autocompleted number, which on submit could mean wrong number is saved (esp in nationalMode)
                        if (!this.telInput.hasAttribute("autocomplete") && !(this.telInput.form && this.telInput.form.hasAttribute("autocomplete"))) {
                            this.telInput.setAttribute("autocomplete", "off");
                        }
                        // containers (mostly for positioning)
                        var parentClass = "iti";
                        if (this.options.allowDropdown) parentClass += " iti--allow-dropdown";
                        if (this.options.separateDialCode) parentClass += " iti--separate-dial-code";
                        if (this.options.customContainer) {
                            parentClass += " ";
                            parentClass += this.options.customContainer;
                        }
                        var wrapper = this._createEl("div", {
                            "class": parentClass
                        });
                        this.telInput.parentNode.insertBefore(wrapper, this.telInput);
                        this.flagsContainer = this._createEl("div", {
                            "class": "iti__flag-container"
                        }, wrapper);
                        wrapper.appendChild(this.telInput);
                        // selected flag (displayed to left of input)
                        this.selectedFlag = this._createEl("div", {
                            "class": "iti__selected-flag",
                            role: "combobox",
                            "aria-controls": "iti-".concat(this.id, "__country-listbox"),
                            "aria-owns": "iti-".concat(this.id, "__country-listbox"),
                            "aria-expanded": "false"
                        }, this.flagsContainer);
                        this.selectedFlagInner = this._createEl("div", {
                            "class": "iti__flag"
                        }, this.selectedFlag);
                        if (this.options.separateDialCode) {
                            this.selectedDialCode = this._createEl("div", {
                                "class": "iti__selected-dial-code"
                            }, this.selectedFlag);
                        }
                        if (this.options.allowDropdown) {
                            // make element focusable and tab navigable
                            this.selectedFlag.setAttribute("tabindex", "0");
                            this.dropdownArrow = this._createEl("div", {
                                "class": "iti__arrow"
                            }, this.selectedFlag);
                            // country dropdown: preferred countries, then divider, then all countries
                            this.countryList = this._createEl("ul", {
                                "class": "iti__country-list iti__hide",
                                id: "iti-".concat(this.id, "__country-listbox"),
                                role: "listbox",
                                "aria-label": "List of countries"
                            });
                            if (this.preferredCountries.length) {
                                this._appendListItems(this.preferredCountries, "iti__preferred", true);
                                this._createEl("li", {
                                    "class": "iti__divider",
                                    role: "separator",
                                    "aria-disabled": "true"
                                }, this.countryList);
                            }
                            this._appendListItems(this.countries, "iti__standard");
                            // create dropdownContainer markup
                            if (this.options.dropdownContainer) {
                                this.dropdown = this._createEl("div", {
                                    "class": "iti iti--container"
                                });
                                this.dropdown.appendChild(this.countryList);
                            } else {
                                this.flagsContainer.appendChild(this.countryList);
                            }
                        }
                        if (this.options.hiddenInput) {
                            var hiddenInputName = this.options.hiddenInput;
                            var name = this.telInput.getAttribute("name");
                            if (name) {
                                var i = name.lastIndexOf("[");
                                // if input name contains square brackets, then give the hidden input the same name,
                                // replacing the contents of the last set of brackets with the given hiddenInput name
                                if (i !== -1) hiddenInputName = "".concat(name.substr(0, i), "[").concat(hiddenInputName, "]");
                            }
                            this.hiddenInput = this._createEl("input", {
                                type: "hidden",
                                name: hiddenInputName
                            });
                            wrapper.appendChild(this.hiddenInput);
                        }
                    }
                }, {
                    key: "_appendListItems",
                    value: function _appendListItems(countries, className, preferred) {
                        // we create so many DOM elements, it is faster to build a temp string
                        // and then add everything to the DOM in one go at the end
                        var tmp = "";
                        // for each country
                        for (var i = 0; i < countries.length; i++) {
                            var c = countries[i];
                            var idSuffix = preferred ? "-preferred" : "";
                            // open the list item
                            tmp += "<li class='iti__country ".concat(className, "' tabIndex='-1' id='iti-").concat(this.id, "__item-").concat(c.iso2).concat(idSuffix, "' role='option' data-dial-code='").concat(c.dialCode, "' data-country-code='").concat(c.iso2, "' aria-selected='false'>");
                            // add the flag
                            tmp += "<div class='iti__flag-box'><div class='iti__flag iti__".concat(c.iso2, "'></div></div>");
                            // and the country name and dial code
                            tmp += "<span class='iti__country-name'>".concat(c.name, "</span>");
                            tmp += "<span class='iti__dial-code'>+".concat(c.dialCode, "</span>");
                            // close the list item
                            tmp += "</li>";
                        }
                        this.countryList.insertAdjacentHTML("beforeend", tmp);
                    }
                }, {
                    key: "_setInitialState",
                    value: function _setInitialState() {
                        // fix firefox bug: when first load page (with input with value set to number with intl dial
                        // code) and initialising plugin removes the dial code from the input, then refresh page,
                        // and we try to init plugin again but this time on number without dial code so get grey flag
                        var attributeValue = this.telInput.getAttribute("value");
                        var inputValue = this.telInput.value;
                        var useAttribute = attributeValue && attributeValue.charAt(0) === "+" && (!inputValue || inputValue.charAt(0) !== "+");
                        var val = useAttribute ? attributeValue : inputValue;
                        var dialCode = this._getDialCode(val);
                        var isRegionlessNanp = this._isRegionlessNanp(val);
                        var _this$options = this.options, initialCountry = _this$options.initialCountry, nationalMode = _this$options.nationalMode, autoHideDialCode = _this$options.autoHideDialCode, separateDialCode = _this$options.separateDialCode;
                        // if we already have a dial code, and it's not a regionlessNanp, we can go ahead and set the
                        // flag, else fall back to the default country
                        if (dialCode && !isRegionlessNanp) {
                            this._updateFlagFromNumber(val);
                        } else if (initialCountry !== "auto") {
                            // see if we should select a flag
                            if (initialCountry) {
                                this._setFlag(initialCountry.toLowerCase());
                            } else {
                                if (dialCode && isRegionlessNanp) {
                                    // has intl dial code, is regionless nanp, and no initialCountry, so default to US
                                    this._setFlag("us");
                                } else {
                                    // no dial code and no initialCountry, so default to first in list
                                    this.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0].iso2 : this.countries[0].iso2;
                                    if (!val) {
                                        this._setFlag(this.defaultCountry);
                                    }
                                }
                            }
                            // if empty and no nationalMode and no autoHideDialCode then insert the default dial code
                            if (!val && !nationalMode && !autoHideDialCode && !separateDialCode) {
                                this.telInput.value = "+".concat(this.selectedCountryData.dialCode);
                            }
                        }
                        // NOTE: if initialCountry is set to auto, that will be handled separately
                        // format - note this wont be run after _updateDialCode as that's only called if no val
                        if (val) this._updateValFromNumber(val);
                    }
                }, {
                    key: "_initListeners",
                    value: function _initListeners() {
                        this._initKeyListeners();
                        if (this.options.autoHideDialCode) this._initBlurListeners();
                        if (this.options.allowDropdown) this._initDropdownListeners();
                        if (this.hiddenInput) this._initHiddenInputListener();
                    }
                }, {
                    key: "_initHiddenInputListener",
                    value: function _initHiddenInputListener() {
                        var _this3 = this;
                        this._handleHiddenInputSubmit = function() {
                            _this3.hiddenInput.value = _this3.getNumber();
                        };
                        if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleHiddenInputSubmit);
                    }
                }, {
                    key: "_getClosestLabel",
                    value: function _getClosestLabel() {
                        var el = this.telInput;
                        while (el && el.tagName !== "LABEL") {
                            el = el.parentNode;
                        }
                        return el;
                    }
                }, {
                    key: "_initDropdownListeners",
                    value: function _initDropdownListeners() {
                        var _this4 = this;
                        // hack for input nested inside label (which is valid markup): clicking the selected-flag to
                        // open the dropdown would then automatically trigger a 2nd click on the input which would
                        // close it again
                        this._handleLabelClick = function(e) {
                            // if the dropdown is closed, then focus the input, else ignore the click
                            if (_this4.countryList.classList.contains("iti__hide")) _this4.telInput.focus(); else e.preventDefault();
                        };
                        var label = this._getClosestLabel();
                        if (label) label.addEventListener("click", this._handleLabelClick);
                        // toggle country dropdown on click
                        this._handleClickSelectedFlag = function() {
                            // only intercept this event if we're opening the dropdown
                            // else let it bubble up to the top ("click-off-to-close" listener)
                            // we cannot just stopPropagation as it may be needed to close another instance
                            if (_this4.countryList.classList.contains("iti__hide") && !_this4.telInput.disabled && !_this4.telInput.readOnly) {
                                _this4._showDropdown();
                            }
                        };
                        this.selectedFlag.addEventListener("click", this._handleClickSelectedFlag);
                        // open dropdown list if currently focused
                        this._handleFlagsContainerKeydown = function(e) {
                            var isDropdownHidden = _this4.countryList.classList.contains("iti__hide");
                            if (isDropdownHidden && [ "ArrowUp", "Up", "ArrowDown", "Down", " ", "Enter" ].indexOf(e.key) !== -1) {
                                // prevent form from being submitted if "ENTER" was pressed
                                e.preventDefault();
                                // prevent event from being handled again by document
                                e.stopPropagation();
                                _this4._showDropdown();
                            }
                            // allow navigation from dropdown to input on TAB
                            if (e.key === "Tab") _this4._closeDropdown();
                        };
                        this.flagsContainer.addEventListener("keydown", this._handleFlagsContainerKeydown);
                    }
                }, {
                    key: "_initRequests",
                    value: function _initRequests() {
                        var _this5 = this;
                        // if the user has specified the path to the utils script, fetch it on window.load, else resolve
                        if (this.options.utilsScript && !window.intlTelInputUtils) {
                            // if the plugin is being initialised after the window.load event has already been fired
                            if (window.intlTelInputGlobals.documentReady()) {
                                window.intlTelInputGlobals.loadUtils(this.options.utilsScript);
                            } else {
                                // wait until the load event so we don't block any other requests e.g. the flags image
                                window.addEventListener("load", function() {
                                    window.intlTelInputGlobals.loadUtils(_this5.options.utilsScript);
                                });
                            }
                        } else this.resolveUtilsScriptPromise();
                        if (this.options.initialCountry === "auto") this._loadAutoCountry(); else this.resolveAutoCountryPromise();
                    }
                }, {
                    key: "_loadAutoCountry",
                    value: function _loadAutoCountry() {
                        // 3 options:
                        // 1) already loaded (we're done)
                        // 2) not already started loading (start)
                        // 3) already started loading (do nothing - just wait for loading callback to fire)
                        if (window.intlTelInputGlobals.autoCountry) {
                            this.handleAutoCountry();
                        } else if (!window.intlTelInputGlobals.startedLoadingAutoCountry) {
                            // don't do this twice!
                            window.intlTelInputGlobals.startedLoadingAutoCountry = true;
                            if (typeof this.options.geoIpLookup === "function") {
                                this.options.geoIpLookup(function(countryCode) {
                                    window.intlTelInputGlobals.autoCountry = countryCode.toLowerCase();
                                    // tell all instances the auto country is ready
                                    // TODO: this should just be the current instances
                                    // UPDATE: use setTimeout in case their geoIpLookup function calls this callback straight
                                    // away (e.g. if they have already done the geo ip lookup somewhere else). Using
                                    // setTimeout means that the current thread of execution will finish before executing
                                    // this, which allows the plugin to finish initialising.
                                    setTimeout(function() {
                                        return forEachInstance("handleAutoCountry");
                                    });
                                }, function() {
                                    return forEachInstance("rejectAutoCountryPromise");
                                });
                            }
                        }
                    }
                }, {
                    key: "_initKeyListeners",
                    value: function _initKeyListeners() {
                        var _this6 = this;
                        // update flag on keyup
                        this._handleKeyupEvent = function() {
                            if (_this6._updateFlagFromNumber(_this6.telInput.value)) {
                                _this6._triggerCountryChange();
                            }
                        };
                        this.telInput.addEventListener("keyup", this._handleKeyupEvent);
                        // update flag on cut/paste events (now supported in all major browsers)
                        this._handleClipboardEvent = function() {
                            // hack because "paste" event is fired before input is updated
                            setTimeout(_this6._handleKeyupEvent);
                        };
                        this.telInput.addEventListener("cut", this._handleClipboardEvent);
                        this.telInput.addEventListener("paste", this._handleClipboardEvent);
                    }
                }, {
                    key: "_cap",
                    value: function _cap(number) {
                        var max = this.telInput.getAttribute("maxlength");
                        return max && number.length > max ? number.substr(0, max) : number;
                    }
                }, {
                    key: "_initBlurListeners",
                    value: function _initBlurListeners() {
                        var _this7 = this;
                        // on blur or form submit: if just a dial code then remove it
                        this._handleSubmitOrBlurEvent = function() {
                            _this7._removeEmptyDialCode();
                        };
                        if (this.telInput.form) this.telInput.form.addEventListener("submit", this._handleSubmitOrBlurEvent);
                        this.telInput.addEventListener("blur", this._handleSubmitOrBlurEvent);
                    }
                }, {
                    key: "_removeEmptyDialCode",
                    value: function _removeEmptyDialCode() {
                        if (this.telInput.value.charAt(0) === "+") {
                            var numeric = this._getNumeric(this.telInput.value);
                            // if just a plus, or if just a dial code
                            if (!numeric || this.selectedCountryData.dialCode === numeric) {
                                this.telInput.value = "";
                            }
                        }
                    }
                }, {
                    key: "_getNumeric",
                    value: function _getNumeric(s) {
                        return s.replace(/\D/g, "");
                    }
                }, {
                    key: "_trigger",
                    value: function _trigger(name) {
                        // have to use old school document.createEvent as IE11 doesn't support `new Event()` syntax
                        var e = document.createEvent("Event");
                        e.initEvent(name, true, true);
                        // can bubble, and is cancellable
                        this.telInput.dispatchEvent(e);
                    }
                }, {
                    key: "_showDropdown",
                    value: function _showDropdown() {
                        this.countryList.classList.remove("iti__hide");
                        this.selectedFlag.setAttribute("aria-expanded", "true");
                        this._setDropdownPosition();
                        // update highlighting and scroll to active list item
                        if (this.activeItem) {
                            this._highlightListItem(this.activeItem, false);
                            this._scrollTo(this.activeItem, true);
                        }
                        // bind all the dropdown-related listeners: mouseover, click, click-off, keydown
                        this._bindDropdownListeners();
                        // update the arrow
                        this.dropdownArrow.classList.add("iti__arrow--up");
                        this._trigger("open:countrydropdown");
                    }
                }, {
                    key: "_toggleClass",
                    value: function _toggleClass(el, className, shouldHaveClass) {
                        if (shouldHaveClass && !el.classList.contains(className)) el.classList.add(className); else if (!shouldHaveClass && el.classList.contains(className)) el.classList.remove(className);
                    }
                }, {
                    key: "_setDropdownPosition",
                    value: function _setDropdownPosition() {
                        var _this8 = this;
                        if (this.options.dropdownContainer) {
                            this.options.dropdownContainer.appendChild(this.dropdown);
                        }
                        if (!this.isMobile) {
                            var pos = this.telInput.getBoundingClientRect();
                            // windowTop from https://stackoverflow.com/a/14384091/217866
                            var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                            var inputTop = pos.top + windowTop;
                            var dropdownHeight = this.countryList.offsetHeight;
                            // dropdownFitsBelow = (dropdownBottom < windowBottom)
                            var dropdownFitsBelow = inputTop + this.telInput.offsetHeight + dropdownHeight < windowTop + window.innerHeight;
                            var dropdownFitsAbove = inputTop - dropdownHeight > windowTop;
                            // by default, the dropdown will be below the input. If we want to position it above the
                            // input, we add the dropup class.
                            this._toggleClass(this.countryList, "iti__country-list--dropup", !dropdownFitsBelow && dropdownFitsAbove);
                            // if dropdownContainer is enabled, calculate postion
                            if (this.options.dropdownContainer) {
                                // by default the dropdown will be directly over the input because it's not in the flow.
                                // If we want to position it below, we need to add some extra top value.
                                var extraTop = !dropdownFitsBelow && dropdownFitsAbove ? 0 : this.telInput.offsetHeight;
                                // calculate placement
                                this.dropdown.style.top = "".concat(inputTop + extraTop, "px");
                                this.dropdown.style.left = "".concat(pos.left + document.body.scrollLeft, "px");
                                // close menu on window scroll
                                this._handleWindowScroll = function() {
                                    return _this8._closeDropdown();
                                };
                                window.addEventListener("scroll", this._handleWindowScroll);
                            }
                        }
                    }
                }, {
                    key: "_getClosestListItem",
                    value: function _getClosestListItem(target) {
                        var el = target;
                        while (el && el !== this.countryList && !el.classList.contains("iti__country")) {
                            el = el.parentNode;
                        }
                        // if we reached the countryList element, then return null
                        return el === this.countryList ? null : el;
                    }
                }, {
                    key: "_bindDropdownListeners",
                    value: function _bindDropdownListeners() {
                        var _this9 = this;
                        // when mouse over a list item, just highlight that one
                        // we add the class "highlight", so if they hit "enter" we know which one to select
                        this._handleMouseoverCountryList = function(e) {
                            // handle event delegation, as we're listening for this event on the countryList
                            var listItem = _this9._getClosestListItem(e.target);
                            if (listItem) _this9._highlightListItem(listItem, false);
                        };
                        this.countryList.addEventListener("mouseover", this._handleMouseoverCountryList);
                        // listen for country selection
                        this._handleClickCountryList = function(e) {
                            var listItem = _this9._getClosestListItem(e.target);
                            if (listItem) _this9._selectListItem(listItem);
                        };
                        this.countryList.addEventListener("click", this._handleClickCountryList);
                        // click off to close
                        // (except when this initial opening click is bubbling up)
                        // we cannot just stopPropagation as it may be needed to close another instance
                        var isOpening = true;
                        this._handleClickOffToClose = function() {
                            if (!isOpening) _this9._closeDropdown();
                            isOpening = false;
                        };
                        document.documentElement.addEventListener("click", this._handleClickOffToClose);
                        // listen for up/down scrolling, enter to select, or letters to jump to country name.
                        // use keydown as keypress doesn't fire for non-char keys and we want to catch if they
                        // just hit down and hold it to scroll down (no keyup event).
                        // listen on the document because that's where key events are triggered if no input has focus
                        var query = "";
                        var queryTimer = null;
                        this._handleKeydownOnDropdown = function(e) {
                            // prevent down key from scrolling the whole page,
                            // and enter key from submitting a form etc
                            e.preventDefault();
                            // up and down to navigate
                            if (e.key === "ArrowUp" || e.key === "Up" || e.key === "ArrowDown" || e.key === "Down") _this9._handleUpDownKey(e.key); else if (e.key === "Enter") _this9._handleEnterKey(); else if (e.key === "Escape") _this9._closeDropdown(); else if (/^[a-zA-ZÀ-ÿа-яА-Я ]$/.test(e.key)) {
                                // jump to countries that start with the query string
                                if (queryTimer) clearTimeout(queryTimer);
                                query += e.key.toLowerCase();
                                _this9._searchForCountry(query);
                                // if the timer hits 1 second, reset the query
                                queryTimer = setTimeout(function() {
                                    query = "";
                                }, 1e3);
                            }
                        };
                        document.addEventListener("keydown", this._handleKeydownOnDropdown);
                    }
                }, {
                    key: "_handleUpDownKey",
                    value: function _handleUpDownKey(key) {
                        var next = key === "ArrowUp" || key === "Up" ? this.highlightedItem.previousElementSibling : this.highlightedItem.nextElementSibling;
                        if (next) {
                            // skip the divider
                            if (next.classList.contains("iti__divider")) {
                                next = key === "ArrowUp" || key === "Up" ? next.previousElementSibling : next.nextElementSibling;
                            }
                            this._highlightListItem(next, true);
                        }
                    }
                }, {
                    key: "_handleEnterKey",
                    value: function _handleEnterKey() {
                        if (this.highlightedItem) this._selectListItem(this.highlightedItem);
                    }
                }, {
                    key: "_searchForCountry",
                    value: function _searchForCountry(query) {
                        for (var i = 0; i < this.countries.length; i++) {
                            if (this._startsWith(this.countries[i].name, query)) {
                                var listItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(this.countries[i].iso2));
                                // update highlighting and scroll
                                this._highlightListItem(listItem, false);
                                this._scrollTo(listItem, true);
                                break;
                            }
                        }
                    }
                }, {
                    key: "_startsWith",
                    value: function _startsWith(a, b) {
                        return a.substr(0, b.length).toLowerCase() === b;
                    }
                }, {
                    key: "_updateValFromNumber",
                    value: function _updateValFromNumber(originalNumber) {
                        var number = originalNumber;
                        if (this.options.formatOnDisplay && window.intlTelInputUtils && this.selectedCountryData) {
                            var useNational = !this.options.separateDialCode && (this.options.nationalMode || number.charAt(0) !== "+");
                            var _intlTelInputUtils$nu = intlTelInputUtils.numberFormat, NATIONAL = _intlTelInputUtils$nu.NATIONAL, INTERNATIONAL = _intlTelInputUtils$nu.INTERNATIONAL;
                            var format = useNational ? NATIONAL : INTERNATIONAL;
                            number = intlTelInputUtils.formatNumber(number, this.selectedCountryData.iso2, format);
                        }
                        number = this._beforeSetNumber(number);
                        this.telInput.value = number;
                    }
                }, {
                    key: "_updateFlagFromNumber",
                    value: function _updateFlagFromNumber(originalNumber) {
                        // if we're in nationalMode and we already have US/Canada selected, make sure the number starts
                        // with a +1 so _getDialCode will be able to extract the area code
                        // update: if we dont yet have selectedCountryData, but we're here (trying to update the flag
                        // from the number), that means we're initialising the plugin with a number that already has a
                        // dial code, so fine to ignore this bit
                        var number = originalNumber;
                        var selectedDialCode = this.selectedCountryData.dialCode;
                        var isNanp = selectedDialCode === "1";
                        if (number && this.options.nationalMode && isNanp && number.charAt(0) !== "+") {
                            if (number.charAt(0) !== "1") number = "1".concat(number);
                            number = "+".concat(number);
                        }
                        // update flag if user types area code for another country
                        if (this.options.separateDialCode && selectedDialCode && number.charAt(0) !== "+") {
                            number = "+".concat(selectedDialCode).concat(number);
                        }
                        // try and extract valid dial code from input
                        var dialCode = this._getDialCode(number, true);
                        var numeric = this._getNumeric(number);
                        var countryCode = null;
                        if (dialCode) {
                            var countryCodes = this.countryCodes[this._getNumeric(dialCode)];
                            // check if the right country is already selected. this should be false if the number is
                            // longer than the matched dial code because in this case we need to make sure that if
                            // there are multiple country matches, that the first one is selected (note: we could
                            // just check that here, but it requires the same loop that we already have later)
                            var alreadySelected = countryCodes.indexOf(this.selectedCountryData.iso2) !== -1 && numeric.length <= dialCode.length - 1;
                            var isRegionlessNanpNumber = selectedDialCode === "1" && this._isRegionlessNanp(numeric);
                            // only update the flag if:
                            // A) NOT (we currently have a NANP flag selected, and the number is a regionlessNanp)
                            // AND
                            // B) the right country is not already selected
                            if (!isRegionlessNanpNumber && !alreadySelected) {
                                // if using onlyCountries option, countryCodes[0] may be empty, so we must find the first
                                // non-empty index
                                for (var j = 0; j < countryCodes.length; j++) {
                                    if (countryCodes[j]) {
                                        countryCode = countryCodes[j];
                                        break;
                                    }
                                }
                            }
                        } else if (number.charAt(0) === "+" && numeric.length) {
                            // invalid dial code, so empty
                            // Note: use getNumeric here because the number has not been formatted yet, so could contain
                            // bad chars
                            countryCode = "";
                        } else if (!number || number === "+") {
                            // empty, or just a plus, so default
                            countryCode = this.defaultCountry;
                        }
                        if (countryCode !== null) {
                            return this._setFlag(countryCode);
                        }
                        return false;
                    }
                }, {
                    key: "_isRegionlessNanp",
                    value: function _isRegionlessNanp(number) {
                        var numeric = this._getNumeric(number);
                        if (numeric.charAt(0) === "1") {
                            var areaCode = numeric.substr(1, 3);
                            return regionlessNanpNumbers.indexOf(areaCode) !== -1;
                        }
                        return false;
                    }
                }, {
                    key: "_highlightListItem",
                    value: function _highlightListItem(listItem, shouldFocus) {
                        var prevItem = this.highlightedItem;
                        if (prevItem) prevItem.classList.remove("iti__highlight");
                        this.highlightedItem = listItem;
                        this.highlightedItem.classList.add("iti__highlight");
                        if (shouldFocus) this.highlightedItem.focus();
                    }
                }, {
                    key: "_getCountryData",
                    value: function _getCountryData(countryCode, ignoreOnlyCountriesOption, allowFail) {
                        var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
                        for (var i = 0; i < countryList.length; i++) {
                            if (countryList[i].iso2 === countryCode) {
                                return countryList[i];
                            }
                        }
                        if (allowFail) {
                            return null;
                        }
                        throw new Error("No country data for '".concat(countryCode, "'"));
                    }
                }, {
                    key: "_setFlag",
                    value: function _setFlag(countryCode) {
                        var prevCountry = this.selectedCountryData.iso2 ? this.selectedCountryData : {};
                        // do this first as it will throw an error and stop if countryCode is invalid
                        this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
                        // update the defaultCountry - we only need the iso2 from now on, so just store that
                        if (this.selectedCountryData.iso2) {
                            this.defaultCountry = this.selectedCountryData.iso2;
                        }
                        this.selectedFlagInner.setAttribute("class", "iti__flag iti__".concat(countryCode));
                        // update the selected country's title attribute
                        var title = countryCode ? "".concat(this.selectedCountryData.name, ": +").concat(this.selectedCountryData.dialCode) : "Unknown";
                        this.selectedFlag.setAttribute("title", title);
                        if (this.options.separateDialCode) {
                            var dialCode = this.selectedCountryData.dialCode ? "+".concat(this.selectedCountryData.dialCode) : "";
                            this.selectedDialCode.innerHTML = dialCode;
                            // offsetWidth is zero if input is in a hidden container during initialisation
                            var selectedFlagWidth = this.selectedFlag.offsetWidth || this._getHiddenSelectedFlagWidth();
                            // add 6px of padding after the grey selected-dial-code box, as this is what we use in the css
                            this.telInput.style.paddingLeft = "".concat(selectedFlagWidth + 6, "px");
                        }
                        // and the input's placeholder
                        this._updatePlaceholder();
                        // update the active list item
                        if (this.options.allowDropdown) {
                            var prevItem = this.activeItem;
                            if (prevItem) {
                                prevItem.classList.remove("iti__active");
                                prevItem.setAttribute("aria-selected", "false");
                            }
                            if (countryCode) {
                                // check if there is a preferred item first, else fall back to standard
                                var nextItem = this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode, "-preferred")) || this.countryList.querySelector("#iti-".concat(this.id, "__item-").concat(countryCode));
                                nextItem.setAttribute("aria-selected", "true");
                                nextItem.classList.add("iti__active");
                                this.activeItem = nextItem;
                                this.selectedFlag.setAttribute("aria-activedescendant", nextItem.getAttribute("id"));
                            }
                        }
                        // return if the flag has changed or not
                        return prevCountry.iso2 !== countryCode;
                    }
                }, {
                    key: "_getHiddenSelectedFlagWidth",
                    value: function _getHiddenSelectedFlagWidth() {
                        // to get the right styling to apply, all we need is a shallow clone of the container,
                        // and then to inject a deep clone of the selectedFlag element
                        var containerClone = this.telInput.parentNode.cloneNode();
                        containerClone.style.visibility = "hidden";
                        document.body.appendChild(containerClone);
                        var flagsContainerClone = this.flagsContainer.cloneNode();
                        containerClone.appendChild(flagsContainerClone);
                        var selectedFlagClone = this.selectedFlag.cloneNode(true);
                        flagsContainerClone.appendChild(selectedFlagClone);
                        var width = selectedFlagClone.offsetWidth;
                        containerClone.parentNode.removeChild(containerClone);
                        return width;
                    }
                }, {
                    key: "_updatePlaceholder",
                    value: function _updatePlaceholder() {
                        var shouldSetPlaceholder = this.options.autoPlaceholder === "aggressive" || !this.hadInitialPlaceholder && this.options.autoPlaceholder === "polite";
                        if (window.intlTelInputUtils && shouldSetPlaceholder) {
                            var numberType = intlTelInputUtils.numberType[this.options.placeholderNumberType];
                            var placeholder = this.selectedCountryData.iso2 ? intlTelInputUtils.getExampleNumber(this.selectedCountryData.iso2, this.options.nationalMode, numberType) : "";
                            placeholder = this._beforeSetNumber(placeholder);
                            if (typeof this.options.customPlaceholder === "function") {
                                placeholder = this.options.customPlaceholder(placeholder, this.selectedCountryData);
                            }
                            this.telInput.setAttribute("placeholder", placeholder);
                        }
                    }
                }, {
                    key: "_selectListItem",
                    value: function _selectListItem(listItem) {
                        // update selected flag and active list item
                        var flagChanged = this._setFlag(listItem.getAttribute("data-country-code"));
                        this._closeDropdown();
                        this._updateDialCode(listItem.getAttribute("data-dial-code"), true);
                        // focus the input
                        this.telInput.focus();
                        // put cursor at end - this fix is required for FF and IE11 (with nationalMode=false i.e. auto
                        // inserting dial code), who try to put the cursor at the beginning the first time
                        var len = this.telInput.value.length;
                        this.telInput.setSelectionRange(len, len);
                        if (flagChanged) {
                            this._triggerCountryChange();
                        }
                    }
                }, {
                    key: "_closeDropdown",
                    value: function _closeDropdown() {
                        this.countryList.classList.add("iti__hide");
                        this.selectedFlag.setAttribute("aria-expanded", "false");
                        // update the arrow
                        this.dropdownArrow.classList.remove("iti__arrow--up");
                        // unbind key events
                        document.removeEventListener("keydown", this._handleKeydownOnDropdown);
                        document.documentElement.removeEventListener("click", this._handleClickOffToClose);
                        this.countryList.removeEventListener("mouseover", this._handleMouseoverCountryList);
                        this.countryList.removeEventListener("click", this._handleClickCountryList);
                        // remove menu from container
                        if (this.options.dropdownContainer) {
                            if (!this.isMobile) window.removeEventListener("scroll", this._handleWindowScroll);
                            if (this.dropdown.parentNode) this.dropdown.parentNode.removeChild(this.dropdown);
                        }
                        this._trigger("close:countrydropdown");
                    }
                }, {
                    key: "_scrollTo",
                    value: function _scrollTo(element, middle) {
                        var container = this.countryList;
                        // windowTop from https://stackoverflow.com/a/14384091/217866
                        var windowTop = window.pageYOffset || document.documentElement.scrollTop;
                        var containerHeight = container.offsetHeight;
                        var containerTop = container.getBoundingClientRect().top + windowTop;
                        var containerBottom = containerTop + containerHeight;
                        var elementHeight = element.offsetHeight;
                        var elementTop = element.getBoundingClientRect().top + windowTop;
                        var elementBottom = elementTop + elementHeight;
                        var newScrollTop = elementTop - containerTop + container.scrollTop;
                        var middleOffset = containerHeight / 2 - elementHeight / 2;
                        if (elementTop < containerTop) {
                            // scroll up
                            if (middle) newScrollTop -= middleOffset;
                            container.scrollTop = newScrollTop;
                        } else if (elementBottom > containerBottom) {
                            // scroll down
                            if (middle) newScrollTop += middleOffset;
                            var heightDifference = containerHeight - elementHeight;
                            container.scrollTop = newScrollTop - heightDifference;
                        }
                    }
                }, {
                    key: "_updateDialCode",
                    value: function _updateDialCode(newDialCodeBare, hasSelectedListItem) {
                        var inputVal = this.telInput.value;
                        // save having to pass this every time
                        var newDialCode = "+".concat(newDialCodeBare);
                        var newNumber;
                        if (inputVal.charAt(0) === "+") {
                            // there's a plus so we're dealing with a replacement (doesn't matter if nationalMode or not)
                            var prevDialCode = this._getDialCode(inputVal);
                            if (prevDialCode) {
                                // current number contains a valid dial code, so replace it
                                newNumber = inputVal.replace(prevDialCode, newDialCode);
                            } else {
                                // current number contains an invalid dial code, so ditch it
                                // (no way to determine where the invalid dial code ends and the rest of the number begins)
                                newNumber = newDialCode;
                            }
                        } else if (this.options.nationalMode || this.options.separateDialCode) {
                            // don't do anything
                            return;
                        } else {
                            // nationalMode is disabled
                            if (inputVal) {
                                // there is an existing value with no dial code: prefix the new dial code
                                newNumber = newDialCode + inputVal;
                            } else if (hasSelectedListItem || !this.options.autoHideDialCode) {
                                // no existing value and either they've just selected a list item, or autoHideDialCode is
                                // disabled: insert new dial code
                                newNumber = newDialCode;
                            } else {
                                return;
                            }
                        }
                        this.telInput.value = newNumber;
                    }
                }, {
                    key: "_getDialCode",
                    value: function _getDialCode(number, includeAreaCode) {
                        var dialCode = "";
                        // only interested in international numbers (starting with a plus)
                        if (number.charAt(0) === "+") {
                            var numericChars = "";
                            // iterate over chars
                            for (var i = 0; i < number.length; i++) {
                                var c = number.charAt(i);
                                // if char is number (https://stackoverflow.com/a/8935649/217866)
                                if (!isNaN(parseInt(c, 10))) {
                                    numericChars += c;
                                    // if current numericChars make a valid dial code
                                    if (includeAreaCode) {
                                        if (this.countryCodes[numericChars]) {
                                            // store the actual raw string (useful for matching later)
                                            dialCode = number.substr(0, i + 1);
                                        }
                                    } else {
                                        if (this.dialCodes[numericChars]) {
                                            dialCode = number.substr(0, i + 1);
                                            // if we're just looking for a dial code, we can break as soon as we find one
                                            break;
                                        }
                                    }
                                    // stop searching as soon as we can - in this case when we hit max len
                                    if (numericChars.length === this.countryCodeMaxLen) {
                                        break;
                                    }
                                }
                            }
                        }
                        return dialCode;
                    }
                }, {
                    key: "_getFullNumber",
                    value: function _getFullNumber() {
                        var val = this.telInput.value.trim();
                        var dialCode = this.selectedCountryData.dialCode;
                        var prefix;
                        var numericVal = this._getNumeric(val);
                        if (this.options.separateDialCode && val.charAt(0) !== "+" && dialCode && numericVal) {
                            // when using separateDialCode, it is visible so is effectively part of the typed number
                            prefix = "+".concat(dialCode);
                        } else {
                            prefix = "";
                        }
                        return prefix + val;
                    }
                }, {
                    key: "_beforeSetNumber",
                    value: function _beforeSetNumber(originalNumber) {
                        var number = originalNumber;
                        if (this.options.separateDialCode) {
                            var dialCode = this._getDialCode(number);
                            // if there is a valid dial code
                            if (dialCode) {
                                // in case _getDialCode returned an area code as well
                                dialCode = "+".concat(this.selectedCountryData.dialCode);
                                // a lot of numbers will have a space separating the dial code and the main number, and
                                // some NANP numbers will have a hyphen e.g. +1 684-733-1234 - in both cases we want to get
                                // rid of it
                                // NOTE: don't just trim all non-numerics as may want to preserve an open parenthesis etc
                                var start = number[dialCode.length] === " " || number[dialCode.length] === "-" ? dialCode.length + 1 : dialCode.length;
                                number = number.substr(start);
                            }
                        }
                        return this._cap(number);
                    }
                }, {
                    key: "_triggerCountryChange",
                    value: function _triggerCountryChange() {
                        this._trigger("countrychange");
                    }
                }, {
                    key: "handleAutoCountry",
                    value: function handleAutoCountry() {
                        if (this.options.initialCountry === "auto") {
                            // we must set this even if there is an initial val in the input: in case the initial val is
                            // invalid and they delete it - they should see their auto country
                            this.defaultCountry = window.intlTelInputGlobals.autoCountry;
                            // if there's no initial value in the input, then update the flag
                            if (!this.telInput.value) {
                                this.setCountry(this.defaultCountry);
                            }
                            this.resolveAutoCountryPromise();
                        }
                    }
                }, {
                    key: "handleUtils",
                    value: function handleUtils() {
                        // if the request was successful
                        if (window.intlTelInputUtils) {
                            // if there's an initial value in the input, then format it
                            if (this.telInput.value) {
                                this._updateValFromNumber(this.telInput.value);
                            }
                            this._updatePlaceholder();
                        }
                        this.resolveUtilsScriptPromise();
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        var form = this.telInput.form;
                        if (this.options.allowDropdown) {
                            // make sure the dropdown is closed (and unbind listeners)
                            this._closeDropdown();
                            this.selectedFlag.removeEventListener("click", this._handleClickSelectedFlag);
                            this.flagsContainer.removeEventListener("keydown", this._handleFlagsContainerKeydown);
                            // label click hack
                            var label = this._getClosestLabel();
                            if (label) label.removeEventListener("click", this._handleLabelClick);
                        }
                        // unbind hiddenInput listeners
                        if (this.hiddenInput && form) form.removeEventListener("submit", this._handleHiddenInputSubmit);
                        // unbind autoHideDialCode listeners
                        if (this.options.autoHideDialCode) {
                            if (form) form.removeEventListener("submit", this._handleSubmitOrBlurEvent);
                            this.telInput.removeEventListener("blur", this._handleSubmitOrBlurEvent);
                        }
                        // unbind key events, and cut/paste events
                        this.telInput.removeEventListener("keyup", this._handleKeyupEvent);
                        this.telInput.removeEventListener("cut", this._handleClipboardEvent);
                        this.telInput.removeEventListener("paste", this._handleClipboardEvent);
                        // remove attribute of id instance: data-intl-tel-input-id
                        this.telInput.removeAttribute("data-intl-tel-input-id");
                        // remove markup (but leave the original input)
                        var wrapper = this.telInput.parentNode;
                        wrapper.parentNode.insertBefore(this.telInput, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                        delete window.intlTelInputGlobals.instances[this.id];
                    }
                }, {
                    key: "getExtension",
                    value: function getExtension() {
                        if (window.intlTelInputUtils) {
                            return intlTelInputUtils.getExtension(this._getFullNumber(), this.selectedCountryData.iso2);
                        }
                        return "";
                    }
                }, {
                    key: "getNumber",
                    value: function getNumber(format) {
                        if (window.intlTelInputUtils) {
                            var iso2 = this.selectedCountryData.iso2;
                            return intlTelInputUtils.formatNumber(this._getFullNumber(), iso2, format);
                        }
                        return "";
                    }
                }, {
                    key: "getNumberType",
                    value: function getNumberType() {
                        if (window.intlTelInputUtils) {
                            return intlTelInputUtils.getNumberType(this._getFullNumber(), this.selectedCountryData.iso2);
                        }
                        return -99;
                    }
                }, {
                    key: "getSelectedCountryData",
                    value: function getSelectedCountryData() {
                        return this.selectedCountryData;
                    }
                }, {
                    key: "getValidationError",
                    value: function getValidationError() {
                        if (window.intlTelInputUtils) {
                            var iso2 = this.selectedCountryData.iso2;
                            return intlTelInputUtils.getValidationError(this._getFullNumber(), iso2);
                        }
                        return -99;
                    }
                }, {
                    key: "isValidNumber",
                    value: function isValidNumber() {
                        var val = this._getFullNumber().trim();
                        var countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
                        return window.intlTelInputUtils ? intlTelInputUtils.isValidNumber(val, countryCode) : null;
                    }
                }, {
                    key: "setCountry",
                    value: function setCountry(originalCountryCode) {
                        var countryCode = originalCountryCode.toLowerCase();
                        // check if already selected
                        if (!this.selectedFlagInner.classList.contains("iti__".concat(countryCode))) {
                            this._setFlag(countryCode);
                            this._updateDialCode(this.selectedCountryData.dialCode, false);
                            this._triggerCountryChange();
                        }
                    }
                }, {
                    key: "setNumber",
                    value: function setNumber(number) {
                        // we must update the flag first, which updates this.selectedCountryData, which is used for
                        // formatting the number before displaying it
                        var flagChanged = this._updateFlagFromNumber(number);
                        this._updateValFromNumber(number);
                        if (flagChanged) {
                            this._triggerCountryChange();
                        }
                    }
                }, {
                    key: "setPlaceholderNumberType",
                    value: function setPlaceholderNumberType(type) {
                        this.options.placeholderNumberType = type;
                        this._updatePlaceholder();
                    }
                } ]);
                return Iti;
            }();
            /********************
     *  STATIC METHODS
     ********************/
            // get the country data object
            intlTelInputGlobals.getCountryData = function() {
                return allCountries;
            };
            // inject a <script> element to load utils.js
            var injectScript = function injectScript(path, handleSuccess, handleFailure) {
                // inject a new script element into the page
                var script = document.createElement("script");
                script.onload = function() {
                    forEachInstance("handleUtils");
                    if (handleSuccess) handleSuccess();
                };
                script.onerror = function() {
                    forEachInstance("rejectUtilsScriptPromise");
                    if (handleFailure) handleFailure();
                };
                script.className = "iti-load-utils";
                script.async = true;
                script.src = path;
                document.body.appendChild(script);
            };
            // load the utils script
            intlTelInputGlobals.loadUtils = function(path) {
                // 2 options:
                // 1) not already started loading (start)
                // 2) already started loading (do nothing - just wait for the onload callback to fire, which will
                // trigger handleUtils on all instances, invoking their resolveUtilsScriptPromise functions)
                if (!window.intlTelInputUtils && !window.intlTelInputGlobals.startedLoadingUtilsScript) {
                    // only do this once
                    window.intlTelInputGlobals.startedLoadingUtilsScript = true;
                    // if we have promises, then return a promise
                    if (typeof Promise !== "undefined") {
                        return new Promise(function(resolve, reject) {
                            return injectScript(path, resolve, reject);
                        });
                    }
                    injectScript(path);
                }
                return null;
            };
            // default options
            intlTelInputGlobals.defaults = defaults;
            // version
            intlTelInputGlobals.version = "17.0.16";
            // convenience wrapper
            return function(input, options) {
                var iti = new Iti(input, options);
                iti._init();
                input.setAttribute("data-intl-tel-input-id", iti.id);
                window.intlTelInputGlobals.instances[iti.id] = iti;
                return iti;
            };
        }();
    });
    });

    /**
     * Exposing intl-tel-input as a component
     */

    var intlTelInput = intlTelInput$1;

    /* src\components\information\TabForms\ContactForm.svelte generated by Svelte v3.48.0 */

    const file$c = "src\\components\\information\\TabForms\\ContactForm.svelte";

    function create_fragment$c(ctx) {
    	let div3;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let input0;
    	let t4;
    	let input1;
    	let t5;
    	let input2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			div0.textContent = "Contact";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Please put your legal Phone and Email";
    			t3 = space();
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			input2 = element("input");
    			attr_dev(div0, "class", "tab__head");
    			add_location(div0, file$c, 43, 2, 1011);
    			attr_dev(div1, "class", "tab__subhead");
    			add_location(div1, file$c, 44, 2, 1051);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "input svelte-19hdgyb");
    			attr_dev(input0, "placeholder", "Username");
    			attr_dev(input0, "autocomplete", "");
    			toggle_class(input0, "error", /*$infoFormErrorStates*/ ctx[2].userName);
    			add_location(input0, file$c, 46, 4, 1161);
    			attr_dev(input1, "type", "email");
    			attr_dev(input1, "class", "input svelte-19hdgyb");
    			attr_dev(input1, "placeholder", "Email");
    			attr_dev(input1, "autocomplete", "");
    			toggle_class(input1, "error", /*$infoFormErrorStates*/ ctx[2].email);
    			add_location(input1, file$c, 47, 4, 1368);
    			attr_dev(input2, "type", "tel");
    			attr_dev(input2, "class", "input svelte-19hdgyb");
    			attr_dev(input2, "autocomplete", "");
    			toggle_class(input2, "error", /*$infoFormErrorStates*/ ctx[2].phone);
    			add_location(input2, file$c, 48, 4, 1563);
    			attr_dev(div2, "class", "tab__form__fields");
    			add_location(div2, file$c, 45, 2, 1124);
    			attr_dev(div3, "class", "tab__wrapper");
    			add_location(div3, file$c, 42, 0, 981);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, input0);
    			set_input_value(input0, /*$infoFormData*/ ctx[3].userName);
    			append_dev(div2, t4);
    			append_dev(div2, input1);
    			set_input_value(input1, /*$infoFormData*/ ctx[3].email);
    			append_dev(div2, t5);
    			append_dev(div2, input2);
    			/*input2_binding*/ ctx[9](input2);
    			set_input_value(input2, /*phoneData*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[5]),
    					listen_dev(input0, "focus", /*focus_handler*/ ctx[6], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[7]),
    					listen_dev(input1, "focus", /*focus_handler_1*/ ctx[8], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[10]),
    					listen_dev(input2, "focus", /*focus_handler_2*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$infoFormData*/ 8 && input0.value !== /*$infoFormData*/ ctx[3].userName) {
    				set_input_value(input0, /*$infoFormData*/ ctx[3].userName);
    			}

    			if (dirty & /*$infoFormErrorStates*/ 4) {
    				toggle_class(input0, "error", /*$infoFormErrorStates*/ ctx[2].userName);
    			}

    			if (dirty & /*$infoFormData*/ 8 && input1.value !== /*$infoFormData*/ ctx[3].email) {
    				set_input_value(input1, /*$infoFormData*/ ctx[3].email);
    			}

    			if (dirty & /*$infoFormErrorStates*/ 4) {
    				toggle_class(input1, "error", /*$infoFormErrorStates*/ ctx[2].email);
    			}

    			if (dirty & /*phoneData*/ 1) {
    				set_input_value(input2, /*phoneData*/ ctx[0]);
    			}

    			if (dirty & /*$infoFormErrorStates*/ 4) {
    				toggle_class(input2, "error", /*$infoFormErrorStates*/ ctx[2].phone);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			/*input2_binding*/ ctx[9](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let $infoFormErrorStates;
    	let $infoFormData;
    	validate_store(infoFormErrorStates, 'infoFormErrorStates');
    	component_subscribe($$self, infoFormErrorStates, $$value => $$invalidate(2, $infoFormErrorStates = $$value));
    	validate_store(infoFormData, 'infoFormData');
    	component_subscribe($$self, infoFormData, $$value => $$invalidate(3, $infoFormData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContactForm', slots, []);
    	let input;
    	let iti;
    	let initCounter = 0;
    	let number;
    	let phoneData = '';

    	afterUpdate(() => {
    		if (input) {
    			if (initCounter < 1) {
    				iti = intlTelInput(input, {
    					separateDialCode: true,
    					utilsScript: "https://intl-tel-input.com/node_modules/intl-tel-input/build/js/utils.js",
    					autoPlaceholder: ""
    				});

    				initCounter = 1;
    			}

    			if (phoneData.length != 0) {
    				set_store_value(infoFormData, $infoFormData.phone = phoneData, $infoFormData);
    			}

    			iti.setNumber($infoFormData.phone);
    		}
    	});

    	function disableErrorState(type) {
    		set_store_value(infoFormErrorStates, $infoFormErrorStates[type] = false, $infoFormErrorStates);
    		infoFormErrorMessage[type] = '';
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContactForm> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$infoFormData.userName = this.value;
    		infoFormData.set($infoFormData);
    	}

    	const focus_handler = () => {
    		disableErrorState('userName');
    	};

    	function input1_input_handler() {
    		$infoFormData.email = this.value;
    		infoFormData.set($infoFormData);
    	}

    	const focus_handler_1 = () => {
    		disableErrorState('email');
    	};

    	function input2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			input = $$value;
    			$$invalidate(1, input);
    		});
    	}

    	function input2_input_handler() {
    		phoneData = this.value;
    		$$invalidate(0, phoneData);
    	}

    	const focus_handler_2 = () => {
    		disableErrorState('phone');
    	};

    	$$self.$capture_state = () => ({
    		intlTelInput,
    		afterUpdate,
    		infoFormData,
    		infoFormErrorStates,
    		infoFormErrorMessage,
    		input,
    		iti,
    		initCounter,
    		number,
    		phoneData,
    		disableErrorState,
    		$infoFormErrorStates,
    		$infoFormData
    	});

    	$$self.$inject_state = $$props => {
    		if ('input' in $$props) $$invalidate(1, input = $$props.input);
    		if ('iti' in $$props) iti = $$props.iti;
    		if ('initCounter' in $$props) initCounter = $$props.initCounter;
    		if ('number' in $$props) $$invalidate(15, number = $$props.number);
    		if ('phoneData' in $$props) $$invalidate(0, phoneData = $$props.phoneData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*phoneData*/ 1) ;
    	};

    	return [
    		phoneData,
    		input,
    		$infoFormErrorStates,
    		$infoFormData,
    		disableErrorState,
    		input0_input_handler,
    		focus_handler,
    		input1_input_handler,
    		focus_handler_1,
    		input2_binding,
    		input2_input_handler,
    		focus_handler_2
    	];
    }

    class ContactForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContactForm",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src\components\information\Tabs\TabIcon.svelte generated by Svelte v3.48.0 */
    const file$b = "src\\components\\information\\Tabs\\TabIcon.svelte";

    // (114:39) 
    function create_if_block_4$2(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let t;
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M13.4615 6.46043H9.69231C8.51092 6.46043 7.53846 7.43289 7.53846 8.61428C7.53846 9.79566 8.51092 10.7681 9.69231 10.7681H11.8462V12.3835C11.8462 12.6791 11.6033 12.922 11.3077 12.922H2.69231C1.806 12.922 1.07692 12.1929 1.07692 11.3066V3.22966C1.07692 2.34335 1.806 1.61428 2.69231 1.61428H3.76923C4.06485 1.61428 4.30769 1.37143 4.30769 1.07582C4.30769 0.7802 4.06485 0.537354 3.76923 0.537354H2.69231C1.21531 0.537354 0 1.75266 0 3.22966V11.3066C0 12.7836 1.21531 13.9989 2.69231 13.9989H11.3077C12.194 13.9989 12.9231 13.2698 12.9231 12.3835V10.7681H13.4615C13.7572 10.7681 14 10.5253 14 10.2297V6.99889C14 6.70328 13.7572 6.46043 13.4615 6.46043ZM12.9231 9.6912H9.69231C9.10162 9.6912 8.61539 9.20497 8.61539 8.61428C8.61539 8.02358 9.10162 7.53735 9.69231 7.53735H12.9231V9.6912Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$b, 122, 6, 10890);
    			attr_dev(path1, "d", "M2.49857 2.72842C1.89765 2.99065 2.09634 3.76765 2.69242 3.76765H11.3078C11.6034 3.76765 11.8463 4.01049 11.8463 4.30611V4.84457C11.8463 5.14019 12.0891 5.38303 12.3847 5.38303C12.6803 5.38303 12.9232 5.14019 12.9232 4.84457V4.30611C12.9226 3.87803 12.7525 3.46719 12.4493 3.16457C12.1467 2.86142 11.7359 2.69126 11.3078 2.69072H11.1355L10.1932 0.337648C10.0839 0.0657245 9.77157 -0.0699679 9.49857 0.0361091L2.49857 2.72842ZM9.97242 2.69072H5.59473L9.39088 1.23149L9.97242 2.69072Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$b, 126, 6, 11735);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classNamePass*/ ctx[2]) + " svelte-n55xjo"));
    			add_location(svg, file$b, 114, 4, 10717);
    			attr_dev(div, "class", div_class_value = "icon__line " + /*classNamePass*/ ctx[2] + " svelte-n55xjo");
    			add_location(div, file$b, 132, 4, 12290);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*classNamePass*/ 4 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classNamePass*/ ctx[2]) + " svelte-n55xjo"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*classNamePass*/ 4 && div_class_value !== (div_class_value = "icon__line " + /*classNamePass*/ ctx[2] + " svelte-n55xjo")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(114:39) ",
    		ctx
    	});

    	return block;
    }

    // (88:40) 
    function create_if_block_3$2(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let defs;
    	let clipPath;
    	let rect;
    	let svg_class_value;
    	let t;
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			defs = svg_element("defs");
    			clipPath = svg_element("clipPath");
    			rect = svg_element("rect");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M11.0827 4.914V4.08333C11.0827 3.00037 10.6525 1.96175 9.8867 1.19598C9.12093 0.430207 8.08232 0 6.99935 0C5.91638 0 4.87777 0.430207 4.112 1.19598C3.34622 1.96175 2.91602 3.00037 2.91602 4.08333V4.914C2.39648 5.14074 1.95427 5.51397 1.64347 5.98804C1.33268 6.46211 1.16676 7.01647 1.16602 7.58333V11.0833C1.16694 11.8566 1.47453 12.5979 2.02131 13.1447C2.56809 13.6915 3.30942 13.9991 4.08268 14H9.91602C10.6893 13.9991 11.4306 13.6915 11.9774 13.1447C12.5242 12.5979 12.8318 11.8566 12.8327 11.0833V7.58333C12.8319 7.01647 12.666 6.46211 12.3552 5.98804C12.0444 5.51397 11.6022 5.14074 11.0827 4.914ZM4.08268 4.08333C4.08268 3.30979 4.38997 2.56792 4.93695 2.02094C5.48394 1.47396 6.2258 1.16667 6.99935 1.16667C7.7729 1.16667 8.51476 1.47396 9.06174 2.02094C9.60873 2.56792 9.91602 3.30979 9.91602 4.08333V4.66667H4.08268V4.08333ZM11.666 11.0833C11.666 11.5475 11.4816 11.9926 11.1535 12.3208C10.8253 12.649 10.3801 12.8333 9.91602 12.8333H4.08268C3.61855 12.8333 3.17343 12.649 2.84525 12.3208C2.51706 11.9926 2.33268 11.5475 2.33268 11.0833V7.58333C2.33268 7.1192 2.51706 6.67408 2.84525 6.3459C3.17343 6.01771 3.61855 5.83333 4.08268 5.83333H9.91602C10.3801 5.83333 10.8253 6.01771 11.1535 6.3459C11.4816 6.67408 11.666 7.1192 11.666 7.58333V11.0833Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$b, 97, 8, 8656);
    			attr_dev(path1, "d", "M6.99935 8.16675C6.84464 8.16675 6.69627 8.22821 6.58687 8.3376C6.47747 8.447 6.41602 8.59537 6.41602 8.75008V9.91675C6.41602 10.0715 6.47747 10.2198 6.58687 10.3292C6.69627 10.4386 6.84464 10.5001 6.99935 10.5001C7.15406 10.5001 7.30243 10.4386 7.41183 10.3292C7.52122 10.2198 7.58268 10.0715 7.58268 9.91675V8.75008C7.58268 8.59537 7.52122 8.447 7.41183 8.3376C7.30243 8.22821 7.15406 8.16675 6.99935 8.16675Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$b, 101, 8, 9981);
    			attr_dev(g, "clip-path", "url(#clip0_3547_4004)");
    			add_location(g, file$b, 96, 6, 8609);
    			attr_dev(rect, "width", "14");
    			attr_dev(rect, "height", "14");
    			attr_dev(rect, "fill", "white");
    			add_location(rect, file$b, 108, 10, 10530);
    			attr_dev(clipPath, "id", "clip0_3547_4004");
    			add_location(clipPath, file$b, 107, 8, 10487);
    			add_location(defs, file$b, 106, 6, 10471);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classNamePass*/ ctx[2]) + " svelte-n55xjo"));
    			add_location(svg, file$b, 88, 4, 8436);
    			attr_dev(div, "class", div_class_value = "icon__line " + /*classNamePass*/ ctx[2] + " svelte-n55xjo");
    			add_location(div, file$b, 112, 4, 10628);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(svg, defs);
    			append_dev(defs, clipPath);
    			append_dev(clipPath, rect);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*classNamePass*/ 4 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classNamePass*/ ctx[2]) + " svelte-n55xjo"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*classNamePass*/ 4 && div_class_value !== (div_class_value = "icon__line " + /*classNamePass*/ ctx[2] + " svelte-n55xjo")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(88:40) ",
    		ctx
    	});

    	return block;
    }

    // (62:39) 
    function create_if_block_2$2(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let defs;
    	let clipPath;
    	let rect;
    	let t;
    	let div;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			defs = svg_element("defs");
    			clipPath = svg_element("clipPath");
    			rect = svg_element("rect");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M6.99935 3.5C6.53786 3.5 6.08673 3.63685 5.70302 3.89324C5.31931 4.14963 5.02024 4.51404 4.84363 4.94041C4.66703 5.36677 4.62082 5.83592 4.71085 6.28854C4.80088 6.74117 5.02311 7.15693 5.34943 7.48325C5.67576 7.80957 6.09152 8.0318 6.54414 8.12183C6.99676 8.21186 7.46592 8.16566 7.89228 7.98905C8.31864 7.81245 8.68306 7.51338 8.93945 7.12966C9.19584 6.74595 9.33268 6.29482 9.33268 5.83333C9.33268 5.21449 9.08685 4.621 8.64927 4.18342C8.21168 3.74583 7.61819 3.5 6.99935 3.5ZM6.99935 7C6.76861 7 6.54304 6.93158 6.35119 6.80338C6.15933 6.67519 6.00979 6.49298 5.92149 6.2798C5.83319 6.06662 5.81008 5.83204 5.8551 5.60573C5.90012 5.37942 6.01123 5.17154 6.17439 5.00838C6.33755 4.84521 6.54543 4.7341 6.77174 4.68908C6.99806 4.64407 7.23263 4.66717 7.44581 4.75547C7.65899 4.84378 7.8412 4.99331 7.9694 5.18517C8.09759 5.37703 8.16602 5.60259 8.16602 5.83333C8.16602 6.14275 8.0431 6.4395 7.82431 6.65829C7.60552 6.87708 7.30877 7 6.99935 7Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$b, 71, 8, 6103);
    			attr_dev(path1, "d", "M7.00018 13.9999C6.50898 14.0025 6.02433 13.8873 5.5868 13.664C5.14928 13.4407 4.77161 13.1158 4.48543 12.7166C2.26235 9.65003 1.13477 7.3447 1.13477 5.8642C1.13477 4.30859 1.75273 2.8167 2.85271 1.71672C3.95269 0.616741 5.44458 -0.0012207 7.00018 -0.0012207C8.55579 -0.0012207 10.0477 0.616741 11.1477 1.71672C12.2476 2.8167 12.8656 4.30859 12.8656 5.8642C12.8656 7.3447 11.738 9.65003 9.51493 12.7166C9.22875 13.1158 8.85109 13.4407 8.41356 13.664C7.97604 13.8873 7.49138 14.0025 7.00018 13.9999ZM7.00018 1.2722C5.78243 1.27359 4.61494 1.75795 3.75386 2.61904C2.89277 3.48012 2.40841 4.64761 2.40702 5.86536C2.40702 7.03786 3.51127 9.20611 5.5156 11.9705C5.68575 12.2049 5.90898 12.3957 6.16702 12.5272C6.42505 12.6587 6.71056 12.7273 7.00018 12.7273C7.28981 12.7273 7.57532 12.6587 7.83335 12.5272C8.09138 12.3957 8.31461 12.2049 8.48477 11.9705C10.4891 9.20611 11.5934 7.03786 11.5934 5.86536C11.592 4.64761 11.1076 3.48012 10.2465 2.61904C9.38542 1.75795 8.21794 1.27359 7.00018 1.2722Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$b, 75, 8, 7116);
    			attr_dev(g, "clip-path", "url(#clip0_3547_4001)");
    			add_location(g, file$b, 70, 6, 6056);
    			attr_dev(rect, "width", "14");
    			attr_dev(rect, "height", "14");
    			attr_dev(rect, "fill", "white");
    			add_location(rect, file$b, 82, 10, 8245);
    			attr_dev(clipPath, "id", "clip0_3547_4001");
    			add_location(clipPath, file$b, 81, 8, 8202);
    			add_location(defs, file$b, 80, 6, 8186);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "" + (null_to_empty(/*classNameAddress*/ ctx[3]) + " svelte-n55xjo"));
    			add_location(svg, file$b, 62, 4, 5880);
    			attr_dev(div, "class", "icon__line " + /*classNameAddress*/ ctx[3] + " svelte-n55xjo");
    			add_location(div, file$b, 86, 4, 8343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(svg, defs);
    			append_dev(defs, clipPath);
    			append_dev(clipPath, rect);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(62:39) ",
    		ctx
    	});

    	return block;
    }

    // (47:40) 
    function create_if_block_1$3(ctx) {
    	let svg;
    	let path;
    	let svg_class_value;
    	let t;
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = space();
    			div = element("div");
    			attr_dev(path, "d", "M8.73877 4.09685V1.76352C8.73877 1.60881 8.80022 1.46043 8.90962 1.35104C9.01902 1.24164 9.16739 1.18018 9.3221 1.18018C9.47681 1.18018 9.62518 1.24164 9.73458 1.35104C9.84397 1.46043 9.90543 1.60881 9.90543 1.76352V3.2866C10.2729 2.91677 12.6477 0.529766 12.993 0.184432C13.0468 0.128718 13.1112 0.0842786 13.1824 0.0537066C13.2535 0.0231347 13.3301 0.00704274 13.4075 0.00636968C13.485 0.00569662 13.5618 0.020456 13.6335 0.0497865C13.7052 0.079117 13.7703 0.122431 13.8251 0.177202C13.8798 0.231973 13.9232 0.297103 13.9525 0.368793C13.9818 0.440482 13.9966 0.517295 13.9959 0.59475C13.9952 0.672204 13.9791 0.748749 13.9486 0.819918C13.918 0.891087 13.8736 0.955455 13.8178 1.00927C13.4725 1.3546 11.11 3.73052 10.7448 4.09685H12.2388C12.3935 4.09685 12.5418 4.15831 12.6512 4.2677C12.7606 4.3771 12.8221 4.52547 12.8221 4.68018C12.8221 4.83489 12.7606 4.98327 12.6512 5.09266C12.5418 5.20206 12.3935 5.26352 12.2388 5.26352H9.90543C9.59601 5.26352 9.29927 5.1406 9.08047 4.92181C8.86168 4.70302 8.73877 4.40627 8.73877 4.09685ZM13.4608 9.77793C13.7989 10.1169 13.9887 10.5761 13.9887 11.0548C13.9887 11.5336 13.7989 11.9928 13.4608 12.3318L12.9288 12.9443C8.15077 17.5164 -3.4739 5.89527 1.02885 1.1026L1.69968 0.519266C2.03897 0.190584 2.49402 0.00869678 2.96639 0.0129543C3.43876 0.0172118 3.89046 0.207272 4.22377 0.542016C4.24185 0.559516 5.32218 1.96418 5.32218 1.96418C5.6418 2.30167 5.81964 2.74899 5.81899 3.2138C5.81834 3.67861 5.63925 4.12543 5.31868 4.46202L4.64318 5.31135C5.01709 6.21961 5.56675 7.04507 6.26058 7.7403C6.95441 8.43554 7.77876 8.98686 8.68627 9.3626L9.54085 8.68302C9.87676 8.3616 10.3236 8.18192 10.7885 8.18126C11.2534 8.18061 11.7007 8.35905 12.0375 8.67952C12.0375 8.67952 13.4428 9.76043 13.4608 9.77793ZM12.6588 10.6261C12.6588 10.6261 11.2628 9.5516 11.2448 9.5341C11.1246 9.41494 10.9622 9.34809 10.793 9.34809C10.6237 9.34809 10.4614 9.41494 10.3412 9.5341C10.3254 9.54927 9.14885 10.4873 9.14885 10.4873C9.06956 10.5504 8.9752 10.5917 8.87506 10.6073C8.77492 10.6228 8.67246 10.612 8.57777 10.5759C7.40143 10.1383 6.33294 9.45281 5.44474 8.56602C4.55653 7.67922 3.86937 6.61182 3.42985 5.43618C3.39088 5.3402 3.37818 5.23557 3.39304 5.13305C3.40791 5.03053 3.44981 4.93381 3.51443 4.85285C3.51443 4.85285 4.45243 3.67802 4.46818 3.66285C4.58734 3.54267 4.65419 3.38029 4.65419 3.21106C4.65419 3.04182 4.58734 2.87944 4.46818 2.75927C4.45068 2.74177 3.37618 1.34468 3.37618 1.34468C3.25421 1.23531 3.09502 1.17674 2.93124 1.18097C2.76747 1.1852 2.61152 1.25191 2.49535 1.36743L1.82452 1.95077C-1.46665 5.90752 8.60868 15.424 12.0754 12.1492L12.6074 11.5361C12.7329 11.421 12.8084 11.2615 12.818 11.0915C12.8276 10.9216 12.7705 10.7546 12.6588 10.6261Z");
    			attr_dev(path, "fill", "#E4E4E4");
    			attr_dev(path, "class", "svelte-n55xjo");
    			add_location(path, file$b, 55, 6, 3023);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classNameContact*/ ctx[1]) + " svelte-n55xjo"));
    			add_location(svg, file$b, 47, 4, 2847);
    			attr_dev(div, "class", div_class_value = "icon__line " + /*classNameContact*/ ctx[1] + " svelte-n55xjo");
    			add_location(div, file$b, 60, 4, 5788);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*classNameContact*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classNameContact*/ ctx[1]) + " svelte-n55xjo"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*classNameContact*/ 2 && div_class_value !== (div_class_value = "icon__line " + /*classNameContact*/ ctx[1] + " svelte-n55xjo")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(47:40) ",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if categoryName === "Name"}
    function create_if_block$4(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let defs;
    	let clipPath;
    	let rect;
    	let t;
    	let div;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			defs = svg_element("defs");
    			clipPath = svg_element("clipPath");
    			rect = svg_element("rect");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M7 7C7.69223 7 8.36892 6.79473 8.9445 6.41015C9.52007 6.02556 9.96867 5.47894 10.2336 4.83939C10.4985 4.19985 10.5678 3.49612 10.4327 2.81719C10.2977 2.13825 9.96436 1.51461 9.47487 1.02513C8.98539 0.535644 8.36175 0.202301 7.68282 0.0672531C7.00388 -0.0677952 6.30015 0.0015165 5.66061 0.266423C5.02107 0.53133 4.47444 0.979934 4.08986 1.55551C3.70527 2.13108 3.5 2.80777 3.5 3.5C3.50093 4.42798 3.86997 5.31768 4.52615 5.97385C5.18233 6.63003 6.07203 6.99908 7 7ZM7 1.16667C7.46149 1.16667 7.91262 1.30352 8.29633 1.55991C8.68005 1.8163 8.97912 2.18071 9.15572 2.60707C9.33232 3.03343 9.37853 3.50259 9.2885 3.95521C9.19847 4.40784 8.97624 4.8236 8.64992 5.14992C8.32359 5.47624 7.90783 5.69847 7.45521 5.7885C7.00259 5.87853 6.53343 5.83233 6.10707 5.65572C5.68071 5.47912 5.31629 5.18005 5.0599 4.79633C4.80351 4.41262 4.66667 3.96149 4.66667 3.5C4.66667 2.88116 4.9125 2.28767 5.35008 1.85009C5.78767 1.4125 6.38116 1.16667 7 1.16667Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$b, 30, 8, 766);
    			attr_dev(path1, "d", "M7 8.16675C5.60809 8.16829 4.27363 8.72191 3.28939 9.70614C2.30516 10.6904 1.75154 12.0248 1.75 13.4167C1.75 13.5715 1.81146 13.7198 1.92085 13.8292C2.03025 13.9386 2.17862 14.0001 2.33333 14.0001C2.48804 14.0001 2.63642 13.9386 2.74581 13.8292C2.85521 13.7198 2.91667 13.5715 2.91667 13.4167C2.91667 12.3338 3.34687 11.2952 4.11265 10.5294C4.87842 9.76362 5.91703 9.33341 7 9.33341C8.08297 9.33341 9.12158 9.76362 9.88735 10.5294C10.6531 11.2952 11.0833 12.3338 11.0833 13.4167C11.0833 13.5715 11.1448 13.7198 11.2542 13.8292C11.3636 13.9386 11.512 14.0001 11.6667 14.0001C11.8214 14.0001 11.9697 13.9386 12.0791 13.8292C12.1885 13.7198 12.25 13.5715 12.25 13.4167C12.2485 12.0248 11.6948 10.6904 10.7106 9.70614C9.72637 8.72191 8.39191 8.16829 7 8.16675Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$b, 34, 8, 1774);
    			attr_dev(g, "clip-path", "url(#clip0_3547_3996)");
    			add_location(g, file$b, 29, 6, 719);
    			attr_dev(rect, "width", "14");
    			attr_dev(rect, "height", "14");
    			attr_dev(rect, "fill", "white");
    			add_location(rect, file$b, 41, 10, 2668);
    			attr_dev(clipPath, "id", "clip0_3547_3996");
    			add_location(clipPath, file$b, 40, 8, 2625);
    			add_location(defs, file$b, 39, 6, 2609);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "active svelte-n55xjo");
    			add_location(svg, file$b, 21, 4, 553);
    			attr_dev(div, "class", "icon__line active svelte-n55xjo");
    			add_location(div, file$b, 45, 4, 2766);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(svg, defs);
    			append_dev(defs, clipPath);
    			append_dev(clipPath, rect);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(21:2) {#if categoryName === \\\"Name\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*categoryName*/ ctx[0] === "Name") return create_if_block$4;
    		if (/*categoryName*/ ctx[0] === "Contacts") return create_if_block_1$3;
    		if (/*categoryName*/ ctx[0] === "Address") return create_if_block_2$2;
    		if (/*categoryName*/ ctx[0] === "Password") return create_if_block_3$2;
    		if (/*categoryName*/ ctx[0] === "Payment") return create_if_block_4$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "icon__wrapper  svelte-n55xjo");
    			add_location(div, file$b, 19, 0, 486);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $allowItemIndex;
    	validate_store(allowItemIndex, 'allowItemIndex');
    	component_subscribe($$self, allowItemIndex, $$value => $$invalidate(4, $allowItemIndex = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabIcon', slots, []);
    	let { categoryName } = $$props;
    	let classNameContact = "", classNameAddress = "", classNamePass = "";

    	beforeUpdate(() => {
    		if ($allowItemIndex === 2) {
    			$$invalidate(1, classNameContact = "active");
    			$$invalidate(2, classNamePass = "active");
    		} else if ($allowItemIndex === 1) {
    			$$invalidate(1, classNameContact = "active");
    			$$invalidate(2, classNamePass = "");
    		}
    	});

    	const writable_props = ['categoryName'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('categoryName' in $$props) $$invalidate(0, categoryName = $$props.categoryName);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		categoryName,
    		allowItemIndex,
    		classNameContact,
    		classNameAddress,
    		classNamePass,
    		$allowItemIndex
    	});

    	$$self.$inject_state = $$props => {
    		if ('categoryName' in $$props) $$invalidate(0, categoryName = $$props.categoryName);
    		if ('classNameContact' in $$props) $$invalidate(1, classNameContact = $$props.classNameContact);
    		if ('classNameAddress' in $$props) $$invalidate(3, classNameAddress = $$props.classNameAddress);
    		if ('classNamePass' in $$props) $$invalidate(2, classNamePass = $$props.classNamePass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [categoryName, classNameContact, classNamePass, classNameAddress];
    }

    class TabIcon$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { categoryName: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabIcon",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*categoryName*/ ctx[0] === undefined && !('categoryName' in props)) {
    			console.warn("<TabIcon> was created without expected prop 'categoryName'");
    		}
    	}

    	get categoryName() {
    		throw new Error("<TabIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set categoryName(value) {
    		throw new Error("<TabIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\information\Tabs\Tabs.svelte generated by Svelte v3.48.0 */
    const file$a = "src\\components\\information\\Tabs\\Tabs.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    // (12:8) {#each tabItems as item, i}
    function create_each_block$1(ctx) {
    	let li;
    	let div;
    	let tabicon;
    	let t;
    	let current;

    	tabicon = new TabIcon$1({
    			props: { categoryName: /*item*/ ctx[1].name },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			create_component(tabicon.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "icon");
    			add_location(div, file$a, 13, 16, 206);
    			attr_dev(li, "class", "svelte-1xshcb4");
    			add_location(li, file$a, 12, 12, 184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			mount_component(tabicon, div, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabicon_changes = {};
    			if (dirty & /*tabItems*/ 1) tabicon_changes.categoryName = /*item*/ ctx[1].name;
    			tabicon.$set(tabicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(tabicon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(12:8) {#each tabItems as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;
    	let ul;
    	let current;
    	let each_value = /*tabItems*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1xshcb4");
    			add_location(ul, file$a, 10, 4, 129);
    			attr_dev(div, "class", "tabs svelte-1xshcb4");
    			add_location(div, file$a, 9, 0, 105);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tabItems*/ 1) {
    				each_value = /*tabItems*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, []);
    	let { tabItems } = $$props;
    	const writable_props = ['tabItems'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('tabItems' in $$props) $$invalidate(0, tabItems = $$props.tabItems);
    	};

    	$$self.$capture_state = () => ({ TabIcon: TabIcon$1, tabItems });

    	$$self.$inject_state = $$props => {
    		if ('tabItems' in $$props) $$invalidate(0, tabItems = $$props.tabItems);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tabItems];
    }

    class Tabs$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { tabItems: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabItems*/ ctx[0] === undefined && !('tabItems' in props)) {
    			console.warn("<Tabs> was created without expected prop 'tabItems'");
    		}
    	}

    	get tabItems() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabItems(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\billing\TabForms\AddressForm.svelte generated by Svelte v3.48.0 */

    const file$9 = "src\\components\\billing\\TabForms\\AddressForm.svelte";

    function create_fragment$9(ctx) {
    	let div5;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div4;
    	let div2;
    	let input0;
    	let t4;
    	let input1;
    	let t5;
    	let input2;
    	let t6;
    	let input3;
    	let t7;
    	let div3;
    	let input4;
    	let t8;
    	let input5;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "Address";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "*Please make sure that all information matches your billling information";
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			input0 = element("input");
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			input2 = element("input");
    			t6 = space();
    			input3 = element("input");
    			t7 = space();
    			div3 = element("div");
    			input4 = element("input");
    			t8 = space();
    			input5 = element("input");
    			attr_dev(div0, "class", "tab__head");
    			add_location(div0, file$9, 1, 2, 30);
    			attr_dev(div1, "class", "tab__subhead");
    			add_location(div1, file$9, 2, 2, 70);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "input small svelte-9w58l0");
    			attr_dev(input0, "placeholder", "First Name*");
    			attr_dev(input0, "autocomplete", "");
    			add_location(input0, file$9, 7, 6, 264);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "input small svelte-9w58l0");
    			attr_dev(input1, "placeholder", "Last Name*");
    			attr_dev(input1, "autocomplete", "");
    			add_location(input1, file$9, 13, 6, 395);
    			attr_dev(div2, "class", "two__colums names svelte-9w58l0");
    			add_location(div2, file$9, 6, 4, 225);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "input");
    			attr_dev(input2, "placeholder", "Street Number & Street*");
    			attr_dev(input2, "autocomplete", "");
    			add_location(input2, file$9, 20, 4, 535);
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "class", "input");
    			attr_dev(input3, "placeholder", "City *");
    			attr_dev(input3, "autocomplete", "");
    			add_location(input3, file$9, 26, 4, 660);
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "class", "input small svelte-9w58l0");
    			attr_dev(input4, "placeholder", "Country");
    			attr_dev(input4, "autocomplete", "");
    			add_location(input4, file$9, 28, 6, 768);
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "class", "input small svelte-9w58l0");
    			attr_dev(input5, "placeholder", "Postal / Zip Code");
    			attr_dev(input5, "autocomplete", "");
    			add_location(input5, file$9, 34, 6, 895);
    			attr_dev(div3, "class", "two__colums svelte-9w58l0");
    			add_location(div3, file$9, 27, 4, 735);
    			attr_dev(div4, "class", "tab__form__fields");
    			add_location(div4, file$9, 5, 2, 188);
    			attr_dev(div5, "class", "tab__wrapper");
    			add_location(div5, file$9, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, input0);
    			append_dev(div2, t4);
    			append_dev(div2, input1);
    			append_dev(div4, t5);
    			append_dev(div4, input2);
    			append_dev(div4, t6);
    			append_dev(div4, input3);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, input4);
    			append_dev(div3, t8);
    			append_dev(div3, input5);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AddressForm', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AddressForm> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class AddressForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddressForm",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src\components\information\TabForms\PasswordForm.svelte generated by Svelte v3.48.0 */

    const { console: console_1$1 } = globals;

    const file$8 = "src\\components\\information\\TabForms\\PasswordForm.svelte";

    function create_fragment$8(ctx) {
    	let div5;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div4;
    	let div2;
    	let svg0;
    	let path0;
    	let t4;
    	let input0;
    	let t5;
    	let div3;
    	let svg1;
    	let path1;
    	let t6;
    	let input1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");
    			div0.textContent = "Password";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Please put your Password";
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t4 = space();
    			input0 = element("input");
    			t5 = space();
    			div3 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t6 = space();
    			input1 = element("input");
    			attr_dev(div0, "class", "tab__head");
    			add_location(div0, file$8, 40, 2, 1101);
    			attr_dev(div1, "class", "tab__subhead");
    			add_location(div1, file$8, 41, 2, 1142);
    			attr_dev(path0, "d", "M12.0007 9.005C13.0615 9.005 14.079 9.42643 14.8291 10.1766C15.5792 10.9267 16.0007 11.9441 16.0007 13.005C16.0007 14.0659 15.5792 15.0833 14.8291 15.8334C14.079 16.5836 13.0615 17.005 12.0007 17.005C10.9398 17.005 9.92239 16.5836 9.17225 15.8334C8.4221 15.0833 8.00067 14.0659 8.00067 13.005C8.00067 11.9441 8.4221 10.9267 9.17225 10.1766C9.92239 9.42643 10.9398 9.005 12.0007 9.005ZM12.0007 10.505C11.3376 10.505 10.7017 10.7684 10.2329 11.2372C9.76407 11.7061 9.50067 12.342 9.50067 13.005C9.50067 13.668 9.76407 14.3039 10.2329 14.7728C10.7017 15.2416 11.3376 15.505 12.0007 15.505C12.6637 15.505 13.2996 15.2416 13.7684 14.7728C14.2373 14.3039 14.5007 13.668 14.5007 13.005C14.5007 12.342 14.2373 11.7061 13.7684 11.2372C13.2996 10.7684 12.6637 10.505 12.0007 10.505ZM12.0007 5.5C16.6137 5.5 20.5967 8.65 21.7017 13.064C21.7501 13.2569 21.7198 13.4612 21.6176 13.6319C21.5154 13.8025 21.3496 13.9256 21.1567 13.974C20.9637 14.0224 20.7595 13.9922 20.5888 13.89C20.4181 13.7878 20.2951 13.6219 20.2467 13.429C19.7837 11.5925 18.7208 9.96306 17.2267 8.79913C15.7326 7.6352 13.8926 7.00338 11.9986 7.00384C10.1046 7.0043 8.26499 7.63701 6.7714 8.80167C5.27782 9.96632 4.21578 11.5962 3.75367 13.433C3.72984 13.5286 3.68741 13.6186 3.6288 13.6978C3.5702 13.777 3.49656 13.8439 3.41211 13.8946C3.32765 13.9454 3.23403 13.979 3.13658 13.9935C3.03914 14.0081 2.93978 14.0033 2.84417 13.9795C2.74857 13.9557 2.6586 13.9132 2.5794 13.8546C2.50019 13.796 2.43331 13.7224 2.38256 13.6379C2.33181 13.5535 2.2982 13.4599 2.28363 13.3624C2.26907 13.265 2.27384 13.1656 2.29767 13.07C2.83999 10.9073 4.08933 8.98777 5.84728 7.61627C7.60523 6.24476 9.77101 5.49991 12.0007 5.5Z");
    			attr_dev(path0, "fill", "#053900");
    			add_location(path0, file$8, 55, 8, 1534);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "eye__icon svelte-133ug4u");
    			add_location(svg0, file$8, 44, 6, 1275);
    			attr_dev(input0, "type", /*passwordType*/ ctx[0]);
    			attr_dev(input0, "class", "input svelte-133ug4u");
    			attr_dev(input0, "placeholder", "Password");
    			attr_dev(input0, "autocomplete", "");
    			toggle_class(input0, "error", /*$infoFormErrorStates*/ ctx[2].password);
    			add_location(input0, file$8, 60, 6, 3281);
    			attr_dev(div2, "class", "input__wrapper svelte-133ug4u");
    			add_location(div2, file$8, 43, 4, 1239);
    			attr_dev(path1, "d", "M12.0007 9.005C13.0615 9.005 14.079 9.42643 14.8291 10.1766C15.5792 10.9267 16.0007 11.9441 16.0007 13.005C16.0007 14.0659 15.5792 15.0833 14.8291 15.8334C14.079 16.5836 13.0615 17.005 12.0007 17.005C10.9398 17.005 9.92239 16.5836 9.17225 15.8334C8.4221 15.0833 8.00067 14.0659 8.00067 13.005C8.00067 11.9441 8.4221 10.9267 9.17225 10.1766C9.92239 9.42643 10.9398 9.005 12.0007 9.005ZM12.0007 10.505C11.3376 10.505 10.7017 10.7684 10.2329 11.2372C9.76407 11.7061 9.50067 12.342 9.50067 13.005C9.50067 13.668 9.76407 14.3039 10.2329 14.7728C10.7017 15.2416 11.3376 15.505 12.0007 15.505C12.6637 15.505 13.2996 15.2416 13.7684 14.7728C14.2373 14.3039 14.5007 13.668 14.5007 13.005C14.5007 12.342 14.2373 11.7061 13.7684 11.2372C13.2996 10.7684 12.6637 10.505 12.0007 10.505ZM12.0007 5.5C16.6137 5.5 20.5967 8.65 21.7017 13.064C21.7501 13.2569 21.7198 13.4612 21.6176 13.6319C21.5154 13.8025 21.3496 13.9256 21.1567 13.974C20.9637 14.0224 20.7595 13.9922 20.5888 13.89C20.4181 13.7878 20.2951 13.6219 20.2467 13.429C19.7837 11.5925 18.7208 9.96306 17.2267 8.79913C15.7326 7.6352 13.8926 7.00338 11.9986 7.00384C10.1046 7.0043 8.26499 7.63701 6.7714 8.80167C5.27782 9.96632 4.21578 11.5962 3.75367 13.433C3.72984 13.5286 3.68741 13.6186 3.6288 13.6978C3.5702 13.777 3.49656 13.8439 3.41211 13.8946C3.32765 13.9454 3.23403 13.979 3.13658 13.9935C3.03914 14.0081 2.93978 14.0033 2.84417 13.9795C2.74857 13.9557 2.6586 13.9132 2.5794 13.8546C2.50019 13.796 2.43331 13.7224 2.38256 13.6379C2.33181 13.5535 2.2982 13.4599 2.28363 13.3624C2.26907 13.265 2.27384 13.1656 2.29767 13.07C2.83999 10.9073 4.08933 8.98777 5.84728 7.61627C7.60523 6.24476 9.77101 5.49991 12.0007 5.5Z");
    			attr_dev(path1, "fill", "#053900");
    			add_location(path1, file$8, 82, 8, 3869);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "eye__icon svelte-133ug4u");
    			add_location(svg1, file$8, 71, 6, 3603);
    			attr_dev(input1, "type", /*confirnPasswordType*/ ctx[1]);
    			attr_dev(input1, "class", "input svelte-133ug4u");
    			attr_dev(input1, "placeholder", "Confirm Password");
    			attr_dev(input1, "autocomplete", "");
    			toggle_class(input1, "error", /*$infoFormErrorStates*/ ctx[2].confirmPassword);
    			add_location(input1, file$8, 87, 6, 5616);
    			attr_dev(div3, "class", "input__wrapper svelte-133ug4u");
    			add_location(div3, file$8, 70, 4, 3567);
    			attr_dev(div4, "class", "tab__form__fields");
    			add_location(div4, file$8, 42, 2, 1202);
    			attr_dev(div5, "class", "tab__wrapper");
    			add_location(div5, file$8, 39, 0, 1071);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);
    			append_dev(div5, t1);
    			append_dev(div5, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, svg0);
    			append_dev(svg0, path0);
    			append_dev(div2, t4);
    			append_dev(div2, input0);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, svg1);
    			append_dev(svg1, path1);
    			append_dev(div3, t6);
    			append_dev(div3, input1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg0, "click", /*click_handler*/ ctx[8], false, false, false),
    					listen_dev(input0, "focus", /*focus_handler*/ ctx[9], false, false, false),
    					listen_dev(input0, "input", /*onInputPass*/ ctx[4], false, false, false),
    					listen_dev(svg1, "click", /*click_handler_1*/ ctx[10], false, false, false),
    					listen_dev(input1, "focus", /*focus_handler_1*/ ctx[11], false, false, false),
    					listen_dev(input1, "input", /*onInputConfirmPass*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*passwordType*/ 1) {
    				attr_dev(input0, "type", /*passwordType*/ ctx[0]);
    			}

    			if (dirty & /*$infoFormErrorStates*/ 4) {
    				toggle_class(input0, "error", /*$infoFormErrorStates*/ ctx[2].password);
    			}

    			if (dirty & /*confirnPasswordType*/ 2) {
    				attr_dev(input1, "type", /*confirnPasswordType*/ ctx[1]);
    			}

    			if (dirty & /*$infoFormErrorStates*/ 4) {
    				toggle_class(input1, "error", /*$infoFormErrorStates*/ ctx[2].confirmPassword);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $infoFormErrorMessage;
    	let $infoFormErrorStates;
    	let $infoFormData;
    	validate_store(infoFormErrorMessage, 'infoFormErrorMessage');
    	component_subscribe($$self, infoFormErrorMessage, $$value => $$invalidate(12, $infoFormErrorMessage = $$value));
    	validate_store(infoFormErrorStates, 'infoFormErrorStates');
    	component_subscribe($$self, infoFormErrorStates, $$value => $$invalidate(2, $infoFormErrorStates = $$value));
    	validate_store(infoFormData, 'infoFormData');
    	component_subscribe($$self, infoFormData, $$value => $$invalidate(13, $infoFormData = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PasswordForm', slots, []);
    	let passwordType = "password";
    	let confirnPasswordType = "password";
    	let valuePass = "";
    	let valueConfirmPass = "";

    	let onInputConfirmPass = event => {
    		set_store_value(infoFormData, $infoFormData.password = event.target.value, $infoFormData);
    		console.log($infoFormData.password);
    	};

    	let onInputPass = event => {
    		set_store_value(infoFormData, $infoFormData.confirmPassword = event.target.value, $infoFormData);
    		console.log($infoFormData.confirmPassword);
    	};

    	function validatePasswordType() {
    		if (passwordType === "password") {
    			$$invalidate(0, passwordType = "text");
    		} else {
    			$$invalidate(0, passwordType = "password");
    		}
    	}

    	function validateConfirmPasswordType() {
    		if (confirnPasswordType === "password") {
    			$$invalidate(1, confirnPasswordType = "text");
    		} else {
    			$$invalidate(1, confirnPasswordType = "password");
    		}
    	}

    	function disableErrorState(type) {
    		set_store_value(infoFormErrorStates, $infoFormErrorStates[type] = false, $infoFormErrorStates);
    		set_store_value(infoFormErrorMessage, $infoFormErrorMessage[type] = '', $infoFormErrorMessage);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<PasswordForm> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		validatePasswordType();
    	};

    	const focus_handler = () => {
    		disableErrorState('password');
    	};

    	const click_handler_1 = () => {
    		validateConfirmPasswordType();
    	};

    	const focus_handler_1 = () => {
    		disableErrorState('confirmPassword');
    	};

    	$$self.$capture_state = () => ({
    		infoFormData,
    		infoFormErrorStates,
    		infoFormErrorMessage,
    		passwordType,
    		confirnPasswordType,
    		valuePass,
    		valueConfirmPass,
    		onInputConfirmPass,
    		onInputPass,
    		validatePasswordType,
    		validateConfirmPasswordType,
    		disableErrorState,
    		$infoFormErrorMessage,
    		$infoFormErrorStates,
    		$infoFormData
    	});

    	$$self.$inject_state = $$props => {
    		if ('passwordType' in $$props) $$invalidate(0, passwordType = $$props.passwordType);
    		if ('confirnPasswordType' in $$props) $$invalidate(1, confirnPasswordType = $$props.confirnPasswordType);
    		if ('valuePass' in $$props) valuePass = $$props.valuePass;
    		if ('valueConfirmPass' in $$props) valueConfirmPass = $$props.valueConfirmPass;
    		if ('onInputConfirmPass' in $$props) $$invalidate(3, onInputConfirmPass = $$props.onInputConfirmPass);
    		if ('onInputPass' in $$props) $$invalidate(4, onInputPass = $$props.onInputPass);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*passwordType, confirnPasswordType*/ 3) ;
    	};

    	return [
    		passwordType,
    		confirnPasswordType,
    		$infoFormErrorStates,
    		onInputConfirmPass,
    		onInputPass,
    		validatePasswordType,
    		validateConfirmPasswordType,
    		disableErrorState,
    		click_handler,
    		focus_handler,
    		click_handler_1,
    		focus_handler_1
    	];
    }

    class PasswordForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PasswordForm",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* src\components\information\Information.svelte generated by Svelte v3.48.0 */

    const { console: console_1 } = globals;
    const file$7 = "src\\components\\information\\Information.svelte";

    // (166:8) {#if $infoFormErrorState}
    function create_if_block_1$2(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let if_block4_anchor;
    	let if_block0 = /*$infoFormErrorStates*/ ctx[3].userName === true && create_if_block_6$1(ctx);
    	let if_block1 = /*$infoFormErrorStates*/ ctx[3].email === true && create_if_block_5$1(ctx);
    	let if_block2 = /*$infoFormErrorStates*/ ctx[3].phone === true && create_if_block_4$1(ctx);
    	let if_block3 = /*$infoFormErrorStates*/ ctx[3].password === true && create_if_block_3$1(ctx);
    	let if_block4 = /*$infoFormErrorStates*/ ctx[3].password === true && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			if_block4_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, if_block4_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$infoFormErrorStates*/ ctx[3].userName === true) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$infoFormErrorStates*/ ctx[3].email === true) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_5$1(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*$infoFormErrorStates*/ ctx[3].phone === true) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_4$1(ctx);
    					if_block2.c();
    					if_block2.m(t2.parentNode, t2);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*$infoFormErrorStates*/ ctx[3].password === true) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_3$1(ctx);
    					if_block3.c();
    					if_block3.m(t3.parentNode, t3);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*$infoFormErrorStates*/ ctx[3].password === true) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_2$1(ctx);
    					if_block4.c();
    					if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(if_block4_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(166:8) {#if $infoFormErrorState}",
    		ctx
    	});

    	return block;
    }

    // (167:10) {#if $infoFormErrorStates.userName === true}
    function create_if_block_6$1(ctx) {
    	let div;
    	let t_value = /*$infoFormErrorMessage*/ ctx[4].userName + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "error__message svelte-1xn3q8o");
    			add_location(div, file$7, 167, 12, 5148);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$infoFormErrorMessage*/ 16 && t_value !== (t_value = /*$infoFormErrorMessage*/ ctx[4].userName + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(167:10) {#if $infoFormErrorStates.userName === true}",
    		ctx
    	});

    	return block;
    }

    // (170:10) {#if $infoFormErrorStates.email === true}
    function create_if_block_5$1(ctx) {
    	let div;
    	let t_value = /*$infoFormErrorMessage*/ ctx[4].email + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "error__message svelte-1xn3q8o");
    			add_location(div, file$7, 170, 12, 5298);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$infoFormErrorMessage*/ 16 && t_value !== (t_value = /*$infoFormErrorMessage*/ ctx[4].email + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(170:10) {#if $infoFormErrorStates.email === true}",
    		ctx
    	});

    	return block;
    }

    // (173:10) {#if $infoFormErrorStates.phone === true}
    function create_if_block_4$1(ctx) {
    	let div;
    	let t_value = /*$infoFormErrorMessage*/ ctx[4].phone + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "error__message svelte-1xn3q8o");
    			add_location(div, file$7, 173, 12, 5445);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$infoFormErrorMessage*/ 16 && t_value !== (t_value = /*$infoFormErrorMessage*/ ctx[4].phone + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(173:10) {#if $infoFormErrorStates.phone === true}",
    		ctx
    	});

    	return block;
    }

    // (176:10) {#if $infoFormErrorStates.password === true}
    function create_if_block_3$1(ctx) {
    	let div;
    	let t_value = /*$infoFormErrorMessage*/ ctx[4].password + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "error__message svelte-1xn3q8o");
    			add_location(div, file$7, 176, 12, 5595);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$infoFormErrorMessage*/ 16 && t_value !== (t_value = /*$infoFormErrorMessage*/ ctx[4].password + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(176:10) {#if $infoFormErrorStates.password === true}",
    		ctx
    	});

    	return block;
    }

    // (179:10) {#if $infoFormErrorStates.password === true}
    function create_if_block_2$1(ctx) {
    	let div;
    	let t_value = /*$infoFormErrorMessage*/ ctx[4].confirmPassword + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "error__message svelte-1xn3q8o");
    			add_location(div, file$7, 179, 12, 5748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$infoFormErrorMessage*/ 16 && t_value !== (t_value = /*$infoFormErrorMessage*/ ctx[4].confirmPassword + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(179:10) {#if $infoFormErrorStates.password === true}",
    		ctx
    	});

    	return block;
    }

    // (186:6) {#if $allowItemIndex > 1}
    function create_if_block$3(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = text("Back");
    			attr_dev(path, "d", "M9.36881 12.568C9.53285 12.4039 9.625 12.1814 9.625 11.9494C9.625 11.7174 9.53285 11.4949 9.36881 11.3308L5.03756 6.99953L9.36881 2.66828C9.5282 2.50325 9.61639 2.28223 9.6144 2.0528C9.61241 1.82338 9.52038 1.60392 9.35815 1.44169C9.19592 1.27946 8.97646 1.18743 8.74704 1.18544C8.51761 1.18345 8.29659 1.27164 8.13156 1.43103L3.18169 6.38091C3.01765 6.54499 2.9255 6.76751 2.9255 6.99953C2.9255 7.23155 3.01765 7.45407 3.18169 7.61816L8.13156 12.568C8.29565 12.7321 8.51817 12.8242 8.75019 12.8242C8.98221 12.8242 9.20473 12.7321 9.36881 12.568Z");
    			attr_dev(path, "fill", "#CFCFCF");
    			add_location(path, file$7, 194, 12, 6201);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-1xn3q8o");
    			add_location(svg, file$7, 187, 11, 6015);
    			attr_dev(button, "class", "btn prev svelte-1xn3q8o");
    			add_location(button, file$7, 186, 8, 5959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*prevTab*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(186:6) {#if $allowItemIndex > 1}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div4;
    	let div2;
    	let h2;
    	let t0;
    	let span;
    	let t2;
    	let div0;
    	let form;
    	let tabs;
    	let t3;
    	let switch_instance;
    	let t4;
    	let t5;
    	let div1;
    	let t6;
    	let button;
    	let t7;
    	let t8;
    	let div3;
    	let buttonleft;
    	let t9;
    	let buttonright;
    	let current;
    	let mounted;
    	let dispose;

    	tabs = new Tabs$1({
    			props: { tabItems: /*tabItems*/ ctx[7] },
    			$$inline: true
    		});

    	var switch_value = /*activeItem*/ ctx[2].component;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	let if_block0 = /*$infoFormErrorState*/ ctx[5] && create_if_block_1$2(ctx);
    	let if_block1 = /*$allowItemIndex*/ ctx[6] > 1 && create_if_block$3(ctx);
    	buttonleft = new ButtonLeft({ $$inline: true });
    	buttonleft.$on("click", /*prevStep*/ ctx[10]);

    	buttonright = new ButtonRight({
    			props: { buttonState: /*nextButtonState*/ ctx[1] },
    			$$inline: true
    		});

    	buttonright.$on("click", /*nextStep*/ ctx[11]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			h2 = element("h2");
    			t0 = text("Personal ");
    			span = element("span");
    			span.textContent = "Information";
    			t2 = space();
    			div0 = element("div");
    			form = element("form");
    			create_component(tabs.$$.fragment);
    			t3 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t6 = space();
    			button = element("button");
    			t7 = text(/*formButtonText*/ ctx[0]);
    			t8 = space();
    			div3 = element("div");
    			create_component(buttonleft.$$.fragment);
    			t9 = space();
    			create_component(buttonright.$$.fragment);
    			attr_dev(span, "class", "green svelte-1xn3q8o");
    			add_location(span, file$7, 159, 15, 4863);
    			attr_dev(h2, "class", "main__head svelte-1xn3q8o");
    			add_location(h2, file$7, 158, 4, 4823);
    			attr_dev(form, "class", "svelte-1xn3q8o");
    			add_location(form, file$7, 162, 6, 4950);
    			attr_dev(div0, "class", "main__tabs svelte-1xn3q8o");
    			add_location(div0, file$7, 161, 4, 4918);
    			attr_dev(button, "class", "btn next svelte-1xn3q8o");
    			add_location(button, file$7, 201, 6, 6880);
    			attr_dev(div1, "class", "buttons__wrapper svelte-1xn3q8o");
    			add_location(div1, file$7, 184, 4, 5886);
    			attr_dev(div2, "class", "info__main svelte-1xn3q8o");
    			add_location(div2, file$7, 157, 2, 4793);
    			attr_dev(div3, "class", "bottom__btns");
    			add_location(div3, file$7, 205, 2, 6977);
    			attr_dev(div4, "class", "main__wrapper svelte-1xn3q8o");
    			add_location(div4, file$7, 156, 0, 4762);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, h2);
    			append_dev(h2, t0);
    			append_dev(h2, span);
    			append_dev(div2, t2);
    			append_dev(div2, div0);
    			append_dev(div0, form);
    			mount_component(tabs, form, null);
    			append_dev(form, t3);

    			if (switch_instance) {
    				mount_component(switch_instance, form, null);
    			}

    			append_dev(form, t4);
    			if (if_block0) if_block0.m(form, null);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t6);
    			append_dev(div1, button);
    			append_dev(button, t7);
    			append_dev(div4, t8);
    			append_dev(div4, div3);
    			mount_component(buttonleft, div3, null);
    			append_dev(div3, t9);
    			mount_component(buttonright, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*nextTab*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (switch_value !== (switch_value = /*activeItem*/ ctx[2].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, form, t4);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (/*$infoFormErrorState*/ ctx[5]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					if_block0.m(form, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$allowItemIndex*/ ctx[6] > 1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$3(ctx);
    					if_block1.c();
    					if_block1.m(div1, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*formButtonText*/ 1) set_data_dev(t7, /*formButtonText*/ ctx[0]);
    			const buttonright_changes = {};
    			if (dirty & /*nextButtonState*/ 2) buttonright_changes.buttonState = /*nextButtonState*/ ctx[1];
    			buttonright.$set(buttonright_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(buttonleft.$$.fragment, local);
    			transition_in(buttonright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(buttonleft.$$.fragment, local);
    			transition_out(buttonright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(tabs);
    			if (switch_instance) destroy_component(switch_instance);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(buttonleft);
    			destroy_component(buttonright);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $confirmPopUpState;
    	let $infoFormErrorStates;
    	let $infoFormErrorMessage;
    	let $infoFormErrorState;
    	let $infoFormData;
    	let $allowItemIndex;
    	validate_store(confirmPopUpState, 'confirmPopUpState');
    	component_subscribe($$self, confirmPopUpState, $$value => $$invalidate(12, $confirmPopUpState = $$value));
    	validate_store(infoFormErrorStates, 'infoFormErrorStates');
    	component_subscribe($$self, infoFormErrorStates, $$value => $$invalidate(3, $infoFormErrorStates = $$value));
    	validate_store(infoFormErrorMessage, 'infoFormErrorMessage');
    	component_subscribe($$self, infoFormErrorMessage, $$value => $$invalidate(4, $infoFormErrorMessage = $$value));
    	validate_store(infoFormErrorState, 'infoFormErrorState');
    	component_subscribe($$self, infoFormErrorState, $$value => $$invalidate(5, $infoFormErrorState = $$value));
    	validate_store(infoFormData, 'infoFormData');
    	component_subscribe($$self, infoFormData, $$value => $$invalidate(13, $infoFormData = $$value));
    	validate_store(allowItemIndex, 'allowItemIndex');
    	component_subscribe($$self, allowItemIndex, $$value => $$invalidate(6, $allowItemIndex = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Information', slots, []);

    	let tabItems = [
    		// { name: "Name", component: NameForm },
    		{ name: "Contacts", component: ContactForm },
    		// { name: "Address", component: AddressForm },
    		{
    			name: "Password",
    			component: PasswordForm
    		}
    	];

    	let formButtonText = "Next";
    	let activeItem = tabItems[0];
    	let changeCounter = 0;
    	let nextButtonState = false;

    	function nextTab() {
    		if ($allowItemIndex < 3) {
    			let index = tabItems.findIndex(object => {
    				return object.name === activeItem.name;
    			});

    			if (index === 0) {
    				validateContact();

    				if ($infoFormErrorState === false) {
    					$$invalidate(2, activeItem = tabItems[index + 1]);
    					set_store_value(allowItemIndex, $allowItemIndex = $allowItemIndex + 1, $allowItemIndex);
    					$$invalidate(0, formButtonText = "Save");
    				}
    			} else if (index === 1) {
    				validatePassword();

    				if ($infoFormErrorState === false) {
    					console.log("here");
    					$$invalidate(1, nextButtonState = true);
    				}
    			}
    		}
    	}

    	function prevTab() {
    		if ($allowItemIndex > 1) {
    			let index = tabItems.findIndex(object => {
    				return object.name === activeItem.name;
    			});

    			if (index != 0) {
    				$$invalidate(2, activeItem = tabItems[index - 1]);
    				set_store_value(allowItemIndex, $allowItemIndex = $allowItemIndex - 1, $allowItemIndex);
    				$$invalidate(0, formButtonText = "Next");
    				$$invalidate(1, nextButtonState = false);
    			}
    		}
    	}

    	let validateContact = () => {
    		let email = $infoFormData.email;
    		let userName = $infoFormData.userName;
    		let phone = $infoFormData.phone;

    		// email validation
    		validateEmail(email);

    		validateUserName(userName);
    		checkFieldLenght(phone, "Phone", "phone", 8, 12);
    		checkValidFieldStatus();
    	};

    	function checkValidFieldStatus() {
    		if ($infoFormErrorStates.email === false && $infoFormErrorStates.phone === false && $infoFormErrorStates.userName === false) {
    			set_store_value(infoFormErrorState, $infoFormErrorState = false, $infoFormErrorState);
    		} else {
    			set_store_value(infoFormErrorState, $infoFormErrorState = true, $infoFormErrorState);
    		}
    	}

    	let validatePassword = () => {
    		let pass = $infoFormData.password;
    		let confirmPass = $infoFormData.confirmPassword;
    		console.log(pass);

    		if (pass !== confirmPass) {
    			showError("password", "Passwords do not match");
    			console.log("Passwords do not match");
    			checkPassValidFieldStatus();
    			return false;
    		}

    		checkFieldLenght(pass, "Password", "password", 6, 32);
    		checkFieldLenght(confirmPass, "Confirm Password", "confirmPassword", 6, 32);
    		checkPassValidFieldStatus();
    	};

    	function checkPassValidFieldStatus() {
    		if ($infoFormErrorStates.password === false && $infoFormErrorStates.confirmPassword === false) {
    			set_store_value(infoFormErrorState, $infoFormErrorState = false, $infoFormErrorState);
    		} else {
    			set_store_value(infoFormErrorState, $infoFormErrorState = true, $infoFormErrorState);
    		}
    	}

    	let validateEmail = email => {
    		const re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

    		if (!re.test(email.trim())) {
    			showError("email", "Email is not invalid");
    			return false;
    		} else {
    			showSucces("email");
    		}
    	};

    	let validateUserName = userName => {
    		checkFieldLenght(userName, "User Name", "userName", 3, 32);
    	};

    	let checkFieldLenght = (field, fieldName, fieldType, min, max) => {
    		if (field.length < min) {
    			showError(fieldType, `${fieldName} must be at least ${min} characters`);
    		} else if (field.length > max) {
    			showError(fieldType, `${fieldName} must be les than ${max} characters`);
    		} else {
    			showSucces(fieldType);
    		}
    	};

    	//Show input error messages
    	function showError(type, message) {
    		set_store_value(infoFormErrorMessage, $infoFormErrorMessage[type] = message, $infoFormErrorMessage);
    		set_store_value(infoFormErrorStates, $infoFormErrorStates[type] = true, $infoFormErrorStates);
    	}

    	function showSucces(type) {
    		set_store_value(infoFormErrorStates, $infoFormErrorStates[type] = false, $infoFormErrorStates);
    	}

    	let prevStep = () => {
    		decrementStep();
    	};

    	let nextStep = () => {
    		set_store_value(confirmPopUpState, $confirmPopUpState = true, $confirmPopUpState);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Information> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		writable,
    		NameForm,
    		ContactForm,
    		Tabs: Tabs$1,
    		AddressForm,
    		PasswordForm,
    		allowItemIndex,
    		infoFormErrorMessage,
    		infoFormErrorState,
    		infoFormData,
    		infoFormErrorStates,
    		confirmPopUpState,
    		headSteps,
    		decrementStep,
    		incrementStep,
    		ButtonLeft,
    		ButtonRight,
    		tabItems,
    		formButtonText,
    		activeItem,
    		changeCounter,
    		nextButtonState,
    		nextTab,
    		prevTab,
    		validateContact,
    		checkValidFieldStatus,
    		validatePassword,
    		checkPassValidFieldStatus,
    		validateEmail,
    		validateUserName,
    		checkFieldLenght,
    		showError,
    		showSucces,
    		prevStep,
    		nextStep,
    		$confirmPopUpState,
    		$infoFormErrorStates,
    		$infoFormErrorMessage,
    		$infoFormErrorState,
    		$infoFormData,
    		$allowItemIndex
    	});

    	$$self.$inject_state = $$props => {
    		if ('tabItems' in $$props) $$invalidate(7, tabItems = $$props.tabItems);
    		if ('formButtonText' in $$props) $$invalidate(0, formButtonText = $$props.formButtonText);
    		if ('activeItem' in $$props) $$invalidate(2, activeItem = $$props.activeItem);
    		if ('changeCounter' in $$props) changeCounter = $$props.changeCounter;
    		if ('nextButtonState' in $$props) $$invalidate(1, nextButtonState = $$props.nextButtonState);
    		if ('validateContact' in $$props) validateContact = $$props.validateContact;
    		if ('validatePassword' in $$props) validatePassword = $$props.validatePassword;
    		if ('validateEmail' in $$props) validateEmail = $$props.validateEmail;
    		if ('validateUserName' in $$props) validateUserName = $$props.validateUserName;
    		if ('checkFieldLenght' in $$props) checkFieldLenght = $$props.checkFieldLenght;
    		if ('prevStep' in $$props) $$invalidate(10, prevStep = $$props.prevStep);
    		if ('nextStep' in $$props) $$invalidate(11, nextStep = $$props.nextStep);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*formButtonText, nextButtonState*/ 3) ;
    	};

    	return [
    		formButtonText,
    		nextButtonState,
    		activeItem,
    		$infoFormErrorStates,
    		$infoFormErrorMessage,
    		$infoFormErrorState,
    		$allowItemIndex,
    		tabItems,
    		nextTab,
    		prevTab,
    		prevStep,
    		nextStep
    	];
    }

    class Information extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Information",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    const allowItemIndexBilling = writable (1);

    /* src\components\billing\Tabs\TabIcon.svelte generated by Svelte v3.48.0 */
    const file$6 = "src\\components\\billing\\Tabs\\TabIcon.svelte";

    // (48:39) 
    function create_if_block_1$1(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let svg_class_value;
    	let t;
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M13.4615 6.46043H9.69231C8.51092 6.46043 7.53846 7.43289 7.53846 8.61428C7.53846 9.79566 8.51092 10.7681 9.69231 10.7681H11.8462V12.3835C11.8462 12.6791 11.6033 12.922 11.3077 12.922H2.69231C1.806 12.922 1.07692 12.1929 1.07692 11.3066V3.22966C1.07692 2.34335 1.806 1.61428 2.69231 1.61428H3.76923C4.06485 1.61428 4.30769 1.37143 4.30769 1.07582C4.30769 0.7802 4.06485 0.537354 3.76923 0.537354H2.69231C1.21531 0.537354 0 1.75266 0 3.22966V11.3066C0 12.7836 1.21531 13.9989 2.69231 13.9989H11.3077C12.194 13.9989 12.9231 13.2698 12.9231 12.3835V10.7681H13.4615C13.7572 10.7681 14 10.5253 14 10.2297V6.99889C14 6.70328 13.7572 6.46043 13.4615 6.46043ZM12.9231 9.6912H9.69231C9.10162 9.6912 8.61539 9.20497 8.61539 8.61428C8.61539 8.02358 9.10162 7.53735 9.69231 7.53735H12.9231V9.6912Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$6, 56, 6, 3299);
    			attr_dev(path1, "d", "M2.49857 2.72842C1.89765 2.99065 2.09634 3.76765 2.69242 3.76765H11.3078C11.6034 3.76765 11.8463 4.01049 11.8463 4.30611V4.84457C11.8463 5.14019 12.0891 5.38303 12.3847 5.38303C12.6803 5.38303 12.9232 5.14019 12.9232 4.84457V4.30611C12.9226 3.87803 12.7525 3.46719 12.4493 3.16457C12.1467 2.86142 11.7359 2.69126 11.3078 2.69072H11.1355L10.1932 0.337648C10.0839 0.0657245 9.77157 -0.0699679 9.49857 0.0361091L2.49857 2.72842ZM9.97242 2.69072H5.59473L9.39088 1.23149L9.97242 2.69072Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$6, 60, 6, 4144);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classNamePayment*/ ctx[1]) + " svelte-n55xjo"));
    			add_location(svg, file$6, 48, 4, 3123);
    			attr_dev(div, "class", div_class_value = "icon__line " + /*classNamePayment*/ ctx[1] + " svelte-n55xjo");
    			add_location(div, file$6, 66, 4, 4699);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*classNamePayment*/ 2 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classNamePayment*/ ctx[1]) + " svelte-n55xjo"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*classNamePayment*/ 2 && div_class_value !== (div_class_value = "icon__line " + /*classNamePayment*/ ctx[1] + " svelte-n55xjo")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(48:39) ",
    		ctx
    	});

    	return block;
    }

    // (21:2) {#if categoryName === "Address"}
    function create_if_block$2(ctx) {
    	let svg;
    	let g;
    	let path0;
    	let path1;
    	let defs;
    	let clipPath;
    	let rect;
    	let svg_class_value;
    	let t;
    	let div;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g = svg_element("g");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			defs = svg_element("defs");
    			clipPath = svg_element("clipPath");
    			rect = svg_element("rect");
    			t = space();
    			div = element("div");
    			attr_dev(path0, "d", "M6.99935 3.5C6.53786 3.5 6.08673 3.63685 5.70302 3.89324C5.31931 4.14963 5.02024 4.51404 4.84363 4.94041C4.66703 5.36677 4.62082 5.83592 4.71085 6.28854C4.80088 6.74117 5.02311 7.15693 5.34943 7.48325C5.67576 7.80957 6.09152 8.0318 6.54414 8.12183C6.99676 8.21186 7.46592 8.16566 7.89228 7.98905C8.31864 7.81245 8.68306 7.51338 8.93945 7.12966C9.19584 6.74595 9.33268 6.29482 9.33268 5.83333C9.33268 5.21449 9.08685 4.621 8.64927 4.18342C8.21168 3.74583 7.61819 3.5 6.99935 3.5ZM6.99935 7C6.76861 7 6.54304 6.93158 6.35119 6.80338C6.15933 6.67519 6.00979 6.49298 5.92149 6.2798C5.83319 6.06662 5.81008 5.83204 5.8551 5.60573C5.90012 5.37942 6.01123 5.17154 6.17439 5.00838C6.33755 4.84521 6.54543 4.7341 6.77174 4.68908C6.99806 4.64407 7.23263 4.66717 7.44581 4.75547C7.65899 4.84378 7.8412 4.99331 7.9694 5.18517C8.09759 5.37703 8.16602 5.60259 8.16602 5.83333C8.16602 6.14275 8.0431 6.4395 7.82431 6.65829C7.60552 6.87708 7.30877 7 6.99935 7Z");
    			attr_dev(path0, "fill", "#E4E4E4");
    			attr_dev(path0, "class", "svelte-n55xjo");
    			add_location(path0, file$6, 30, 8, 789);
    			attr_dev(path1, "d", "M7.00018 13.9999C6.50898 14.0025 6.02433 13.8873 5.5868 13.664C5.14928 13.4407 4.77161 13.1158 4.48543 12.7166C2.26235 9.65003 1.13477 7.3447 1.13477 5.8642C1.13477 4.30859 1.75273 2.8167 2.85271 1.71672C3.95269 0.616741 5.44458 -0.0012207 7.00018 -0.0012207C8.55579 -0.0012207 10.0477 0.616741 11.1477 1.71672C12.2476 2.8167 12.8656 4.30859 12.8656 5.8642C12.8656 7.3447 11.738 9.65003 9.51493 12.7166C9.22875 13.1158 8.85109 13.4407 8.41356 13.664C7.97604 13.8873 7.49138 14.0025 7.00018 13.9999ZM7.00018 1.2722C5.78243 1.27359 4.61494 1.75795 3.75386 2.61904C2.89277 3.48012 2.40841 4.64761 2.40702 5.86536C2.40702 7.03786 3.51127 9.20611 5.5156 11.9705C5.68575 12.2049 5.90898 12.3957 6.16702 12.5272C6.42505 12.6587 6.71056 12.7273 7.00018 12.7273C7.28981 12.7273 7.57532 12.6587 7.83335 12.5272C8.09138 12.3957 8.31461 12.2049 8.48477 11.9705C10.4891 9.20611 11.5934 7.03786 11.5934 5.86536C11.592 4.64761 11.1076 3.48012 10.2465 2.61904C9.38542 1.75795 8.21794 1.27359 7.00018 1.2722Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			attr_dev(path1, "class", "svelte-n55xjo");
    			add_location(path1, file$6, 34, 8, 1802);
    			attr_dev(g, "clip-path", "url(#clip0_3547_4001)");
    			add_location(g, file$6, 29, 6, 742);
    			attr_dev(rect, "width", "14");
    			attr_dev(rect, "height", "14");
    			attr_dev(rect, "fill", "white");
    			add_location(rect, file$6, 41, 10, 2931);
    			attr_dev(clipPath, "id", "clip0_3547_4001");
    			add_location(clipPath, file$6, 40, 8, 2888);
    			add_location(defs, file$6, 39, 6, 2872);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", svg_class_value = "" + (null_to_empty(/*classNameAddress*/ ctx[2]) + " svelte-n55xjo"));
    			add_location(svg, file$6, 21, 4, 566);
    			attr_dev(div, "class", div_class_value = "icon__line " + /*classNameAddress*/ ctx[2] + " svelte-n55xjo");
    			add_location(div, file$6, 45, 4, 3029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g);
    			append_dev(g, path0);
    			append_dev(g, path1);
    			append_dev(svg, defs);
    			append_dev(defs, clipPath);
    			append_dev(clipPath, rect);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*classNameAddress*/ 4 && svg_class_value !== (svg_class_value = "" + (null_to_empty(/*classNameAddress*/ ctx[2]) + " svelte-n55xjo"))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (dirty & /*classNameAddress*/ 4 && div_class_value !== (div_class_value = "icon__line " + /*classNameAddress*/ ctx[2] + " svelte-n55xjo")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(21:2) {#if categoryName === \\\"Address\\\"}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*categoryName*/ ctx[0] === "Address") return create_if_block$2;
    		if (/*categoryName*/ ctx[0] === "Payment") return create_if_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "icon__wrapper  svelte-n55xjo");
    			add_location(div, file$6, 19, 0, 496);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (if_block) {
    				if_block.d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $allowItemIndexBilling;
    	validate_store(allowItemIndexBilling, 'allowItemIndexBilling');
    	component_subscribe($$self, allowItemIndexBilling, $$value => $$invalidate(3, $allowItemIndexBilling = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TabIcon', slots, []);
    	let { categoryName } = $$props;
    	let classNamePayment = "", classNameAddress = "";

    	beforeUpdate(() => {
    		if ($allowItemIndexBilling === 2) {
    			$$invalidate(2, classNameAddress = "active");
    			$$invalidate(1, classNamePayment = "active");
    		} else if ($allowItemIndexBilling === 1) {
    			$$invalidate(2, classNameAddress = "active");
    			$$invalidate(1, classNamePayment = "");
    		}
    	});

    	const writable_props = ['categoryName'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TabIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('categoryName' in $$props) $$invalidate(0, categoryName = $$props.categoryName);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		categoryName,
    		allowItemIndexBilling,
    		classNamePayment,
    		classNameAddress,
    		$allowItemIndexBilling
    	});

    	$$self.$inject_state = $$props => {
    		if ('categoryName' in $$props) $$invalidate(0, categoryName = $$props.categoryName);
    		if ('classNamePayment' in $$props) $$invalidate(1, classNamePayment = $$props.classNamePayment);
    		if ('classNameAddress' in $$props) $$invalidate(2, classNameAddress = $$props.classNameAddress);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [categoryName, classNamePayment, classNameAddress];
    }

    class TabIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { categoryName: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabIcon",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*categoryName*/ ctx[0] === undefined && !('categoryName' in props)) {
    			console.warn("<TabIcon> was created without expected prop 'categoryName'");
    		}
    	}

    	get categoryName() {
    		throw new Error("<TabIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set categoryName(value) {
    		throw new Error("<TabIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\billing\Tabs\Tabs.svelte generated by Svelte v3.48.0 */
    const file$5 = "src\\components\\billing\\Tabs\\Tabs.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    // (12:8) {#each tabItems as item, i}
    function create_each_block(ctx) {
    	let li;
    	let div;
    	let tabicon;
    	let t;
    	let current;

    	tabicon = new TabIcon({
    			props: { categoryName: /*item*/ ctx[1].name },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			create_component(tabicon.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "icon");
    			add_location(div, file$5, 13, 16, 206);
    			attr_dev(li, "class", "svelte-1xshcb4");
    			add_location(li, file$5, 12, 12, 184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			mount_component(tabicon, div, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabicon_changes = {};
    			if (dirty & /*tabItems*/ 1) tabicon_changes.categoryName = /*item*/ ctx[1].name;
    			tabicon.$set(tabicon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabicon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabicon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(tabicon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(12:8) {#each tabItems as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let ul;
    	let current;
    	let each_value = /*tabItems*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1xshcb4");
    			add_location(ul, file$5, 10, 4, 129);
    			attr_dev(div, "class", "tabs svelte-1xshcb4");
    			add_location(div, file$5, 9, 0, 105);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tabItems*/ 1) {
    				each_value = /*tabItems*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tabs', slots, []);
    	let { tabItems } = $$props;
    	const writable_props = ['tabItems'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('tabItems' in $$props) $$invalidate(0, tabItems = $$props.tabItems);
    	};

    	$$self.$capture_state = () => ({ TabIcon, tabItems });

    	$$self.$inject_state = $$props => {
    		if ('tabItems' in $$props) $$invalidate(0, tabItems = $$props.tabItems);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [tabItems];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { tabItems: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*tabItems*/ ctx[0] === undefined && !('tabItems' in props)) {
    			console.warn("<Tabs> was created without expected prop 'tabItems'");
    		}
    	}

    	get tabItems() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabItems(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\billing\TabForms\CardsIcons.svelte generated by Svelte v3.48.0 */

    const file$4 = "src\\components\\billing\\TabForms\\CardsIcons.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let svg0;
    	let path0;
    	let path1;
    	let t0;
    	let svg1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let t1;
    	let svg2;
    	let path6;
    	let path7;
    	let path8;
    	let path9;
    	let path10;
    	let path11;
    	let path12;
    	let t2;
    	let svg3;
    	let path13;
    	let path14;
    	let path15;
    	let path16;
    	let path17;
    	let path18;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t0 = space();
    			svg1 = svg_element("svg");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			t1 = space();
    			svg2 = svg_element("svg");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			path9 = svg_element("path");
    			path10 = svg_element("path");
    			path11 = svg_element("path");
    			path12 = svg_element("path");
    			t2 = space();
    			svg3 = svg_element("svg");
    			path13 = svg_element("path");
    			path14 = svg_element("path");
    			path15 = svg_element("path");
    			path16 = svg_element("path");
    			path17 = svg_element("path");
    			path18 = svg_element("path");
    			attr_dev(path0, "d", "M21.75 0.25H2.25C1.14543 0.25 0.25 1.14543 0.25 2.25V13.75C0.25 14.8546 1.14543 15.75 2.25 15.75H21.75C22.8546 15.75 23.75 14.8546 23.75 13.75V2.25C23.75 1.14543 22.8546 0.25 21.75 0.25Z");
    			attr_dev(path0, "fill", "white");
    			attr_dev(path0, "stroke", "black");
    			attr_dev(path0, "stroke-opacity", "0.2");
    			attr_dev(path0, "stroke-width", "0.5");
    			add_location(path0, file$4, 8, 4, 159);
    			attr_dev(path1, "d", "M2.78773 5.91444C2.26459 5.62751 1.66754 5.39674 1 5.23659L1.028 5.11188H3.76498C4.13596 5.12489 4.43699 5.23651 4.53495 5.63071L5.12977 8.46659L5.31198 9.32073L6.97797 5.11188H8.77679L6.10288 11.2775H4.30397L2.78773 5.91444ZM10.1 11.2841H8.39883L9.46285 5.11188H11.1639L10.1 11.2841ZM16.2668 5.26277L16.0354 6.59559L15.8816 6.53004C15.5737 6.40525 15.1674 6.28054 14.6144 6.29371C13.9427 6.29371 13.6415 6.56277 13.6345 6.82546C13.6345 7.11441 13.9989 7.30484 14.5939 7.58725C15.574 8.02719 16.0286 8.56557 16.0218 9.26819C16.0081 10.5486 14.846 11.3761 13.0611 11.3761C12.2979 11.3694 11.5628 11.2181 11.1638 11.0476L11.4019 9.66205L11.6259 9.76066C12.1789 9.99071 12.5428 10.089 13.222 10.089C13.7118 10.089 14.2369 9.89838 14.2436 9.48488C14.2436 9.21565 14.0199 9.01851 13.3617 8.71646C12.7178 8.42087 11.8568 7.92848 11.8708 7.04198C11.8781 5.84042 13.0611 5 14.741 5C15.399 5 15.9312 5.13789 16.2668 5.26277ZM18.5278 9.09749H19.9417C19.8718 8.78889 19.5496 7.31147 19.5496 7.31147L19.4307 6.77964C19.3467 7.00943 19.1999 7.38373 19.2069 7.37056C19.2069 7.37056 18.6678 8.7429 18.5278 9.09749ZM20.6276 5.11188L22 11.284H20.4249C20.4249 11.284 20.2708 10.5748 20.2219 10.3581H18.0378C17.9746 10.5222 17.6808 11.284 17.6808 11.284H15.8958L18.4226 5.62399C18.5977 5.22342 18.906 5.11188 19.3118 5.11188H20.6276Z");
    			attr_dev(path1, "fill", "#171E6C");
    			add_location(path1, file$4, 15, 4, 472);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "16");
    			attr_dev(svg0, "viewBox", "0 0 24 16");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svelte-pxe2je");
    			add_location(svg0, file$4, 1, 2, 29);
    			attr_dev(path2, "d", "M22 0H2C0.89543 0 0 0.89543 0 2V14C0 15.1046 0.89543 16 2 16H22C23.1046 16 24 15.1046 24 14V2C24 0.89543 23.1046 0 22 0Z");
    			attr_dev(path2, "fill", "#252525");
    			add_location(path2, file$4, 27, 4, 1977);
    			attr_dev(path3, "d", "M9 13C11.7614 13 14 10.7614 14 8C14 5.23858 11.7614 3 9 3C6.23858 3 4 5.23858 4 8C4 10.7614 6.23858 13 9 13Z");
    			attr_dev(path3, "fill", "#EB001B");
    			add_location(path3, file$4, 31, 4, 2150);
    			attr_dev(path4, "d", "M15 13C17.7614 13 20 10.7614 20 8C20 5.23858 17.7614 3 15 3C12.2386 3 10 5.23858 10 8C10 10.7614 12.2386 13 15 13Z");
    			attr_dev(path4, "fill", "#F79E1B");
    			add_location(path4, file$4, 35, 4, 2311);
    			attr_dev(path5, "fill-rule", "evenodd");
    			attr_dev(path5, "clip-rule", "evenodd");
    			attr_dev(path5, "d", "M12 3.99951C13.2144 4.91172 14 6.36406 14 7.99988C14 9.6357 13.2144 11.088 12 12.0002C10.7856 11.088 10 9.6357 10 7.99988C10 6.36406 10.7856 4.91172 12 3.99951V3.99951Z");
    			attr_dev(path5, "fill", "#FF5F00");
    			add_location(path5, file$4, 39, 4, 2478);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "16");
    			attr_dev(svg1, "viewBox", "0 0 24 16");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "svelte-pxe2je");
    			add_location(svg1, file$4, 20, 2, 1847);
    			attr_dev(path6, "d", "M22 0H2C0.89543 0 0 0.89543 0 2V14C0 15.1046 0.89543 16 2 16H22C23.1046 16 24 15.1046 24 14V2C24 0.89543 23.1046 0 22 0Z");
    			attr_dev(path6, "fill", "#016FD0");
    			add_location(path6, file$4, 53, 4, 2891);
    			attr_dev(path7, "fill-rule", "evenodd");
    			attr_dev(path7, "clip-rule", "evenodd");
    			attr_dev(path7, "d", "M13.7637 13.3938V7.69238L23.9112 7.70149V9.27638L22.7383 10.5298L23.9112 11.7947V13.403H22.0386L21.0434 12.3048L20.0553 13.4071L13.7637 13.3938Z");
    			attr_dev(path7, "fill", "#FFFFFE");
    			add_location(path7, file$4, 57, 4, 3064);
    			attr_dev(path8, "fill-rule", "evenodd");
    			attr_dev(path8, "clip-rule", "evenodd");
    			attr_dev(path8, "d", "M14.4414 12.7687V8.31982H18.2137V9.34471H15.6628V10.0404H18.1529V11.0482H15.6628V11.7315H18.2137V12.7687H14.4414Z");
    			attr_dev(path8, "fill", "#016FD0");
    			add_location(path8, file$4, 63, 4, 3315);
    			attr_dev(path9, "fill-rule", "evenodd");
    			attr_dev(path9, "clip-rule", "evenodd");
    			attr_dev(path9, "d", "M18.1954 12.7686L20.2827 10.5416L18.1953 8.31982H19.811L21.0865 9.72986L22.3656 8.31982H23.9117V8.35483L21.8689 10.5416L23.9117 12.7055V12.7686H22.35L21.0519 11.3444L19.7671 12.7686H18.1954Z");
    			attr_dev(path9, "fill", "#016FD0");
    			add_location(path9, file$4, 69, 4, 3535);
    			attr_dev(path10, "fill-rule", "evenodd");
    			attr_dev(path10, "clip-rule", "evenodd");
    			attr_dev(path10, "d", "M14.2369 2.63184H16.6829L17.5421 4.58269V2.63184H20.5619L21.0827 4.09341L21.6052 2.63184H23.9111V8.33323H11.7246L14.2369 2.63184Z");
    			attr_dev(path10, "fill", "#FFFFFE");
    			add_location(path10, file$4, 75, 4, 3832);
    			attr_dev(path11, "fill-rule", "evenodd");
    			attr_dev(path11, "clip-rule", "evenodd");
    			attr_dev(path11, "d", "M14.7006 3.25098L12.7266 7.69615H14.0805L14.4529 6.80598H16.4708L16.843 7.69615H18.2306L16.2648 3.25098H14.7006ZM14.8702 5.80841L15.4622 4.39334L16.0538 5.80841H14.8702Z");
    			attr_dev(path11, "fill", "#016FD0");
    			add_location(path11, file$4, 81, 4, 4068);
    			attr_dev(path12, "fill-rule", "evenodd");
    			attr_dev(path12, "clip-rule", "evenodd");
    			attr_dev(path12, "d", "M18.2129 7.69557V3.25049L20.116 3.25703L21.0953 5.98976L22.0809 3.25049H23.9125V7.69557L22.7339 7.706V4.65265L21.6213 7.69557H20.5455L19.4099 4.64222V7.69557H18.2129Z");
    			attr_dev(path12, "fill", "#016FD0");
    			add_location(path12, file$4, 87, 4, 4344);
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "width", "24");
    			attr_dev(svg2, "height", "16");
    			attr_dev(svg2, "viewBox", "0 0 24 16");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "class", "svelte-pxe2je");
    			add_location(svg2, file$4, 46, 2, 2761);
    			attr_dev(path13, "d", "M0.205078 16H4.72294C5.75075 16 6.98186 14.8053 6.98186 13.8667V0H2.46401C1.43619 0 0.205078 1.19467 0.205078 3.2V16Z");
    			attr_dev(path13, "fill", "#047AB1");
    			add_location(path13, file$4, 101, 4, 4755);
    			attr_dev(path14, "d", "M2.76896 10.8162C1.90163 10.8163 1.03857 10.7014 0.205078 10.4748V9.3015C0.851867 9.6792 1.59118 9.89234 2.35106 9.92016C3.22075 9.92016 3.70642 9.34416 3.70642 8.55483V5.3335H5.8524V8.55483C5.8524 9.8135 5.15213 10.8162 2.76896 10.8162V10.8162Z");
    			attr_dev(path14, "fill", "white");
    			add_location(path14, file$4, 105, 4, 4925);
    			attr_dev(path15, "d", "M8.11133 16H12.6292C13.657 16 14.8881 14.8053 14.8881 13.8667V0H10.3703C9.34244 0 8.11133 1.19467 8.11133 3.2V16Z");
    			attr_dev(path15, "fill", "#D42D06");
    			add_location(path15, file$4, 109, 4, 5221);
    			attr_dev(path16, "d", "M8.11133 6.08005C8.76642 5.48272 9.89588 5.10939 11.7256 5.19472C12.7195 5.23739 13.7586 5.51472 13.7586 5.51472V6.69872C13.1643 6.35925 12.4963 6.15137 11.8047 6.09072C10.4154 5.97339 9.56834 6.70939 9.56834 8.00005C9.56834 9.29072 10.4154 10.0267 11.8047 9.92005C12.4967 9.85399 13.1643 9.64261 13.7586 9.30139V10.4747C13.7586 10.4747 12.7195 10.7627 11.7256 10.8054C9.89588 10.8907 8.76642 10.5174 8.11133 9.92005V6.08005Z");
    			attr_dev(path16, "fill", "white");
    			add_location(path16, file$4, 113, 4, 5387);
    			attr_dev(path17, "d", "M16.0176 16H20.5354C21.5632 16 22.7944 14.8053 22.7944 13.8667V0H18.2765C17.2487 0 16.0176 1.19467 16.0176 3.2V16Z");
    			attr_dev(path17, "fill", "#67B637");
    			add_location(path17, file$4, 117, 4, 5863);
    			attr_dev(path18, "d", "M21.6649 9.28016C21.6649 10.1335 20.9646 10.6668 20.0272 10.6668H16.0176V5.3335H19.6657L19.9255 5.34416C20.75 5.38683 21.3599 5.8455 21.3599 6.63483C21.3599 7.2535 20.942 7.78683 20.1853 7.91483V7.94683C21.0211 8.00016 21.6649 8.5015 21.6649 9.28016ZM18.7848 6.17616C18.7362 6.1693 18.6871 6.16573 18.6379 6.1655H17.2826V7.5095H18.7848C19.0671 7.4455 19.3043 7.20016 19.3043 6.8375C19.3043 6.47483 19.0671 6.2295 18.7848 6.17616V6.17616ZM18.9542 8.35216C18.8944 8.3433 18.8339 8.33973 18.7735 8.3415H17.2826V9.80283H18.7735L18.9542 9.7815C19.2366 9.7175 19.4737 9.44016 19.4737 9.06683C19.4737 8.6935 19.2478 8.42683 18.9542 8.35216V8.35216Z");
    			attr_dev(path18, "fill", "white");
    			add_location(path18, file$4, 121, 4, 6030);
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "width", "23");
    			attr_dev(svg3, "height", "16");
    			attr_dev(svg3, "viewBox", "0 0 23 16");
    			attr_dev(svg3, "fill", "none");
    			attr_dev(svg3, "class", "svelte-pxe2je");
    			add_location(svg3, file$4, 94, 2, 4625);
    			attr_dev(div, "class", "card__icons svelte-pxe2je");
    			add_location(div, file$4, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, path1);
    			append_dev(div, t0);
    			append_dev(div, svg1);
    			append_dev(svg1, path2);
    			append_dev(svg1, path3);
    			append_dev(svg1, path4);
    			append_dev(svg1, path5);
    			append_dev(div, t1);
    			append_dev(div, svg2);
    			append_dev(svg2, path6);
    			append_dev(svg2, path7);
    			append_dev(svg2, path8);
    			append_dev(svg2, path9);
    			append_dev(svg2, path10);
    			append_dev(svg2, path11);
    			append_dev(svg2, path12);
    			append_dev(div, t2);
    			append_dev(div, svg3);
    			append_dev(svg3, path13);
    			append_dev(svg3, path14);
    			append_dev(svg3, path15);
    			append_dev(svg3, path16);
    			append_dev(svg3, path17);
    			append_dev(svg3, path18);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CardsIcons', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CardsIcons> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class CardsIcons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CardsIcons",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\components\billing\TabForms\PaymentForm.svelte generated by Svelte v3.48.0 */
    const file$3 = "src\\components\\billing\\TabForms\\PaymentForm.svelte";

    function create_fragment$3(ctx) {
    	let div16;
    	let div7;
    	let div1;
    	let svg0;
    	let path0;
    	let t0;
    	let div0;
    	let t2;
    	let div3;
    	let svg1;
    	let rect0;
    	let defs0;
    	let pattern;
    	let use;
    	let image;
    	let t3;
    	let div2;
    	let t5;
    	let div5;
    	let svg2;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let path5;
    	let t6;
    	let div4;
    	let t8;
    	let div6;
    	let span;
    	let t10;
    	let div15;
    	let label0;
    	let t12;
    	let div9;
    	let input0;
    	let t13;
    	let div8;
    	let cardsicons;
    	let t14;
    	let div14;
    	let div10;
    	let label1;
    	let t16;
    	let input1;
    	let t17;
    	let div13;
    	let label2;
    	let t19;
    	let div12;
    	let input2;
    	let t20;
    	let div11;
    	let svg3;
    	let g;
    	let path6;
    	let path7;
    	let path8;
    	let defs1;
    	let clipPath;
    	let rect1;
    	let current;
    	cardsicons = new CardsIcons({ $$inline: true });

    	const block = {
    		c: function create() {
    			div16 = element("div");
    			div7 = element("div");
    			div1 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Card";
    			t2 = space();
    			div3 = element("div");
    			svg1 = svg_element("svg");
    			rect0 = svg_element("rect");
    			defs0 = svg_element("defs");
    			pattern = svg_element("pattern");
    			use = svg_element("use");
    			image = svg_element("image");
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Paypal";
    			t5 = space();
    			div5 = element("div");
    			svg2 = svg_element("svg");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			t6 = space();
    			div4 = element("div");
    			div4.textContent = "US Bank";
    			t8 = space();
    			div6 = element("div");
    			span = element("span");
    			span.textContent = "...";
    			t10 = space();
    			div15 = element("div");
    			label0 = element("label");
    			label0.textContent = "Card number";
    			t12 = space();
    			div9 = element("div");
    			input0 = element("input");
    			t13 = space();
    			div8 = element("div");
    			create_component(cardsicons.$$.fragment);
    			t14 = space();
    			div14 = element("div");
    			div10 = element("div");
    			label1 = element("label");
    			label1.textContent = "Expiration";
    			t16 = space();
    			input1 = element("input");
    			t17 = space();
    			div13 = element("div");
    			label2 = element("label");
    			label2.textContent = "CVC";
    			t19 = space();
    			div12 = element("div");
    			input2 = element("input");
    			t20 = space();
    			div11 = element("div");
    			svg3 = svg_element("svg");
    			g = svg_element("g");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			path8 = svg_element("path");
    			defs1 = svg_element("defs");
    			clipPath = svg_element("clipPath");
    			rect1 = svg_element("rect");
    			attr_dev(path0, "d", "M20 4H4C2.89 4 2.01 4.89 2.01 6L2 18C2 19.11 2.89 20 4 20H20C21.11 20 22 19.11 22 18V6C22 4.89 21.11 4 20 4ZM20 18H4V12H20V18ZM20 8H4V6H20V8Z");
    			attr_dev(path0, "fill", "#0085FF");
    			add_location(path0, file$3, 14, 8, 322);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "class", "svelte-105pe8i");
    			add_location(svg0, file$3, 7, 6, 164);
    			attr_dev(div0, "class", "text");
    			add_location(div0, file$3, 19, 6, 544);
    			attr_dev(div1, "class", "card svelte-105pe8i");
    			add_location(div1, file$3, 6, 4, 138);
    			attr_dev(rect0, "width", "55");
    			attr_dev(rect0, "height", "14");
    			attr_dev(rect0, "fill", "url(#pattern0)");
    			add_location(rect0, file$3, 30, 8, 828);
    			xlink_attr(use, "xlink:href", "#image0_4069_6438");
    			attr_dev(use, "transform", "translate(0 -0.023298) scale(0.00078125 0.0030692)");
    			add_location(use, file$3, 38, 12, 1071);
    			attr_dev(pattern, "id", "pattern0");
    			attr_dev(pattern, "patternContentUnits", "objectBoundingBox");
    			attr_dev(pattern, "width", "1");
    			attr_dev(pattern, "height", "1");
    			add_location(pattern, file$3, 32, 10, 909);
    			attr_dev(image, "id", "image0_4069_6438");
    			attr_dev(image, "width", "1280");
    			attr_dev(image, "height", "341");
    			xlink_attr(image, "xlink:href", "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQAAAAFVCAYAAACw6EKgAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAACAAElEQVR42u3deXxW1Z0/8M/3PM+ThB3ZEhaRJQkJqVqLFSHBRttqbW3tMjKd1tqqLLWdsfNzZmrd4OLWbWo7drEIarV2EVtr972iJCCtu4asLEUICaCyBZI8zz3f3x/gQhIgy/Mk99z7eb9evqajkNz7Peeec8/3nkUQAgVzvberwftE8W4FJgswAcBQUFAcEqD19f9HD//vQwD2AmgDcECAFgD7VfGKCl41wKsqeFV9eSUW1x0aQ2Pdam83Q0lERERERERE1DPi8sUXlnrvt8D1ApSyKCOhFcA2AI0CbAWwySrqxZj6WHu8oebv17/CEBERERERERERHc3JBGDJHG9Uu8EKAB9lEdJbKvNrClSJ4gUYPA8fzx1ox0uNT3sHGR0iIiIiIiIiiirnEoAFZ99SjJj/RwAns/ioG3wANVBUikGl72PtxnVeA8NCRERERERERFHhVAJwRuktMyz8xwCMZ9FRHzQL8LgV/NH48T/WrbtxO0NCRERERERERGHlTALwtPO/PuRQS8tzAPJZbJRmL6nij0bML+sqbSXgWYaEiIiIiIiIiMLCmQRgQZn3PSiuYpFRhu0Wxe+tkYcnxfX3q1d7KYaEiIiIiIiIiFzmRAIwv/TmEoF9EY6fWkzOPR3boLgvpfF7Nq+98Z8MCBERERERERG5yImEWsFc7x4IrmBx0QCxCvzRiKyoG1/8Kzw832dIiIiIiIiIiMgVgU8AHtn77xUA2SwuCoCNgHw9mdD7t6z2WhkOIiIiIiIiIgo6E/QLbD3YMgdM/lFwTAf0+1lJbM4vW3ZtSbk3lCEhIiIiIiIioiALfAJQFeewmChw9RLIE9WvJJOoLyhdtri83IszKkREREREREQURIFPAApwGouJgkqBPEC/vz2FF/LLln2QESEiIiIiIiKioAl8AtACxSwmCjxFsaj+qqDM+830c249mQEhIiIiIiIioqAI9CEgJSVeVvtItADg8kpyyT6ILKmv0G8DnmU4iIiIiIiIiGggBXoGYNso5IPJP3LPcKh+q2Au/jSl3MtjOIiIiIiIiIhoIAU6ASi+cPkvuUvw7kQSL+TP9c5nMIiIiIiIiIhooAQ7ASg6g0VEjhsrgt8VlHk3IuBL7omIiIiIiIgonIJ+CAhnAFIYxKC4paDMWzWl3MthOIiIiIiIiIioPwU6AWiBIhYRhYbiX+JJ/HbarK+MYDCIiIiIiIiIqL8EOQEoAnAJMIWKAOfFclpX58+7fSyjQURERERERET9IbAJwPzZ3kQAw1hEFEJvF9v+l5I53iiGgoiIiIiIiIgyLbAJQInzBGAKtdPaDX43o/SrTHITERERERERUUYFNwEIngBMoTdbceiXJSVeFkNBRERERERERJkS3D0AlScAU/gpcG77SNzNSBARERERERFRpgQ2AWiFJwBTZHy6cK53DcNARERERERERJkQ4CXATABSdKjga/lzvfMZCSIiIiIiIiJKNwniReXP9oZLHHtZPBQxOw1wRm2l18hQEBEREREREVG6BHIGoCQM9/+jKBpnFT/GJatiDAURERERERERpUswE4CqXP5L0SR4V/6O6v9mIIiIiIiIiIgoXQK6ByATgBRdorosv/TmEkaCiIiIiIiIiNIhkAlAqzwAhCItW2Dv4VJgIiIiIiIiIkqHYC4BFiYAKfJm52+vXsQwEBEREREREVFfBe4U4Fmzlif25exoAZBg8VDEvZplUVC1znuVoSAiIiIiIiKi3grcDMB9iZ35YPKPCABGJQ1uZBiIiIiIiIiIqC8ClwCUuOXyX6IjFPj8tDJvMiNBRERERERERL0VvD0AVYtZLERvyIpbXMswEBEREREREVFvBS4BaIEZLBaiN6ngysI5t05kJIiIiIiIiIioN4K3BJgnABN1lK0m9QWGgYiIiIiIiIh6I4BLgJkAJOrCFVPKvRyGgYiIiIiIiIh6KlAJwCPLHIezWIg6GZ2VwnyGgYiIiIiIiIh6KmAzAH3O/iM6BlUsYBSIiIiIiIiIqKeClQA0PAGY6DjKppV5kxkGIiIiIiIiIuqJQCUAeQIw0XGJUfkYw0BEREREREREPRGoBKCAB4AQHf8Z0UsYBSIiIiIiIiLqiaCdAswlwETHd1bJHG8Uw0BERERERERE3RWYBOCM0q8OAzCBRUJ0XLF2g3KGgYiIiIiIiIi6KzAJQNW2IgDCIiE6ofcyBERERERERETUXcFZAmwsl/8Sdc9choCIiIiIiIiIuiswCUCrPAGYqJtKJszyBjMMRERERERERNQdgUkACg8AIequ2OBsczrDQERERERERETdEZwlwIIiFgdRd+nbGQMiIiIiIiIi6o5AJABnzVqegGI6i4Oou0+u5jMIRERERERERNQdgUgA7s/aMR1AFouDqHtEwQQgEREREREREXVLIBKAVoQHgBD1DBOARERERERERNQtwdgD0CgPACHqmUkMARERERERERF1RyASgKI8AISoh4bnX3hnNsNARERERERERCcSlFOAmQAk6unDu2ffGEaBiIiIiIiIiE4kGAlAYQKQqMdilglAIiIiIiIiIjqhAU8Azij1JkAxgkVB1DPWYjCjQEREREREREQnMvAzALn/H1HvHh3RHEaBiIiIiIiIiE5kwBOAvmECkKg3YgATgERERERERER0QgOeAOQJwES9YxVZjAIRERERERERnUgQDgFhApCoFwRIMQpEREREREREdCIDnwAUFLMYiHpOoUlGgYiIiIiIiIhOZEATgCXl3lAoJrIYiHpORZgAJCIiIiIiIqITGtAEYCqJIgDCYiDqubiRdkaBiIiIiIiIiE5kQBOAPg8AIer982Oxh1EgIiIiIiIiohMZ0ASgGCYAiXr98Fqzh1EgIiIiIiIiohOJD+hv5wzAnrM+1CYBm4IyGr0mIoAcWX2uAhgBYCAiUBEIBIBAIW/8saCtVs8Zlr2HJUlBMrnsyycN9pOTVOxYNYE4ZT54bY+FTRmzV3xYE7N7TQr2YDx7b/yQ2E1Pf2kvI0RERIGiKrkra6eo0TzxdQgDcqxhrRyMCdqA2EEbQ5uV5MFBh/y2rNSggw1XF7QxQkThk39nfXbLEP9U69uRA30tRuQ1m91e03zZ6S3HHYsM5EUWlHovAShh1TlRv2uB9hbY9gOAWgZkwJ6qBMTEISYGxOKAiUMkBkjsyJPUr49Te32ll81CoYE2ac4dgwbH9l+h0MugOBNg4q+PkgB2AdipwA4AuwywRRWbNWY2W7WbN1V4LwP8BkRERJmTd3dViUrs/wF6EYBcRqTP9guwA6I7VWUXgG2q2ALoZoVu1lhs4+4ri/YzTETBN+aemmExtbdAZQGAIH0YOQjBj8TEb2i6omBXV39gwBKA5eVefHsSLQCyWIWORaHtB2Fb9zAULhADiefAxLOhsQRE4njL9ME01wz8s6HSm8Kg00DKL/PKRfEAgJMZjf4dRADYIMBLKvKiqq7H8FHPNvz+as4wICKiPply3+acQ6nWrwL4d/CjXv8O/AT/hEUVjLwEtc/GrK5rXFyylaEhCo5xK17MFY3/DYKZgb1IwRZJ4tymq4q3dP5PA6SozCv0FbWsQsfpBQ6+AptqZSCcJpBYNiSRA8SzICaersduXX2lN5fxpYFSWLrs0wq9B0CM0QiEdgDPAlhjBX89dAhPND7tHWRYiIiou8bcUzMsZvX3AEoZjcDYAeBJEfzN+OYvjYtn1DAkRAMnb0X1HxS4IPAXKljfPLyoFPPFP/pfD5D8Uu9DAvySVahr/sFXACb/wimWBZM1BIi9nhDslZ/XV3r/wmDSQCgs9d6vwK/A5F+QtSlQKSqPisYeqVt343aGhIiIjklVclfU/AGC8xmMQNsO4Ldq8POdqZbHsPjMJENC1D/G3VM9RyzWutOu44PNi4p/89Z/NWCHgIiiKGBnKgSmlLTtAJN/Yea3wx5qf/P/TwxGLGsIxMSTKibRvQcIHMzTgJhc9uWTVNtWgsm/oMsW4DyInqeS+r+CUu9JEflRK7J+vLXiutcYHiIiequ8e2o+r0z+uWAigEVisSjXDHkNK6ofNaI/2HFl8RqIcH9gogwyVi5Uh7bhVsH7AByVABy4fR0MTwDukvVh2/YxDlGSPAi/ZRdS+3ck7MFd1eq3Pw6VV477MCs2M3A0ELJt++cAjGcknCIA5qjqd7K1rTG/1Ptp/ryb38WwEBERcPgkS1XcwEg45yQAl1uVx3NX1tTlrqi+fsLy2jEMC1FmKOxpbg0AdFLHf2cGMHpMAHYRFG1l8i/SNSDVXmxbdr3L3799mLbufRI29XcAfuenWTYyWjQwPYkuZhCcliPAv4q1q/NLvX8UzvU+Xl7uxRkWIqLoOpDjXwwgj5FwWj6A23xj/5m3YsNdY7+/oYAhIUrzWB3iWA5LDnT8NwOWABQwAdipQilgU4cYCAKgWbb9wNn+geaz7IGdjWrbnwDwxrpwSZkGxoj627RzbikAT/wNDQHOVMFPtidRV1jmLcIlq7ism4gokoNaPY9RCI3BCvmsiUlN7orqVeOW109nSIjSYPlTCQGmOfau3ylnMCAJwCnlXp4enrJMb2XbGAPq/FJmkyfbA7vO8fc37VG/7XEA+5M5PpcAU7+LWXsmoxBKU1WxvKBxw9NcGkxEFEEC9u/hYwBcIia1IXflhm+dtHzjCIaEqPfyEoMKACRcumaFVnfVMPS7eIqz/7qUZAKQjvcE+3m2Zfe7Ui07tx36xMcXY/lTCQaF+nV8oMq2O9xOF2tXF8z1fp0/25vEcBARReH9UgXADAYitLKg8oUs014zbsWGy46UNxH1kPWNc+MgNbGajv9uYJYAWylmFeoiLKl2BoFO/CAPGbwPot/KM0Neylux4f2MCPUjJgCjQHCRJPBS/lzvUgaDiCjcJty94WQAQxmJ0MsTyP25K2r+MOaemgkMB1FPX4+dGwfZeGp/fcd/OSAJQDGcRdJ1ETEBSCemY8YcAgAFChXy29yV1b8cfVftREaGMl73mACMUmGPEMEPC0u9H84o/eowBoSIKJxSccO+PUoE58esPpd7d82HGAyiHjw66toBINjSuPjMgx3/5cDMAOQJwF2wDAF1iz9pUlaH5+lD8bi+NO7umk8yOpQ5ngFQyDhEiwKX+jj0VOEcj/02EVEYB7U+V2ZF0FiIPpq7suYr8NQwHETdeCcW1yaxSU1X/3agHngOJDrymQCk7rETTx7XRZM0UkQfzF1RvWry917gATuUdvlzY1MB5DASERwcAoUwWFs4Z9m7GQ0iopC18WK5/19Uu3fVa3MnVj8yYflTgxkOohNQt/ZKFdFgJABPO//rQwCczBrUoT7ZFINA3dFuR4855Tj//ZL2ROLJsd/fUMBQUXrfEi0/3ET6nQcnqdHf5c/1/oXRICIKU/vOGYARf8O72DeDH5u0smoUY0HUtdF31U6EYLhTbbtFMBKALQcPFQHg6UOdCijJINCJ60lWYqMakzjBQL3QxOTJvHtqzmXEKG2vh4YztwlZIvgpDwchIgoVzgDkW95ZKTV/mXh/9WjGgqizeCLl3DjIig1GAlCUB4B0RX0eAELdqCejx+3s5h8dpVb/kLei5nJGjdLSibDtpsNiIvgBZwISEblv5H3PjgQwnpEgBc5Itevvxn63iidCE3Xg4AEgSNh4dVf/ngnAoEi1MgZ0Qv4pU+M9+ONZCr0n7+4Nn2PkqM9tN/dupTfFRPDD/Hk3v4uhICJyV3Yqm307vfVt76xYlvkZlj+VYCyI3qTuJQBfaVw8Y3dX/6H/DwHhMrKuqhRDQN2Smj59Yk97chX5Tu6K6kWMHvUR9wiit8oRax8pLPOmMRRERG4SGPbt1HFUekGuGfK/jATRUY2lUzksEa0+1n/r/wSgMgHYOSY8AZi69Sjvs6NGndKrJgu4a9zdNZ9kDKk38ufdPhYA94WhjkapxcNTyj2eDk1E5OIQRLj/H3Xp6nErarjfL9HrbaVjK6FUTc2x/lv/JgAvWRUDwNNJOxaQ9RkEOrEhQwdBpLcH6BgRvW/8yg3nMJDU48pjU/xwQ10TvCORxJcZCCIiJ0chnAFIx+je9ftjv7+B43aKvLHfrRoqwESXrlmhwUgATmuunQYgm9WoA58nANOJ2XG5fd2PI2FVHsldUTOV0aSevQVaDhDoeL6QP2fZBQwDEZFj3TtXZtGxDTEx+QFWaYyhoCiL58SKcHhFnTMMArIE2FjLTqYLlglA6gZ/2vR0/JjRCv1Z/p31TMRT99socIkQHX8MKUa/x6XARETuKFlVlaUA93Gl45mbt6d6McNAkR6Dq3sTITQWD8YMQH5l6rJ4AP8Qw0AnenrQXlCYpp+EdxzISd3KmFIPminOAKQTmZZI4b8ZBiIiN7xyAPkA4owEHfcVUOTWvHvrxzISFNlRuDo3EaK1eWjBP4/1H/t3D0BVJgA7VynA8hAQOoEhQ4GsRPoeRcE1eSuqyxlY6mYrxbabutGw4LriebeNZyCIiILP+oZ9O3XHSdb6HsNAkR0HibjWVtZhvhzzkIn+nQFoOIjsPGBi8o+68ZI2Lu1jaqPAvROWPzWY0aXjmTTnjkEATmEkqBsGpzT5JYaBiMiBQS2Es/upe3VFdSH3EKeoUudWsUr1cZMA/Rw87iPVKSg8AZhOLFmQn4kfO9WaIV9kdOl4BscOFPZ3X0Eu92lYVDjn1okMBBFRwIeIHJdR9yUA5Qc+ih7vsTiAfJcuWY5zAjD6c1A3dfZtuQBGsxZ1GCulUgwCHZ8xSBUWZGisji/m3VU9hUGmY7I8AZh6JMea1OcYBiKigI9BRNm/U098OveuhnEMA0XJmAl50wA4dXimakASgLEsn8t/uxpbazuDQMd/iEeOAUwsUz9+kCbwZUaZjtNLsO2mHhFgEU8EJiIK9AhRoChkIKgHshFPLmAYKEpicG7/P9igzAAUywNAuuS3MgZ0XKlp0zL8Eoj5uSs3vI2Rpq6rB5cIUY+NSaTkIwwDEVEwTVzZMBGC4YwE9dAiqArDQFEhxrqWw7IJPVR3vD/Qj/s6MQHYJS4BpuM3O0iedlqmf4mBCvf1oGM03eASIepNxfkkY0BEFExJJNm3U2+cMvbuulKGgSLzNmsdmwgh2Nq4+MyDxx/499/FsKPpVKOUMaDjGzwUOnRof/ymj49dWZXPgNPRPANwiRD1pn/D+fnzbh/LQBARBY8R4ex+6pWY8fmBj6JD3FoCrNDqE7b//XYxyn2kOuMJwHSCGnLy5H7rz2PWLGbE6a1mnBM7BcAgRoJ6IWG0/UKGgYgoeCyEEzOod2N6yMVcBkxRGg65dLFipeZEf6ZfEoATZnmDBTiZ9adDA2qZAKTjS86a1X/1UfCZ/Dvrsxl1eqNO+D4HCNSHQQKYACQiCuIgUbk1E/Xa+LErNpzOMFDYjVvxYi6A0W417ghGAnBwlpmBft1v0JHBUYonANPxHpyh8MeM6c/fOGb/oNRHGXh6nQWXCFFfOjmcf2QZORERBQsTgNRrRsz7GAUKfT3XeJF7z6YGIwEoMctZJF3FxW9jEOiY/FOmDUClxMcZeXqzPijbbuqLUdPnYibDQEQUoIb5wfrhAMYzEtRrijIGgcLOGvc+lKhJBGMPQFFwFklXlSrFBCAd86lB+6wzB6JDv+DIiyERhHu3Uh/FDOYyCkREwZFoaS8GwD3cqC/DlLnwlDP8KdzV3DqXw3q16YqCXSf6Q/314HIWSUc8AZiOZ8hQ2FEjB+I3ZydaUxexAOgIJgCpj30dzmIQiIgC1Cwbbu9BfXbSmAk1+QwDhZmIczms6u78oXh/XIkVFAnzXR2jwhDQMaVmDOCqOcVFAH7MUoi2orNuH+2jfWwIby0pwIFO1V5goBjBkk93c4K3MQpERAEa1Ib3BOD9AFJd/PvBAHjIXZoZaAmAOkaCQvsOKyiCUzmsE58ADPRLAtAzoihgFepQoTTFINAxelSDttkDOmmmHKoCYdo+0m1UdqooRN8pXlGRr8OanzWsvWljT/7iaed/fcieg6ksAIglbVZ2IjnCWjMCxo5QyFioThTFVBVMATANQAGAGGvQG15fasb2hIgoGKPaIoTnFW+1iP6vZiVXN192ekv3h6dqJo978Y2Pfsms+HBfzQiFP8KoGQHRXAimQDFFBFNUpQjAGFaet6QaYEoA/IKRoDCadMfLg5J6YLJbTbsGIwGYPzc2FfBzWI06FFCKCUA6Rt3ImwgkEgN5CePHr6wv2tHNacQUTr7VojBsEKSCF40fv7B+3Y3be/P3X/jT/7QAeOugovl4f35G6VeHqW09Sw3mAloG4Dz002z7gBo+o9QbX1vpNfKpIiIKANGwbO9xQ/OCoi/36oO1J3Yr8Npb/s1rJ/orY1dW5QtkDmDOFtX34fBHvwjXI8ul5BRabUP3zTAwxq1HEsFIAIrxi/ndv4tBqZ9kEKhL7e8c+C2zfNhyMAEY8UZKi13fIlyA18SPX1jXy+Rfb9RWXrsfwF+P/IOps2/LjcVTnxDopwGcHsWq5AOTATABSEQ00JY/lQAw3f13FCxvXlR8Oxb236/ctaCkAUADgB9CVcau3FBmELsM0EuA6G0hopDJfKAorAzEvROANV7dvXvLfOvATeS7CAr8VoaBOhs0BKlTThnwyxC1Z7Iwok2M+223qnyjP5N/Xdm8/obmhsql36yv9N6ugnMBrItgdeIggYgoACZg2HQACcdv45DE4zcN7EuS6K6FJWuaFxYttO12EiA3AtgbqfdEYd9OYa7fziUA23aelL+lO38w4wlA4SmSXYxKAVifcaBOkiWnBaOKirydpRH5dsr5tltUfx6k62mo8FbXV3qlAK7C4c3Ko/ESpZLLB4qIaOClYr77fTvwRNMVBbuCcj27Pl9yoHlh0W2plCkB8JsIvSfm8Ymi8FZv5xKAdZgv3UowZTwBaJkA7DoqRB3FE0idPTsoL1dvK1lVlcVCiaYp5V4OgCmO30ZL3TqvNojvFPWV3vetYi6AzZF4iTI6hE8VEVEQ3u/cPwFYFc8E8bpeuWrG9uYFRR9S6BJE4+CrHKxSHnpGIX15dW2vVO321l2cATgg5cMEIHVmpxbABmev0axXDiCfpRJN2T4K4fhJtgLUBPkFfONa7yWx8XkANoa9PoliMJ8qIqJAtMfub+/RzZMuBybAojsXzrwF0IWIQBJw7K4Ng/hUUeh4aiAocKttl263ixnNNuTPu30sgNGsRUezlgeAUMen1qBt3ryAVVSZyoKJJl/F+ZPdFKgJ+jXWrbtxuwjOB7An1M0bMJRPFRFREPpG908ANhILfP/evHDmPYDeHvoKNZj9O4VP7sTaUwC3Pl6rIBgJQPHbi1mFupBiApA6PLTjJ8IODdYqObUyjSUT1Qqp7rfdEvwEIADUVXibVGRRuAecnAFIRBSQUaLrCUBtzzFO9O/N25s9Ea0Ic3UymmD/TqEjDraTVmxAEoCGy3+7jIvfziDQWyqEoPXc84J4ZZwBGNmOLwRLhKwbCUAAaKhY+jAEvw1tfQK4ByAR0QAbfVftRAiGO34bja9eWrDPiSv1zk0ZMQsApEJbqWyKCUAKX7WGdW0ihJqsVF13/3BmNxxTJgC7rFRMANJbH5Pxk2BHB3ClvMgElk5ESQgSgHAnAQgARnA9QnpClALcI4iIaIDF4zrD/bsQp/r2xiuLalXwYGhfF22M/TuFr14LXGsrtzZfdnpLt8ccmbwSngDc1UhIGQM6qoVpLT83qJWV+3dGkmcAFDp+E76MGFXv0gXXrvFeUGB1KJs5xUE+V0REA9wWuzerpatxVLVrlxz39duhHdYa/xCfLApdvXYshyVAj9pFk+GLYQKwU43yGQN6szqMnwQ7ZkxQm5MxLKHoKTobk+H6kk3FpobfX93m3OBM8cNwDhBwgE8WEdEAt8Xu7/8HCfIJwMfQuHjmMwBeDGOdkqSwf6fw1WvHcljaw5nRGUsATppzxyAAp7AKdex8mQCk11sXg9b3nB/kK+QMwAhKxkPw4UZQ7eJlZyl+hTAuA1YmAImIAtA3hmB7D1Pt6KX/OoxVyhjD/p1CZdLKqlEAxjnVLvbww0jGEoCDZN8MZHqPQQdZngBMR/jTC2FHjghyc8J9PaI4PtBQJABrXLzsqnXeq4Cb137clkSlhU8WEdGAc34JsG/c7CMFWhnGCpWVlcUEIIVKO2LOtZOmhwcfZixBx+W/xwg4DwAhABJLoPW97w36ZWazpCJYN8PQdltxOYn299D1e1wCTEQ0oMbcUzMMgNuHuyn27b6yqNHJftDG/h7CapXacvnUVj5dFKpxkFrnxkHqJwKyB6BhArCrnsum2hgGQvsZZwKJRNAvM4slFclmKgRLhNxNAKrKltBVKS4BJiIaUHFfigCI0zdh4OryXzQunrEbwP5w1Sru/0dhHAa5dgKw7Gm+Kn9nz5rSDLHKBGBXNSqM2ztRDw0agvazZ7twpUwARlEI9ghqN4kad8OPreHr+vQ1PlhERAPHGt/9A0AUtY7fQsj6d/btFMZhkGuHJemGnv6NTC4BLmYV6lg+TP6RoO29FwLGie0xWWEjZkq5NxJArttPGJq2Vlzn7EupxML3Qm0stvDpIiIawL4lBCcAK9ydAXjEnnCNa9m3Uyi5lcPSnp+MnqEshGcAFLD+dGwnUwxCxNlTpiE1ZbIrl8sTayIm1oaZIRgguH2IhkXoNor1hYMEIqKBFIb9fXt60mUAtYWsUrFvp1ApWVWVBWCKU4+hmGAkAAvLMAUATxDt2HH5PoMQZfEsHHrf+xyqsOCJNVEbIMRCsXWD2wMECd1zd3DjWm8Xny4iogF8pQvB1kxxP+Z0/y4IV/+uwD/5ZFGY7N4nhQDiTj2HEpQZgNz/r+uGnweARFr7OecC2Q4drCucARi5NioMbbc4fQIwrJUhIatWW3BkB1wiIhoA3mNxCPIdv4tkI/ZvdPwla2iYqpXhDEAK3TjIODcOsrA93hohMxlOkWIo3/ePprApnpQeVXbSKUi+rcS1y97Hkosc95cIWXV6jyBjdETIuk8OEC5ZFZu8Y+Pw1//frRXX7QGTokTUTyacPH66b9Xxg920AYvPdPrDtKqMCNfghv177gPPD8k+IFkA0DZU25svO72FLY7LzyiKHDsrvX3Xtp09fg7jmWkPdIawDnUgPAQkqiWflYNDF33QvUYQ4Olekev5nOv4OvERr3W8DIaHrOsL7RKhGaVfHab2UDFiKLKKKQaYrIJJUIxTYJQAowEMRePRB7QVlHqv/89DArQqkAKwU4CdCjQC2KUiTUbRZFXqbFvWhk1Pf2kvGygi6lW/aMOwMktqQlAU4erf/fD27+NXbjhFbWymwuYLMFlFTgZ0EqCjABkFYBSABNqAtsSRv9QG5K544xv0kTGUHADsDkB2QnUnDBphZadCt1lI1e7Gpk3wzuUhAYFpZtS1trKuN/UnnpnY8QTgzoM6Jv+i2ZAIWi94P5Dl3odXCdtpZXRc+RfemY19r05z/DZaNq+9cavbfQUmIURf0ASyMRTPx2xvuDHyThidrcBsBU63OHQKDAAFBEem9Okb7Wd3DNI390seq0DJm+9RCgUgoojltKKgzNsGxQYBqlTlRTH6eF2Ft4ktFxGdeFxmi1Qc71jU8f19V2kMe2vGh6hatTU1N20Lw42M/f6GAjHmLBE9C8BZAEqsYhjE4s1uXdGj3h046UjFPQmQk18fEx7u2AGBIAYgd2JeG+6uroFBNVReUtWnJKe9gjMJB4xTCcDeHnwYZ/D6qYCUB4BEkT/jbUhNneLowJ0JwEi1UXtfLZDD7yMuDxBq4frSSsHUcDWCeM7Fyy4v9+LbfFMqvn0PBO8B8E6FxtDTIUD66vYkAJMUOB+iUAUKSr3NAvxNRf6aSsb/tnn9Dc1syYioI2ukSBzfdECN29t7THhtw0TfmKwQVauXXJ25lntXwzhNtF9gVN6jwLsBTBzAV8dsCE6H4nRAIQKgLat93IrqJwH8Ta356y7sX+/68nc3GhkVrKyZ4dIlG0iv2sW0JwCLzrp9tI/2MaxFHeqU5XMbuTIfOQat57/X3RdGkSaWYnRIGD7cCJxfIqSCKWHaHc74iedcudYp5V5Olo/3qcWHtyfxQYEdFfDZmFMVuBKqV8bjSS0o9dZD5Kdxia+qXnPDjnT+oullN88StZ+FYLYohgTkeW87MivowfpK7xfIwAguf7Y3SRL4rADnqiIvKPetih1GsMYKVjWs8TawB+u+wjJvmrXyKRGdBWAygGEBubRDAOqg8qP6icWP4uH5aZs5EIYDvox1+wTgpMEpJlRPkjzn0tXm3VU9xcbxMSP6YdXkXFExAX7VyhLgHADniLFerg7ZJyuqH4WanzY1Nv45nYnXKfdtzjmYbPuMQD8CwTRk6oDYnr8N71Y1q2PGfm/Hgpn9stR8wn0vTfIRd+qgnt6cAAxkIAFos9qLubV1F81kKsmwREkiG4cume92nVU0siAj1EaJFDt/LoGg2u0b8AzCtYXG1pq/X/9K0GvNjHk3z7W+vQxJzFdgpLO1HzgbqmenNPm/BaXer8TK9+rWLf0b+vZgS36pd5uo/RIACVQTcfhaigF8pLDU+4Ng0Pzaymv3p+vH58/1/kUE90AxPFAt4+El58WqOE8USwrmer818djVtU/ctJk92bEVzrl1oprUXaq4SESDmtovgehHCho3rM6a432sap33apqahyLH+3dtH2yc3t83pnKqhml7D7XPBP0aT1q+cURWrO0SVXOZQssEEHWxEATDFbgMYi/LnZi3XVdW3219XbF78cw+fegbt7x++qFk669EMDOANz1NRM+yKv8+7u6aRTsXFf0o078x5ceKXKsdMb93CcD0Z3mtcP+/rnquVBuDEJlMikHrRRdDB+U43rnrdhZmpFqpGc7fgXV7BmD+PBQhOLNR0vDOimcDG+vZ3vDCUu/fC8q8KmttBQSL4G7yr6M4gI+q0b8Ulnr/yC/1PoRerloumLvsegGuA4I9F1KB91k59HC6rjN/3s3vEsGPEfxN+wWCi6zvv1BYuuxC9mPHKM+5yy6GSb0I4INBr8tHlLcLHgG8Po/TxizfMB5Qp9s2Bba/emnBPsfvYVaYnikbk8D272Pvrnp77srqu7NMeyNUVgh0niPPfXdMFMWymJHN41bWfHfCvS+e3JsfMurB+uFiUn9GIJN/Rxksog/k3V2b8f5NVFybKa3JlNb15i+mPQFoQzCIzMzAlEuAoyJZeg78kyeFoHPnDMBoNVLuzzzr7Wa4QWEUZ4ZqgKDBGyBMK/MmF5R6d0oc2xX4NkJ+aJkCswT4ZUGpt65w7s3v7MnfnVHqTYDoTQ7d7AUFpd5H0jEOEGu/CyDhUFEPVegvC8u897AzO1pBmXeRiP5M39iU3xGCdxWWyqf6+mPiceP88l+B67P7AYiEqX+32mpfDFb7r5K7svqDuSuqK4yYZ6FYCGBwiJu2bFH9nO/H63NXVH8594Hne7Q1R+JQ8ouAM3tOGxX7XazSjO5Trsa5BODLuz5fcqBXAU1/+8YTgDvXKJ4AHBX+zNPQ/o53hOJe4imzlSUaGQJBoeuPn4wYVe90VxGyGQIQDUwCcPocL7+g1LsvpmgA8B8AhkbsGZ+tYp8sKPO+d9r5X+/WQMGKXAIg27FEwWV9/Rn5c25+O95yIrNDEqp4aPpcbxy7tMOmlXmTofghMnfoYUZZaJ/rM3wbhnGZ0x/3Jix/ajAQ+JlWPVHX28RD2nlqcldU/1vuyprnofgVgNKINXPZAL6kbVk1eSs3fKAHveUnHLvPqXl7a+Zl9pVVnUoA9uXDSCY2euQJwB0HdUwARoI9eQpa3xOaj+92cJvhfkLRGSSdDPcTIpsbfn+123stKOaEqk2UgT8BuGSON6qg1PumMagC8Bm4Nasr3QwUVx1saXlmetnNJ042q77TvUeo74k7E7OnOlzGo8TgVvZqh8dHMYt74fDSfkHfJ1WoiPMrs0TV6QSgxgafCUeT0MeomM8F4TJyV1Z/MHdizXMAfgzgVESYAJNU5dfjVlR/Z8p9m4+7B9WE5bVj4M7sv7e8kmS8jJ3KYfX2AJDDL4NpNKXcywFwCt85OpZQijEIexGPHINDF384TD3J1oarC7hxZVSyAjYUH26cXiJUOOfWiUColgDv2lThDdgs4pISLyu/dNn/azeoB/CfALL4pL8xUCg0aivyS73jn1Tl4PJoBfr+xVXF6b2iRPGpyWVfPinq9bywbNnnIHi347cRS8ND4Xz/rmLcTgBCLg7VmAd4eiB//4TlG96Rt3LDmiMz/iKd+OvY/Avw+UOp1r/l3tVwzJngSU7W6mTUg/XDAYx36jm0JhgJwGwfhWnprMLG5/5/YabDT0LrJz4JGBOim0I9SzZCbwwmBIc3uX4CsEl9BOHZpBoK/G2gfndBqffR9pGoEugdAEbxCe9SjgA/zS9d9v+O+UQJnJs5JIqX+1x3VZ93vWxztO1jUa7c0+d4+ar61RDcygtpSAk437/71jrdv6viw2F6vuK+Dkj/PvH+6tF5Kzbc5Rv5u6qUsRs/pjmIJ9flrqjpcpafETe3BVDotkz97KxWW+TaO7gJygxA5QnAXUsxARhaQ4fj4CcuhY2HK++tIkwARkoITgAGal2+fgt8JEw1yqj8tb9/59TZt+UWlnqPAvg5gHw+191IDUC/kV/mfa5TLOfeOhnAEOfagTR8CKhfixcAbHe8bC+KbrX2jDG4x8X62+kBhazsy98/fDCAun0qnWLf7sUzd7h6+WNXVp0BYFqIHrBXGncUP9ffvzRvxYb3p9rxgkI+C0426o5pgK4ev3JDp5WZYtycARjXWAY/BLiXFPXjNhgJQKucUtpVz2VTXEkZSoOHoeWTnwKyQrillMWLLOAIZQHCsETId3eT8PzZ3iQBzglVpTLarwnA/FJvfjyerFLgYj7RPXv8RfHtwrJlRyWgY+o72SaYtHwI8CyAh91+88R7jmzLEzkFpbgGIWhPFXiqrlL7VA9NW5Zzs1q6eKidnv0nKv8Wskfsb/Ck3za3H3nfsyPzVlTfr5DfApjALrtHJluV33Q8IVhVXOzfk43YvzFj7a11bcWD7Nl1eUlTH96V0ngpRpkA7BIPAQmdYSPQctmngezscN6fYQIwYpyfvZ3j8imBMfwnwrRBOLClrsLb1B+/aEq5N7JgrrdcgIcAjOaj3LsWX1XvLzj7luK3/Bs32wQraUkW6OH65LIhWUmcF7WKfKQO3xyCW2lVxeVHktG95sP9lVnq8P6+ox6sHy4wC0P2mP2lv35R7t0b3pOdGvSCpuF09wh7G9qzOswkdrF/1wYsPjNzSyrFtYkQ2qd2Mb2blnEGYOeQWCb/QlemI8fg0Kc+A2SFdk95bY8dqmJJR8OUcm+kAnmO30Zz1TrvVRcvPH+2N1wMFoSrBcGf+uPXTC/z3pdIYgMEi/gk99kwxPwflZR4WYffheHotgCxtHwIaKj01gPY4vRjKNFaBlxe7sUR8+8HMCgEbei1G9d6L/V5TCvW+e09jHX3BOCs1uRnAR0ZqgctFst4AnDSHS8PGrei+jsQ+ROgJ7N77nN78vHclTVXvB5buHhgq5oMb/Pj3CS2PrWLaUwAegZAIZ+yjvXJZwzCVJxjJ+DgpeHb86+Dl/dcfsYelnY0xJMh+HCj7s7+M3H8OxQjQtVOCjK+/LegbNkXjOK3cOzUtoA7o/0kLDnyTLk4c2hf3bobG9PWqghWOd4ufgghOljoRLYlcT2Ad4agP/tr/Vrv22n5UW4u9evQn7h5AvCU+zbnqMrVIXvMNjdfUZjR2f1j7qmZkBy2f7UAn49S+5X5B0nvHLuyKr9t6L4ZSPcEsP65gczNBF7+VAKQ6S5FQ0SDkQAsOhuTAQzmE9aB5QEgYeFPn4GD//bxcJ322/Xb1jMs7egQ5QnAA2VamTdZgevC1uvBZD2WsUFVuZeTX+rdD9VvufkSG/jkw3WFpTfPgziYABTUAND0dYXOLwOeWDDXOz0K1bZgrvd2AW4IQV+21ze4Il31WEKwvYev6mT/fijVehOAiSF71P6cyR8+dmXVGTGLJwE5i51x2g0xan4giJW4OTTN3EzgCRg2HYBTy/rUmmAkAG2MJwB3iScAu/8+Jgaps0rR+oEPRON+YZ9kqUeofofgBGCIODlDIAZ8D8DQkFWpfzSsuX5XJn5w4ZxbJ8aTWCPcDyiTjMI+AGCcc82ATe9J4A1rvGegqHe7NMO/DLikxMuC4H7XBnDH8LlNFd7WtPwk77E43D8NvX13Y9Mm1y46d3n1qQD+J2zPmor+PlM/e9yKmkuNmrVc8ptRpWL0Vie7Moll7D0/FXPv0DNrbTD2ALTg/n9dxiV1iEFwWSyO1gs/hLazZ0fmllXMP1jwESI8AXgg5M/1LoUijF8VfpaReM25+Qw1qXUCnMmHNuOmuNmWSfpnChnnlwGHPgHYNhIegNNCcCu/qK/wfpyuHzY2L3cqgGzH628DvHNTLl1yyaqqLBhdCSARskdtf9a+YX9Mfxmr5K2o9gT6QwCRPLm8n58pJ/v39pzMbQUg7m2V0L6rqXlz315t0hY8ngDc1VMG5SEgzho8DIc+/imk8qdF6a5tclDsKRZ+hAo8BEuEbMytJUKFc29+pwiWh7E+ieCRdP/M/DnLLhBjKwFwZgAdp/Kl/0NAzDeuLwN+55RyLy+sRV5QdvNsAb4YglvZEUtmpfW0WGOM8327GMe291CVV/aaFSFdwvqbbdecnN5ZLd5j8dyVtT9RYCk7MDqOxlcvLdiXscdWnDv0rL6vH0bSt3+OcAZgFx0BY+DoKMKeko+WK66EHX1S1G5+QyYbWQqWkhIvSwDXM9wtmyqwzZWLzZ97y3QV+1uEc8/cf9RVeGldrlVYuuxCMfoownCyJ2X2lSuV/hkCNeuWvAhgg8NhMfEU3h/G8p5S7uVA7T0AXD+VTQVYUPP3619J65uswPntPVRR69L15q2sWaoh3aJCFT9P6w9c/lQib2LeQ4D+K3svOkFrltEPAa7tlSpp+NiZzg20uQdgx8bS8gRg58TiaH/Xe3Do4g+F/7CPrlvBdawE0dE2CvkA4m43tKgFPCemWueX3lwC8f8KYGw4Oz35YTp/XMHcZR9Q6C/AZUF0Ysms/f7GzAx8xellwBLSZcCJJL4MoMT1+xDFXXWV3u/S3zWq8+MyzfDAP52NRN6Kak9x5BT18HlteGv8N+n6YSWrqrJyZegqBT7Krou68Xxlth1QcepjiabhROS0ZDhK5nijQjug6VOnzgSgU0aMwsFPfQbJ00+NcCOLx1gRItRG+aE4AdiJ/f9mzPXOE9gKAU4JaXVKaizx03T9sPy53r9A9BdwfQ8r6i8bq6q89kz84JiYnzoem/OnlHuhSqLPmHdzKYCrw1BvE1m4NkM/2/mVWTHjQP/uPRbPXVnz/SPLWCWU74rQnzZcXdCWlr79zvrs3fvMwxD9MLst6lb9y+AJwGOWbxgP6Einhupq+jwzOi0JwFTccPZfVwWUbGcQXGBiSM0uQ8unPwMdPjzSofCNPM4KEalOdUYI7iLQA4T8C+/MLij1braCPwAYGda6pIrfpuv034KyZf8mgp8gfJuoU+bqX8bagdrKm2oBPO9weIbEUigPS1mfdv7Xh1hrf4D0rmIaCCkFLq1a7R3I0M93PQGoSQR7CXDu8upTcyfmrQWwKNTtq9X70/FzJt3x8qD9g1K/huJD7LWoB/17xtqBeNw4107G0jADMC1Lv3yrRcL62Yn12xiEoDcqYyfg4EUXAcOGMhhAze4rixoZhig9AChy/Xu1BngGYGGZV6b7Xl0OYGbYq5IY3JOOn5M/7+Z34fDgPs4HlLpfAZHhPYLkIYWe7mx4Di8D/kMYivpQS8s3AOSH4Fa+3FDpPZmJHzxuxYu5AJzexFqB7buvLNofxGubsPypwdYM+aIC1wHICnnr+lLz4pL1fS9QleTKmpUA3ssOi3oi5ccy1r9bC9dyWJpqt31OiKblBVvAE4C7rlWcARhYWTloKz8PqSJW3bc8x1z+G7UmSlDs+scbtcE7AbiwzCtTi2s1pHtvdWFjfQX6vIdVwdm3FIv1f6HhH1BRmhlIZmcKiT4ExW1wdImfAB8E8O+ul3Nhmfce1VDMtno2aw9uzdzzEC92/RhCQfBOAB773aqhJhG70he9FsD4KLStKvhOOn5O7j21XwbwCfZW1LMKiH2vfLawEVdlbOzrWCJAtu36fEmfZ43H01Q4ReAUwE5BoSCOEmLwi9+G1nPPjeYhH8dhVf7KKESKCJw/JdCXEaPqg3AhM0q9Car4uAKfVMU7otQnishdwNI+HcRSWO6N0aT/K3V81goNWAeW0WRBXYW3Kb/Ue1qAMx2N0OSiOTefeuRUYydNm/WVEaqt98D9fdbarOKyTO1ZCQBWMEPcH4YEY3a/pyZvYs05KvgEVC5xbb+wPvbueySr7cG+/pTclTVXQPVaEPW4CmoNJIOtmXM5rPTsh5ieBKDwBOBOxcMTgIM2QoWdMBltF7wPdugQxqOzdhuTPzEM0ZE/25sIYJjjt7G54fdXD8heCxNmeYOHZskcjem5ApxrFWdDEMWvCgdakXVvX37AlHIvR5P4FcKxrI8GQKo9J+N7hQnwENxNAMIa+0EAziYATU7rnQAmh+B99NqNlUtfymxd1WLX86SiOmAJwLy7qqcghnIIzlXUvEeBCYfndURrcoeI3tt02ektfYrl3dXvUtW72EtR79qyDO/zLc7tlZqWj519TgDmX3hnNva9OoVVtEN9YgIwME2Hjp+E1veeDztyBMNxbE8Eda8VytBgKoEidf1dNoMb/0+ac8egnHjrUKB9LHxMgsjJojoFgplQnArBNIXGoNGe7y3Aiq0V173Wlx+RSOIeAHP4VFIvNW56+kt7M/1LbCz+kPFTX4OjmRUFLgJwu4vXnl+27IOiepnzNVXx1/rKpXdmvF1WKXK+X4qZjM3qnfy9F07yE4OG+GInWGtPFtGTBSi0kBIB3qbAKDaraI9p/Jt9+QHjV9QVW/i/ALf1oN42mRnc5zv3geeHoA0nu9WFSDBmAMb37Cn0DWKsoh0KyCYZhAEdlRrY3AloP+/d8MeMZjxO3ML+hkGIWpnD/Q0wBWcUlHp/7tuPQAzAcAVyFBhqDv/v4cC+GOybfwjQN4f93PLidW2w8W/05QcUzPX+B9wXiPrUlPXPUsGNT9z4cmGZt04Vcx0N1eyps2/L3bz+hmaXLrqw3BuDpN7tfEJLsNcXXIF++Gak7p8ADLV6W+6K6pY+/pjBALIPL9uVoQCGABh6eNlA6nC3LocLR9m1d6ywP9y+sGBbb/927gPPD7Ft/iPgth7Ut3YgY/177FBihm/ceuyNQTASgKmYFgm3u+siMDwBeEC6KxOHf8pUtJ57LnQoT/btLmv83zIKEStzIAynt0888k9fBkpvGZ9x99YexU7wQP26G7f39u/nz/PeAYtbGEnqo347LEAtHoI4mwA08VjyQgA/cOqqk/iuAnnOt5cqn99UuXRrpn+Pi7NajiGNs8KZ2ush31f9Wp9+Qlv2t8BDQqmP4pq5E4D9mBS59tKfStmA7AGoyv3/uhhS2hRPAO5X2YPhzyxB+5y5sHFOSO2hl3YtKGlgGCKHbTf1RatF70+xPO38rw851NLyY3BpEPWR6cfDApJZWJVI4g7A0ZUvgovgUAKwcK73cQXmh6Ca/qKhcumP+uMXHZnVwlPuqC8NxQ92Lyqq6+3fHrei+qOALmAcqa9dbiP2b8xYLVcpUqcygLJn9+LiHWl6b+rru4Tzp0hmiGUIMv7Wb2DzJqHtAx9Gy+LPonXePCb/ekPlIQYhgq93IVgiRAPqO5sqvF7PZjl0oOVO8P2B0tOY9VsCcMtqrwmKCoejdUH+hXdmu3Ch+fNuH6uC/wtBDd0RS2Yt7K9f5seEfTv1RWssllzW2788cUX9JAHuZhgpDTZi8ZkZ21NNnZuhmr7l0Ok4BZizSDoWj+Uisky+6WPYcKSKStA2axaQlWBI+shaywRgxOTP9oYDmMBIUC/tiSWzvtLbv1wwd9nHIHoFw0hp6cOS6NfTQhXykEDf5Wi4hsq+184B8OegX6jY9u8DGOf6kAAqC2v+fv0r/RY352a1UKCeO8V3Gq849eVe/WVPTQo19wPg5uuUDpne3sOpBGA6D0TpawJQABSwfnYsoRRjkNbeSIBBQ+GfPBntZ50FexL3k02jp3d9dmY9wxCxRyphiqGcpUy9bpO93g5o82d7kyC6kkGkNNnfsN7b3q+/MZb4GWz7nUjPR/SBeEn9IAKeACyYu+xyQD/qfluJ79dXLu3XPZaV+65R7zW3Jlpv6+1fzp1Ucy0U5zGMlCa1GfvJnhqgxqkclrEBmQE4de6tk4EUT1roiCcAp6GWx4CRo5CaOg3J098OO3QIY5KRd1Mu/41kuasWcX4A9VLV8EN53+v1347h2wBGMoxv2CNAqwIHAeyDYggE2QIMU2AYnE0y9Q89PEDo1+asYc31uwpKvccAvNfRmH0IwNVBvb7CObdOhKS+EYI+alNWHF8cgN/LBCD17t1QcO2ey8/Y05u/O+bu6kIoljCKb2gDcBCCvapok8P//9Aj/wzC4f6djl8fMza7f9z4hqkAcpzqu8UEIwEYU7+IByt1gQeA9OYxBwYPgc2dgGTRDKSmTwcM9zDOdE1NWfsgwxDJYTMHCNSriqPGfP7ppxf36itX4Tzvw2rx4YjGbjsE66BYr0CdKjYNGTpk8wt/+p+WY/2FWbOWJ/Zm75wsYqepaIGxOFsFZQCmsioeZrT/TgA+6kE4vAzYyQSgAKfkl95c0lC5pCqQl2dSKxVwfalHSoFPVq32DvTrb12lMeyt4cos6o3KpiuLHkBvju5QldjKmrvgWEIlTZKAPgvIk6J4VoxuEuNvbtz6tu3w5JhLbUbe9+zIwe3Z06wx0wCcpqplEJwFgDNe3uzhM9a/i6Sc28IuZoKyBNjwBOCu2CQTgCeuOzFgyFDY3PFITZkGv7CAB3j0/xDmt7sXz9zBOESwjVIUCT/eUM8tb1iz5PHe/MXTzv/6kEMHW74doVilAKxWwS98G//t5rU3/rOnP+BIonXjkX/+DOB7wOFl1BLDRyH4NwCzgQh/ipX+3f/vde2S9Ui2tn0Prp5iLfaDAAKXAMyfu+yzCn2f+69X+ErDWu/J/v61Y/dtmAqYHBD1TJuoXQyRXk28Hbey9pNApJb+7hDoo6p4JHFgWOW2a04+1NMfsOfyM/bsAZ7B4X9+BgDwHovnTcwrA/RfFfIvAMZEuVK255iM9e9qUCRuTTNPNqYObErXD+tTApAnAB/vvZ/erGVZwKBBsKNGwx8/Af60afDHjGFcBvwFVbgPV1THzMIlQtTT8Sz+GcOgXi9na21p+SKASREIVQ1Uvpel+qOqdd6rmfgFDeu9bQDuBHDn9DlevonhGiguRwRnXygGJgG4teK61wpKvb8AeL+jgbsIwFeCdEkzzrllqvX9r4agWj6btRe3DMQvNtZwZRb14p1QlzQtLOnVB4HcB54fgjb9SgTC1A7BIwZ6145txRXHm93Xa965qSZgNYDVWP7U1Xky9CMQ/ZICZ0SwWja+emnBvozVeZUZcOmwJEV9Ok9EjvfxYorZ0XQISVQ31o/FgETO4WW8w4bCjhoDO348kpNPBrKyWDGCN2jatnNk0e8ZieiZNWt5Yh92TGckqAesESyorbh2f2/+cv5sb5IC/x3yGP1FBF+tq/D+in58q9y4zmsA8Lkp5d7N8SRuEOAqAJGZTq9mYBKAhwfNeEjVzQSgAGcXlntj6lZ7u4NxRZ6xKf8+iPP7YrXFrPl0VdWS9gF6Hlyb1UID78mm4cXf6HVb0pb1PwpMDPGAaZ8A3/IT9q5dl5c09dvvXXxmsglYBdWH81bUvU9h/xeCmdGplpLR7T1EbJGqO0msdO+H2LcEIGeRdDFM8kPy3BmIGGgsDsRj0EQWkMiCZudAhw6BDh0KO+Ik2JHD4efmMsnn3tv/CswXn4GInn2JnfkAEowE9SBZ8LW6Cu8vfXjTuA3A4JCG5x8iuL5P8UmDLau9JgD/UTj35gdU7HJEY8ZAKvtVNAzY614Sj0ocrXBz5mUMKbwfwANBuJjCufhPFbzL/cZSrq1Zt+TFAfv1KkVOzWqhga6wewB8orfjgTH31ExQq/8T0uC0iuB7xpovNy6eMXAfSkS0Cfh9yaqqv+7eE/siRG9ABGb7KzSjH/dUpcixeKQ1IdrrBOCUcm8kkshl49nhObWp4w+jcgbB5ubBjhwNO2wodNjAHKKsg4dABLDxBOygQQAAM2QwLA/eiIJWSSa+zzBEtI2K2yLl+IC6XWHw92GHxvf6ZL/80ptLBPaT4QsLXrOC/26o8O5DgEbcdWuX/KO83DtrewrfgAb3pNc02VhV5Q3YpssN6719haXeHxW42NER1kUIQAKwcI5XpIJbQ1Af19RX6ADvc8oDvqgn1cVe1bxo5ube/nWjuAHh/Lj3F0AWNS0o2hyUC6qaX9IO4NZxK2p+JdBHEfLDwEwG9/fNu7d+rPopp/YiU0FtOn9erxOAsTbMBHNFXbSlXbyLioGddAraysthTwruwWaWxReVEf2Pmq/K38k4RLWR4sxt6radPnBJb0/9BQCBXYaQLUlVxaPxWOJzdWtuCOQhSqtXeykAXyiYu+w5iN4FIDuUPRkGbvnvmy/l8hBUnUwAKnBBSYmXNZBJ1PJyL749iR8AGOR4ZdzrA5cC3kC/SrN/p+5W2m81Lyr+aW//dt5d1VNUdUHIYrIHgv9qvnLGfb09ECXjL2ULi16YeH/1O1PtWIUQH7yiNnMzAH2/vcg4lsSKSXpPRO713UuMnUxXOp4ArCPH4ODlC3DoIx8JdPKPIkNF/W8yDBFuozhDgLonqcbM31Thbe3tD8ifc/MZAD4apphA8YWGtd5HqgOa/Hur+rVL71ORSwAkQ1lDdeATgC2H9JcAWhyN4PDkcJk3kBewvV2uxeGTrB0frOLf+9JWpkPuXQ3jAIxm10Xd8Ofm7Tv6tHRX43IjXD0FvWsvqI2d2byg6N6gJv/eaDc/XfzKsEPx9wvwh7BW0LgkMta/GzWujYO0LTtWl9YY9PYvCmeRdPk2irfMAEy97QwcvOwy6NChDA0Fo4aK/qFpUe9O+qJw4AnA1M3GYnHDmiWP9+0Nw14LhOOoMAGaBObd9Wu9O1267oaKpb9WxScApEL4xjXgCcDGp72DAvzO2RgavWigfnd+6c0lEL3R+XqoeLRhrffgQF+HjbfNYMdF3Wg3a9virfPhndvrPmH0XbUTAf1UiMLyE2S3z925uGCjM3371QVt8f1DPwrgbyGspvu3L8jfnsFx0AzHntnt6T4RuS/zHzmI7FRA+sZQIXXGO9F23rkMCgVrEOvrMkYh8jhIoBO9bCytX7v0vj5VsnNumSrAx0ISki2+xby6yiVrXLz4hrXez0TkS6GrqMZUB+J5UXnI4Sh+aCB+aXm5Fzew98P9zex3KrA4EI8DTDF7LzqBRoFcuOfyM/b05YckYvY/EZ7Zf3c2Lyj6ZPNlpzs3k3vbNScfsu32YkV694cLgJpMzsJUiFNtZSa2OzF9iB4TgB0LyD+89YdfWIy2efMYEArWoF70982LS9YzEtFVOOfWiVCMYCToOG8adzVUejf39cf4vv9f6MM+wwHyUtwk5m5c5zW4fBN1FUvvgOI3YaqqybgNxKAnmaW/BbDP0TBOKzj7ln4fDG1vx1IFZrn+WgWVKzau9XYG5Go4LqPj2WvVfqB5Yd8Otjhp+cYRCiwKyfvO9c0Li78Q9CW/x7Pr8yUH4lY/AaA1NK+hKhme3e/cVkhp/9jZqwRgSYmXBQn36TO9q08pYPAwtJ5/PmNBwWtQOfuPdUBSnP1Hxxk/4oH6Cvx7nzMKs74yQoBPhyAkNZLAuS7s99ed4o2lsj4DICwHQO3YstrbE4QL2bLaawUcTq4a/4P9+evy53nvgODaENTB5fVrl/42MA+44f6+dMzOfZ8q3r9rUclzff1RWZL8DATDnX8fVv1S84LiL4eheBsXz3wGoteHprpK5g4AmXLf5hwApzhVV6Fp/9jZqwRg6wgUIhxf9tNbYW0KrRd+ADA8HpkC5zec/UdqhEuE6FgDhHsbKnF5Ok6xjOe0fgqA65vf7oj5uLButbc7LEVc8/frXxHBTeGorqgO2PW4uwxY0G/7AOZfeGe2WDwAIOF4FdxkMOiLwSpG9u/Upb0QvWDnouK16aloutD1gAj0+02LZn41TIXcvK352wBeCkX/rpqx/v1gqq0QQMyt9x0TjBmABsJZJF2ww4fCnziBgaCg8UXtlxgGssoZAtSl79evxcJ0JP8Ov6zgs47Ho0Wt+UDNk96WsBV03fiZ9wB43vkBnARrz6PsPfgDgFcdDefcorNu75/TY/e+ehuAEte7UoH5TG3ltfuDckGT7nh5EBST2ZVRB7tFzXubF858Mh0/LO+emnOdf35VHm3aXvz50JW0d27KivxPGG4lJvEMngDs3lYJvgnKHoBG+ZWpC+0zSxgECmBfJ8t58i8BgPDwJurUPGBZfaV3VbqSf9PneHPdHyDg3xvWLXk2lCX+8HwfKrc4fx9WAjUDsKrKawfwK1fHW6lE8n2Z/iXT53hzRfCfIehIvxy0A4Hahu6bgb4d7EjhszlmpKxp0Yx/pK1rtLrA8Veeje2a+Aw8sWEs8F0Liv4A4EnHbyM5akQyY6cxW9e2SlDs233FjLRvQ2N6eTEcRHYRlGQRJ0ZS4OyHJm9mGOjIwIVtN72uHSpX1lV4XlpfKmK41PFn5Kf1a70fhLng6ycWP6rAPx0vp5qgXZIVd5cBi2hGlwFPmOUNNoIfwLGlV114Nus1BO6dykDYt9NbPWXjdm7jlUVpmymd+8DzQwBc7HBMkgAufW3x9L0hf8//tuN3sLFqfkl7xsLjWg7LoDoTh9SY3tUtDiI70pxsICvBQFCw6qXC27nw1GZGgmaUfnUYFBMZCQLQaC3OrV+79L50/tCSEi8LikscjsuWrDgWhr70H57vG+Bul2/BxmKBSwCeHMdfAOxyNKQXzpq1PGMvsUOz8XUIChx/ctpi1nz6yGzPYI35hQlAeuPN/8GYbXnXrstLmtL6U9sSHwMwxNWoiOpN6VoKHWRjhtufAWhyt/pm9gRg13JYqpn52Gl69QwBnOrWsYCGDWMQKGCVEs/vbGy6k4Ggw51IW9Hhvo8i7olkArM2rvPWpvsHt50kFwAY4+57p1xdtdo7EIVK4FuscvjyD2x84sZtQbuo1au9lAoedfR9YcSenKayTPzoGXO981RwlfuvVPhSzbolLwbz2pgAJLSpylXNC2d+qnHxmQfTnzCQTzgcm5ea9OAdUagEVfNL2gX6C2dvIIMnAENVFCh0KhwISAJwWpl3Mtw/3S/tUiOHMwgUqPGdEVwJ79wUQ0GAg/teUNq7KREsq58w87wtq72MfB0W1Y85+84J/LKhYumvo1IZNq7zGiDBOkm32+/wh1+INYjXZnzhMuC3yJ/tDbeC++D+x6c1DZUI8AdV7s0ebVptxc7Zuajo+5n46SPve3akAue5GhwxcjUWn5mMUIX4jbv9UOa29xh/T/VkODaLVTOUEO1xAtBYLv/tij92LINAQRrMfmvHwuKnGQl6sxdhAjCyRQ/UQUxZXYXn4eH5fiZ+R3m5FwdwkaMhSkJwTQQrxm9dvGyD4O3/97q6dfoYgB0uxlU0/ft7SQLfAhw/nVawN6XxT6XroKS089QAzi+vpt6xAO5M7B82a9eCkowdXJWVGnQRAEf3udKHm64seixKlSInPuhvAA46WVq+zVj/7lv3ZkrH/VgwEoDc/69rqYm5DAIFpfmsju8fehPjQGy7Iy8piq+mEji9vmLJ+kz+opeTMg/AaEefjQfqKrxNkespFOvdvG6pCe7VeVaBRxytEtNnlN6Sti1+Csq8i6C43PnnBPIfm9feGNhDc3In108BMIjdXeS8pAZlzQuLv7DtmpMPZfIXGehHHI2RhZVbo1Yxtlw+tRXA8y5eeztyMta/izg3UzrZiP0ZORE53otWoCiYCy8GdvSgQwYzDhSQAX/s05l+GSAnMQEYIQr8DTBX169dUtUv3aDqBxxd5JeE4PYo1hEbjz0f830XL70myBdnYB5S2M872W6IvQhAn08OnVLujUQKdznfjioebahc+sNAD0H8VJFye98o2Q/g9mbb8g0s7IdlrcufSijwXkef4J81L575YiRrieIFCOY4dtWNmTylWYAZbqWwtCFTS9d7nAAURRHzfx0kePovBeRFUPWmpkUz/sFI0FuVl3vx7UnkMxKReOmrVyM3NFQsfbhf2x7BexyN2MNRnP0HAJue8DcWlKIFzu2JI4FOANZV2sqCUmwH3Dt1XVUvAvCNPr8Wp3AXFJMcf0R2KrA46BdpIcVM/0WCFZUf+Qn/i+k+4fd4xmLYbMA6edJlzOKrkX0VFHle3JuxldG+3b3DkjL3rtObU4C50WzHFnkwZ/9RIBqKvzY1Fn+dcaCOdiRj0wFkMRKhtlmAhcPbxpf0d/Jv+lxvHIDT3HxJxoroVhnPAtjm2EWnMHxkgwNxfdjRSjGv6Kzb+7SUv3Ce92EoPh6CEfQVG9d6OwP/5ieYAQr1MBOQh0TtaU2Lii7rz+QfAMSMdfXj3lONi2c+E9VKY8Ruda7JRcYPJityLCAZSwD2aAbglHJvpCaRx7b4aP6IYQwCDfQr4MsSi/0bPLGMBXVqo9QWCacIhFWtQr4+ojXvgaefXjwgp9zFgPPUzVM+GxoqvMcjXn92Ae4kEBTY1PD7q9scuM6HBPhPB+tDzM9Kng/gJ735y/nzbh+rtn15CJ6L5fVrlzpxSI6qFAn3ZgqjJKAPSUy/3HRFyYaBG17ou6Hude8qWBnlyqO+7oZxq9xMBk8AHnnfsyORciuHlakTgIEeJgDjSe4h1RU7ehSDQAOpTVQ+1nRFwS6GgrruVbWY44OQvdwBlRD5v4bxxY9k6mTfbveBglIn88sqPzgcykhzqt+QgO//97qGSm99Qam3BcAU954LvQi9TACKbb8LwDjHn4lNBoP+x51nQrkyK1z2Arg/Fkv9b+MVp748kBeSf2d99n5NvdPFcVEqJ/6TKFciRdZuQcqta7aZS3hl2Rzn2kmjsYzNiOxRAlAURdxntrPkeJ4ATAP59iefa1rIff/ouG03lwiFww4IHo75ZmXNuiVB2tj6bBeDGVP5VeTbBqBF3brgGkeuVCFYBcUXHawTF5aXe/HVq70ejR4Ly7zLVPExxx8JC8XltWuv3e/CxU68v3p0qh1j2DU6zwJYB+CBmG15sHHxmQeDcFH7ByXPACTbwTbssVcvLdgX5QqlWe0tkjJOXXNcEpnb885KkTr2vbd9sKnNWKx7+EDxAJCuWu3RIxkEGqghxpebFxbdy0DQCXD2trteheJRa/DwxvEz/zzQs/06mjTnjkGCfac7GNetAUuiDtSoMyFuXXC1K5eqgofEwQSgAidt800pgG4vj59R6k1Qxbfcf6XCVxrWek84M0BsNcXGcOcXhz0log8bX3/auLgkeHu2Cea4OUdefxP1ipVQm/DhVAJw//YF+duxMGP98QzH6vL2TCax4z1sCDiI7CgWA4xhHGggPNzcWHQjw0DdwLbbLQ0K/AFWfjOiPe9vA7W3X3dkY98ZABLORVjwW1YzQBwrO3VnBiAa1njPFMz16iEocK5eWHsRup8AFB9YKcBJjj8Oz2bvwTKXLtjE/CIX92eLsFYonoDRP0DNo80LizYHvMF1cfkvFOZ3Ua9oqWROlhinlgDXQCRzKTq1RW5tVS0ZfdfpUQLQAjxqvmN9GpzDINAAdG54YnA85zIe+kEnUjzvtvEpmxzJSATaywCeAGSNqvlLw9qbNjozADVunv4LoILVDoAg26Wv4qmEOwnAww8IVkFxg4M14yIA3doHr6B02SJAL3T8SWiLWfPpqqol7U49vipcmRVs7QD+AZEKsfK40f2PB2V5bzed6mDMtwc+sdofXY+056hDMwBFM5vwEkixU22lakZXO3Q7AVhS4mW1A9PYlh/NHzqUQaD+bROAZ9rjrRfvvLy4ldGgE7592lQR5ygH6CUHaALwnAWegeJZa/D3TRXeVmfvR3GqixNQYsBTrI0AFBNdena2rPb2OFXPfPOQb6yLCcCiaefcUrDpiZvqj/uHzvam+NCvu/8YyHUubgmg3Js9UK9bAGpU8IyoPGutPJPdMvjpbdecfMjFm8m/sz57P1Lu7R+twj3RAViRCeJUsWXuABAsfyqhwFSn3q0NajP587udAGwbhXyxPVwyHAH+SSMZBOrPt9Tns4x9787Lz9jDYFC3OhEOEPrbThU0G8V2BZoh2AYrG1W0ul2ya7dWXPdaqJokcXIG4L6aCjSwqgIAJjl0rdWuBbdm3ZIXC0q9DQBmunbtxrcXAfjmsf+EZ/wY7gMwzPFnYE1Dpf6fmx08eAJw/2mFoAmKRgGaFNguotvUmhprbfWupubN8M5NheVm9w2xRWId3N4DeJpVFRAxJ0PdmfOmGZzxlpcYVKC+Y9udwAZjBqD4UgzhRPOObN5YBoH6qzl/Lp6t79n26ZJXGQvqdq0xWoTwNt2bVPECDHaJzcxdKrDfACkVaVFBu1gcFKNtAFot5BBU2wDsRArbsg9gZ1WV1x6xKubiCdMvAF7kt0+YUu7lIInRzrwQi2PLf98Y2MgqEfUcvPLjJgDzS3E1gHK3O0jsTdn4p4AbnWsPpty3OedQqvWUkDZPbQqsF+hWQDKyZFZFUgLsh1Ur0L0wUFXZAwCisgcGqvBfFYumuMGObQui9e5tfJ3h5vaS+hzf/AGFTnKp+GISz1j/bn1T5FpVTiXjgdkDkJvIdyE5fhyDQP3RlP89IfZCJv+oF28BYWu7W0Vxr0jsztrKm2pZwAMnf7Y3HMBY9x4JbGLpAXEfM+HSrtjWzQRgTMxPLXzPtesWYN6Ucm9kV8uu8+feMl3g3+r6MyDA1ZvX3vhPF6/9YKqtUIBYyN5XNqjRr0hW8pGdl53ewlZ6AIvCwcOLDj/TdjNLDxDVEoe69+SoEcmNOzLXzrs2Dtr/ymcLG3FVBt//uh08UW4025ERIJFgHCjT/mbb9eJtny85wFBQL4RmiZAKXoTg4/VrvA0s1gCUR8IUiLo3kc4IOEAAAF9mu7SyQ+FmArC28qbaglLveQCnO3bpiaykXADgoaP/tWdE/B8AGOJ0+6V4tL7Se8DZIYiiKEQHAFtAv9zc2OyFaRmt4z38dCe7tST+ybIDIHKWQ6t/NlbNL8nY6hlRKVK3VrFm9kRk9CABaIEibiPVoWnMymIQKLN1TPCDscPt4kw2jBRep53/9SGHWlomheR2nkQSFzSs9/axZAPyfqnWyQGCWuEAAYCInuVUhsC4mQAEAIE8pNDTHXxaLkKHBGB+Gb4IRZnj1X+nAotdvgErWhyScZkCuKp54cy72SoHqlCmO1i/du/iZAnk3tUwDpqc4lBty+hqHhV1agag9MN+x909HFIEKGRz2KHzHcYTgCmD7RWwbOeC4suZ/KPeajl4qAgIwREggm1tkv1+Jv8CZ4KT1Smmr7HoAABzHLrWA5sqvJfdbcP0ocNjaueSAO8vL/femCyQP8+bKYqlIehTrty41tvp9i04uf9qVy+7XvPCYib/gle/Jjh40ezbASCWOtuxgstswkvdaiv7Y7/jbiUA82d7EwEM5xN1NH8kQ0IZaaj2QXBx08Jij8Ggvo05NRz7/1n5bNhOzw0Do8hzsu9WtEa97ArLvGlwKIEgQC3g7nFGdRXeJnXzdMpRjSmcDQDl5V4cFvcDyHH8Hevu+grvNyHo4UOwvYc8t3Nb0+3sTQNpvIPP9iEWGwDRDzh1uRlMeI2+q3YixK0clloNRgJQ4sJj5rsaRIwZzSBQujuvDRK3c5oXFP+awaC+vwOEIgH4fP3apb9laQawuRLkOvlciIn8IMEqPuTYJVe7HnPptJeeK68l+CAANCZxkwBnOl4Mm40M+m/nH2BPDaDOr8wSxZe551/w5D7w/BA4ucenRv7jHlRFgfe7ddEmY/17PJFybhyUyROR34h4N3t/ngDcBX98LoNAaXwRkh/GtOWdTVeU8IADSlcL737brbiXBRlY/Arm7sD7IqeaAYHzJ37bWNzJZcBQXJQ/5+YzFLjO9SKA4jO1ldfud70u5eXWTAYw2PHb2N/UuOMRtsYBfHVsT4xxs2OTyJ9XOn5lzTsEcGrv7zY/nrH+XVRcGwclR41Ibsz88LA7wYMyAdg5KLDDuQcgpcUugVzStKjossbFZx5kOCiNAzfnZ2+LMY+zIANrmJtpADsiyoWWP9ubBEG5W2Umzs8A3PjEjS+LYJ2Dlz5TjH0EQMLx1/av1a/1ngjDM+wnxPlxmQBrOfsvoK+OVp0c4KpiZNTLzio+6dglN762ePrezNUJ59rKjf2x93+3EoBWOAOwU4VKJBgESoff+FZPb1pY9DOGgtLqklUxAPmO30X7hLitYmEG1hAXL9pIxAcJMbkSQMypdy6RmjCEXq2by4ABTHE89M8l9oTg8JI3Bm/W+Y97qniGXWhQK1jcyb5dEO2+Pf/O+mwILnXssmsyXCncymFp/7zrdHMGIBOAncpn8CAGgfpiu4jMb15Y/MHdi2fuYDgo3aY1104DkO34bTSsXu1xhkBwubkEzWJMZEvsklUxEb3CsatOYfjIhjCEP5mFVQB8Nh39qi1mzWVVVV57aO5I3Z8BqKI1rJpBLRzr6vLyk7BKY1Ettv2DUx8DMNatdiCzCS91LYfVT+3iCROA+bO94XDxJKAM84cPYxCodwMZ4M7koPjMpgVFDzMclLHG3ffDcHhTNUsy0OIuXrQ10f2omb+j+qMAJrs1GMXmht9f3RaG+G9Z7TVBUcGmoz/HU7i+Zt2SF8N0TxqCiRlGYkwABrWPhLq6zC1r7KvV0yJbcKpfcK59zuCJt2O/WzVUgIlOxUPQL+3iCV/eJWGKoVbYHB7NHz2KQaCePta/E/W/2LSohEsaqT8GPUVwveXup46Q+jIOdfKqZ0a1WRDVGx1sB6rD9dDIQwJ9F5uPflFRN3Hm/4XuQQ5BAjCTG/9Tn98f1dX3R4mjBEB91Mosb8WG9yvkLAd7xMydAJwTK7JWnarJ6ttgzAAU5QEgXfHHj2MQqLuP89/FyHnNC4s+wOQf9ZsQzHJSCAcIAe8KnRwgCN4GeCZqhZVftuxfAJzm4KWHqx2IJX6Gw6sBKLP2pTR+KR6eH6ol15NWVo0C4PogJKMb/1Mf+8iYcfiZkdOiWGYKN/c4jUsiYwkvX93bK7Utq71f3ne68QLMBGCXlWoMZwDSCZ+dv0Pl4uYFxWc3XVn0GONB/fw24HzbHVPlEuAgVzGBdfTZGFE4B2dGqazyL7wzW1RvcbSihaodaFhz/S4AfCfIdBoAcvXmtTf+M2z31Y5YCLb3EPbtQS4dte4mABXvjlp55a2suQROzv7D/u0L8rdnrh5jhmPxaNxz+Rl7+uMXnTABaJUHgHQSjwHGMA50LKsVen7zwpmzmxcV/QoiypBQ/w9+nG+71U+hjiUZ5EECDrh67dbgfZEqrL2vfQlw7mX4yHhOQrcVgEIeAmWy//tlXeXS+8PZ7toQzO7nASDBLiBpcfjZn3vS8o0jolJUY+6pGaaq33T08msyOUYWce6wpH5rF0+8BFiYAOw0cMjOYRCoozYADwM6p3lh8bk7F878M0NCA2Xq7NtyFTjJ8RHc9ob13j6WZqBftPc6fO0XRaWcisq8QhH9kqvX324SoUsWtEvWIwDaQZmwK5lKLA5tuxuCE4AN9/cNtJRYl5dnx7NN8r1RKauY1dvg2EEXb2nLMnsCsGOT2LQfDz48bgJw1qzlCQDT2RQezQ4bwiDQ615SxX8lxE5oXlg8v3nhzCcZEhrwF4JE0v0lQsoBggNcTtC+M3+e946wF1B5uRdPKe4F4OSXSwGatlZc91rYyuXIPf2FTUhGKs0Vm9ff0BzW29MQTMxQyxmAgX6E1O53un6pLoxCOeWtqC4H8Dl327IMtgPeY3EA+W49d/233/FxTwHel9iZDyABOoodNZJBiLbdAH5igPt3LCx+muGgAHYiYZi5zT2Cgj8QfQUOb3AgPhYDWBzmMtrWjq+IoNTZOobwfggQwUOqeD9bkrS2SSsaKrzfhPw2ne/fU36M/XuA7bRtr+aauEW3zgoIYuOK9479/oaCXZ+dGdrTgMfeV5WnKfwEQIz9e2djJuRNA5DtWESCMQNQ4pbLf7vg545lEKJnt6j8EIIPNduWCc0Li69m8o8C3Ks633aL8ATgwJeRYpvbN4BPTin38sJaPvlzl10sgmscv43QJgBtEo8CaGVLkjabYzrov8J8g/l31mcDmOr4bex/5bOFjayuAbb4zCSAnS737rGY833fsXmPxU3K/AiA0+8vJmYz1r/H4N5WCZk8EblT7MM+iMyE5PhxDEL4+QCeVMATMbObtxflNi0quqx5QfGvj3SMRAHuVUOQALQ8AdiBUtru+A0MiSdxSxhLpnDuze8U0QcBiNtVTEKbAGxY7+1TxR/YjqSFVWMur628dn+Yb3J/dqoQDs/4OaKGh+M5wekPfApZmHd3VUnoSkVVcifkLgdwnuN3kho9FA0Ze3Uwzk1iO5DJE5E7Ou4SYAstEtDRA2sBsrIYh/DxFXheRNeolTWJbKze/uniVxgWcvP9AO633dwkPPhFpPqyiuvVDJfPmOd9u3aN90JYyqWozCv01f4OwFDn2zI/3O2AAR5S4MNsTfo62MdXG9YseTz0bW5MilTdzp1leuN/StdDJdsgeqbDdxBTiX0NwAfCVCy5K2pug8gVIWizN1bNL8nYQVhqMcOxz5/9+mHkuAlAERSB32iOrlDZTP6FxCZAnxLB0wp92pfY33dfWbSfYSHXTZjlDRbgZMdvY19tpbeDpRlsvo86iTt/GzFr8cCUcu/sLas955djzii9ZYav/p8AjAlFHZNYqJMFB9rwqyE5aAHA0+V677nsPfCicKNWbZE4Pqk3oxv/U/rKCahzfxKQvj93xYYrmxfOvCcMZTJuxYabAFwXhnsRZLgdEHHqMERR6ddVTyd6dZ/BJrBD5zuY72gOPU57AN0IYBNENkF1k7Vmgz/EvPDqpQX7GB8Ko8GDUQTr6MbNb74Z1Bx+/6Qga1jvbS8o9fYBGO74rZyeSOEOOHyaHgBMn+u9zcL/I4AJIaliLZvX3rg1zM9Q49PewcJS73cKXMIWpVfajMGnq6q89ijcrDi4r1VHqtzewwVGUBOOlzD5zrgVNf/YubDoBYcfGslbUfM1Bf47RK1ZptsBp3JYKujXfc+PmQAsnHPrRNXUCDaBHQpo5HAGYWClAOwCsBuQnYA2A9it0N2QI/+/SHM8ZeobF8/YzXBR1ITiBGDlCcDOlBRQC+CdIbiTqwpKvRfqK73vu3j508u89xngp1CMCFHtqkUEPgSoykMQZQKwN/2dyA21a5a+EJX7Vbi/vUdM4pwB6ERds9WubyF7RI6BPjxuxYvn7Fx4arNrFz/pjpcHJVdW360il4ar7c7c9h7jVryYC2CUW8+bBmUGoM8DQLqQGjuGQeg+C+hTEPxJrakR4zcZNXu68Xpw0MbQBt9qdrJ9DwCYQcMObbl8Kk/LIzpxL+L+ASDgCcAODUiflzAkAA/7bmGZd7CuwnvAnUv2TGEZlqjiJsDxmb+dG4JIJAqSWfrbRBJhmEnb3yrqxhd/KzqNrYqsrCl0fRg1akRyI/f3cGAA164vmSzx4f6hM1CgUBD/88T7q891aX/3sd/fUJCMHfgZIKeFrjnzM3cCsNF4kWv7U2fyROSuxI8TvWJQ555rAk8A7s77LAQ/UD/+1Z2LCzYyHET9OWZGkfNTZgyXCDlTVMB6BRaE5XZUcW9BqTfYhZmAU+feekpcUitV8Z6QtmaRSABuWe21FpR6vwHwCbYo3bYv5uNTeHi+H5UbHn9P9WQLcfpgn0xv/E/ps+vzJQdyV1RXAQhL8unUVBv+OmF51YcaF5cEfmuJcSs2XCaQOwGEcjVmO3Iy1r9bgyLHzhlPDT2Q1a/5kmMmAC0wgycAdx5Z2+HDGIfj26wGn9x5ZfE6hoKo/1lxruProivkCcCuMNas940N0y3FANxVMNc7I2sv/iOYe4t5prAMC1RT/wsgtC8lUdorTIGHhAnAngTsCzVPeluidMu+lSJx/dT1ft7onvo87l0PxWkhup/TfTHP5K6omd+8sOhvQbzE3BU1UwV6lwIXhLhmNb62ePreDLYzRS7tHqLAxoarC9r69d392MEDZwB2LKB4gkE43gMnWuEbOZ3JP6IBcsmqmCgKHL+L5LD28Zw57IiaSUUbINgbuhsTLGofgXXTy26eFaTLKpi77AMFpXhaFcsR4uTfkZfiyHwIyN6DPwB4lS1Kdx5N/LJ+rfeD6N23+weAgCcAO1ZcEsbx3GhA/5B7d/Xtk+54eVBQLmrSyqpRuSuqvwzoSyFP/gEZ7tsF6lRbmfETkbtgjnM13AOwAzt4EINwbE+lxLx/95VF+xkKooExfduGqQByHL+NjU8/vTjJ0nTEw/N9UawO6Yj7HUbt+oIy7/8Ky72B3ABYppd57yso9dZC9DcA3h6BmuXLiFH1UXmMjsw0/RUblBPalUwlFkfxxkWs+/v7Cmf3u8TEkn8J6a0lILguOezAS7krai6GDtyOcROW144Zt6J6adKazQC+BGBw2OuVSma391DXclhigpEAnFH61WEAJrDp62D4UMagawd9xSeZ/CMa6Je1UHy44RIh90Z1fw7x3cWguFqT+GdBmfd/08q8yf31i4vOun10Ydmy/yoo9eqM4vcA5kSoVm1u+P3VbVF6jKzgITYmJ/TZzetvaI7ijWsIZgBmcuN/Sr/GK059GeGeiT0N0EdzV9Y8P+7umk/CeyzeX7943N3Vc3NXbPihb+w2ATxIdA6BEpu5GW+T7nh5EBSTGY/j67Kiq7YVQcAtADtIjR7NIHTtlt2LiusYBqIBHyG4P0AAZwg41zca86eYH/q9+AdDcXUM+HxhqfeEQh6ShP68brW3O52/ZOrcW09JSOqDClzso/1dUERz7xGNXjtwchx/2Z7ELgBj2ap02TesbKj0HolwCJzfmqktq72WNdk5fwZCvyrwVBF9MHdi3jdlxYafAbKqaXvRE/AkfRscL38qkWuGzgP0Ygg+BMUURDTVohncCqBt6L4ZBsYwHsfXdabb2GIoqAN/PN/Jungj29euWXcxEEQDLwwnABsuEXLOpiduqi8o9aoAlETgdmMKnAvouZrE9wpKvQ1QrBWRtSpSY63dvHGtt/NEP2TWrOWJvdk7Jxu1U6zBaQZ6tgJnA6nJfP0CINGbCbx6tZfKL/MeFcVCVoBONscw6Jqo3vzI+54diRRyHb+Nxj2Xn7GHVdm5xvhRQP8jIjc7ViFXAbgqd0LNPllRvc4C6wz0H8bGNg1uM5u7c1jD5O+9cFIqFp9qY2Y6rJ4Fo2eryjsAHXxk7BxpCSQy1r8bB2dKZydT/f5hpMsEoFWeANyV1FjOAOzULYj++LVF0/cyEkQDzwJFzrfdPhOAbvYF+JlqJBKAR79rAm+D4G0KXQRVGAEKSr0WAM0CvGaBVgEOAYAAJymQDcHIfbpjvAAxlcNzAJj0O5pG9EOA8eUhNcoEYMdhiTGX1665NrLbzGTZnDAczMi+3UHNI2Y8nru3JnozkwXDFbhAgAsUAt9Y7B9kNXdF9Q4o9kBwCMBeAFZEc1RlEIARAMa2Hf6/gOqRDp5ZlbfYv31B/vZMfeYSEdcmQuzY+rnTXuvvXxrvus7zBOBOL6OxGBybUdpfr6t/ZQyIgvK+4v4yjVR7DpcIuTlCf1hglzISAIAhAKYpjl7go53+Bx3znSuiHwLq1uljBaXYAWA8a8Eb/drX6tcseTzSb9pWitTxhiPTG/9ThswXHyuqfwFgEYMBATABcvQ5CcoEX0/UQiRjjdnhvVIdaisHaLsTc4zqzROAO5ZPTg6D0AU/7lcwCkQDb/pcbxwA16cpN256+kucUeyghsolVVA8w0hQOuREdraQZxV4hDXgDVXtCSyLehBsCPb3HYiN7ilN9c+aHzIKlJZ2QCWz23uoOtVWimgwEoDl5V4ciumsoh3q07DBDEJnO3ZdXtLEMBANPBOGTZqVJwA7XXwG9zAKlAbNVeu8V6PblhueBnxYmzH4xJbVXmvkB81G3T/gS5gAdNWuxTMqoNjASFCg2wFPDQQFbg17TDASgDuSsekAslhFj+afNJJB6PwQP8coEAVlgBCCE4B5AIjT7KGcHwE4yEhQH9+II90O1FXaSgDbWRFwY+0a7wWGAUAItmbK5Mb/1C/vZ/cyCtT37j1z/XvuxNpTADg1Y0tNQGYAqvG5/18X/FyeANx5tGdeZBCIAtOrOp8ANNwk3GlHlm9zqRD1TeQ/BHgWwMMRHyRW1k+Y+U0+DEDJqqosKKY6fhsHti/IZ1LbYVli7wNwgJGgPr3nx2zG+neBdS6HFZfUgHwY6ZQADMM+E5mQzMtlEDo9abaKQSAKBhuGJcCcAeh+EQq+BsBnJKi3lB8CoECUlwEfUIvP4OH5bEcAvLIHBTjGoY0Oqcnkxv+UedsWlLwKUW7zQX2RGj0UDRkbB6m4Ng5qabz8bdsG4hd3SgAKE4BdjmiQw1XRnSqPxDhYJwpKMxWCJUI2yYG/6+oqvE0Q/IKRoN43BBL5pYINld56AFsiefMqV29c5zXwQTjyOMC4fwCI8pkOg5jxvwEgyUhQr5p2YGPV/JL2jLUzghmOhWTAPox0dQowE4AdO99sJv+60ubHaxkFooE3ac4dgwBMdvw2DjSs97hEKAQE5lYAlpGg3vD5cfHwWEmwKnptB35Zv3bpfSz+t8ZEnP+4pwKOF0Kg8YpTXwbkAUaCeteWZXa/O3Uuh6UD9mGkqwTgDFbRDsUzlCcAd2H7a4un72UYiAbeINk34xjtuUuqD/ff5Lq6iiXPA/gJI0G9cHDz2tTLDAOgErllwLuSqcRilnzHUbN1flymAzjQpfTyDZaAh31R7xqzjLYDzq2EUjNgH0aOGjAWz7ttPICRrKBHsyOGMwidHzN+oScKytMYgpnbolz+G6o6KVgCoJ2RoB6qPXIIRuQ1rPGegaI+MjesctXm9Tc0s+Q7tabOzwDM5Mb/1L92X1nUKIrvMRLUi/f8jCW8Jq2sGgXAqRNbNSgzAK2f5AnAXfDHjGEQOldaduZEgXm75gEgFCxH9gL8FiNBPcSZQke37ZFYBizAPfVrl/6cBd7xZVsF7q/MSg09kLWRhRke7YPjtwBoZCSoZ82ZzVj/3o6Yczksg4H7MHJUAtA33P+vy55rwjgGoWPF4WCdKDDCcHo7T/4Mn5ZDWAZgMyNB3cfVBW8V800UlgFvtilcw9LubMJ9L00CMNTpJxrY1HB1QRtLMzxevbRgn6p8kZGgnmjLas/YDEBR69o4yB/amjVgh12Zo4PHBGBXPReXAHcxWLecAUgUoGbK/U3CDROAYdP4tHdQRb7ASFC32wF+XDxKzbolLwLYEOJbtGrM5Q3rvX0s7c5SfiwEH/e4/18Y7VxU9CMAf2EkqJt27Ln8jD2Za2ccmyktA/thpOOm8UwAdqxQ8TiD0IW4JPiSThQIngFQ4Po4B0NHcYlQCDVULP01gPsZCerWu4XPGYCd3kNVQrsMWBRfb1iz5HGW8rHGiMb9rZnE8JkOa3uN+OUAXmMkqBsyfACIc3ulDuiHEdMhetwDsOOL1+BBDEJnB7YvyN/OMBANvMIyTAHgdEOlwKaG31/NJUIhlZXAvwNoYCToBPzWbFvPMBwtJuanIb21qvYseCzh4/SN4vz+fxCuGAqt7QsLtinkakaCTtyWZfzjnlOT2NQO7MfONxKAJeXeUCgmsooezQ4fyiB0Vg0RZRiIgtCLuD9z23Dj/1CrWu0dEMHlAJKMRr/xHbzmLVtWe60suqPVVt5UC+D5kN1WmzH4BMv7+MSq+9t7CBOAYbZzYdGDAH7MSPSblKNtWcbagZJVVVkApjg17hng7U7eSACmkigCIHyuOrxBjx7FIHR8iJVLdIiC80CK+zO3lft+hV1dhVch4Eb//dIkADc4OUhQfgg4dplKyA4DkZtq13gvsGRPWPDOf+DLTqZqWZDhFrMtC6Gh+0gRRNsB+Y6Tr/kZ/BCwe58UAnBqzzZrNBgJQJ8HgHTJz+UJwP35EBNRDzsRqPNLhHgCcDTUVXrfEeAeRiKT3TP+ywh+BiDbuasXJgCPHRt96HBTGYJKClTWTyi+g4V6fKMerB8OYLzjt7Fj6+dO4x5xIde4+MyDxujFAHYzGhnzTyu2XAVZLl58AomM9e+ixrkcVk5bMhgJQDFMAHYllTuGQeBgnSjA48IQnADMkz8jww4f9XkBHmMk0s4XwWfr1np3pKybs4IVwplCx1BX4W1COJYB74/FYp/Cw/N9luoJBswt7ZzdT87YsWDmPy3sRwEcYjTSriaOeNmuBSUNoupiviajZweoe5PYmgb6w4h5SyPNBGDHChUzgDEMRMdKE7Ps0ImCw/m2u12yOfCPiIbfX91mU/gwgGcZjbTZr8BH6yq8uw930m7uG6ZWOQPwGKbP9d4WhrYeKl+ofeKmzSzRExNx/wRg4YqhSNm1sGQNBP8KR/epC2abiT9lJ5Nzty8s2Hbk38x08C5qMnp2gDiXFB3wdvGt2S2eANxRdjZj0Flq6IGsjQwD0cArOuv20QCcnqYsQNPWiuu4RChCGtZ7+1KpxIUAqhiNvo4NUGcQe2dDpferN9+F3UwUJfwsfgjowpRyL0cMfgwgx/Fb+VX92qX3sUS7+WyH4ARghWECMGKaFxT/WkWvgJsHUQXtAfpm88ii978+W2zkfc+OBJDn4I3wBOCjxj0ajARgebkXBzCdT9rR7DCeANzFYGNjw9UFbYwEUQDaqKz2MHy44ayfCNq8/oZmNVnnAtw4vPcvkfhDKoHZR06Jfet/cLFd2Fnz9+tfYal2Fk/if0VxquO3sSuVSixiafbojdv97T1g2b9H0M4FM38I1UvBmYC91SaKy5sXFV+D+fJGIjXL5jjaJmTwQ4CqAG59LFE1wUgANqUwDS5uGJ1h/kkjGIROAw5O5ycKDCvc/4+c1bDm+l1ZFucBeILR6JGkCq6rq8QHtqz29nTupp2cAch2oAv5c5ZdIMDnnL8Rlas2r7+hmSXag5BBnF/yHY/5fK4jqnnRzJ9C8FEABxiNHj351Vbt2U2Lin/QaQyuju7vq5nLHUy476VJAJyasaVBmQGY4v5/XUrljmUQOrU+nM5PFBRhOAEYlgP/KKta572qw0edL4ofMhrdUitqShsqvK8Anu34H/NnexMBDHfwvjhTqGNZzrt9rDH6AwDi9ngW99avXfpzlmgPLH8qIcA0x++ipfHyt21jYUZX84LiX1ux5wDYzmicuKUU6F0xe/DMXYtKnuvyD6h1Ml8Tk9iGTP3slB9zLiZxHfiZ0Yf3ABTh/n9dvLHY8eMYhg7EcgYgUWCeR3F/71ZrTCVLMtoafn91W91a79MKuQZAkhHp+j1XgK8kE3h73dol/zhmmxB3dIaACNuBTu9b7SvVyf2ejrJZffw/lmbPjDfD8wEkHL+NzG78T07YtaDkWd/qOwGsZjSO/RokwHlNC2d+rnHxmQeP2SfAyf79lR3bCzK2v6/AucOSGhsXl2wd6Iswh4MXglkk6X4ZNQY2J4eB6PSSzgQgUYBMcXqACzRtHF/0HIuRAGhD5dJvQsw8AFsYjqOsV2vOqqv0rtuy2ms97jOlTrYJqYTE/8JiflNBqfdZAB9y/DasGnN5w3pvH0u0h42h6pQQ3AbHCwQA2L145o7mEUXvgeit4OEgb9UGka8m9g89rWlh8eqQvvP/EZ7YjI0jRE9xbOTzuyBcxeEZgMoTgDvJSjAGXchOpnhKH1GAHkmnBzmQ7+Hh+XwZpDfUVyxZbzDoNAW+CyDas0cE21TxqfpKb07DuiXPdu/vqIttwqrqNTfsYO0/bPocLx/A10NQf/+3Yc2Sx1miPWfhOz8DQQXPsSTpDfPFb14w8yZYWwrFBgYEv1AbL2leUPSlbdecfKibbap7/bu1d2a2rRSX2kpV4NtBuJAjMwDBGYAdS2jwEAahs6bXjyInoiCMr1DvbBsL/FNT+n8sReqotvLa/Q2V3r8LzLuASA4iXxHghkGDhxQ1rPUeRA8SoQpx7SPdARHcxFp/2KxZyxMmhh/BsU3Nu7AhGcdSlmgv+3bjbt/+5vuJ/oElSR01Ly5ZP6w1/g4VLAXQErn8AmSNAOc2Lyz+6M7FBRt79Jct6hxrBR5qXlyyPqO/waGYqOD+nQuLXgjCtZgp5V6eAiexSTqaP3IYg9C51eIm3URBeiRVVjl66a1GcCmXhtHx1FUuWVM/YeaZorIIQBRmiL0iwA0Gg6bWVXq3v/Cn/+nx4Chrjz4OwJXTVlUVV9VVeJtY2w/bn73jFijOcvw22kTMJ060XJ2OrXnBzJdcniWlor9vXjDzJZYkdaXh6oK2nQuKb44jXiQqPwRgw37PClkDse/ZubDonG4u9+3quXLnnV9QnxA/4yfYx+LJRwCkHKgB1Uk/6z+DcjUmnuIJwF3xx45mEDo+y9z/jyhQhrflPSjA045d9gEr+EhdhVfBEqQTeni+X7d26YpDdvh0qFyNcJ4muEFVPpeVwJS6Su/22spr9/f2B1VVee0i+KID95wC8LkjMxwJQGHpzfNU8N8hGOkuqatY8jxLtK9hxDVwcxuEnXFfP8sSpBPZvrBgW9Oiosti1pQA+iDCtz9gEoKfqqJ058Kic5oXlPy1Tw/W9uYfQ7A+6DetQG3MpN69bUHJq5n+XY1XnPqyqtwR8JBU+Rbvfm3x9L1BuSADyxOAu3wzzctjEDo90IYJQKIAefrpxUk5vFG8G1/aFY9bizM2VnhcGkQ9sm3dNYfq1y79dtYeTFPIpUDwX4JPoA3AI2LlPfWV3tsa1i69q2q1dyAdP7iuwnsAh5fVBnVWxUsKzKuv9L7Pmn3YtFlfGWFhfwgg5vZ7IirrJ878Bku073YuKv6jqnwOTsxueXPgL2rPC8Ipl+SOxsUzapoXzvyUpJCvKl8D8Irjt7RVFDf7Vk9pXlD8bzsXFa9Ny0/1zk3ZmP0wFEH9wJIU6F2S3T6r8YpTX+63trJxxw1HZpIGLh4Avh2zLWftXjwzUKtYpGCu9y0IvsDm52j7PvOvDELHjt3ggp1XFv+JkSAKlinlXk4iKf+hop8SRRGAoJxi1KrAVgH+JjA/rqtcsoalRemSP+fmMxCzl4ri4wAmOHDJVoDHAfy4VbJ/vrXiuozuqZs/9+Y5Iva/AJQDGMhlDW0AGgE8oSI/b6hY+htE/YCXDgrmej+G4N8cv40Wa/H2jeu8BpZo+oxbUXOaQK8FcMEAP8fH7OcheB4qP07sH7Ki2wcaEB3DpDteHpQcduDDAD5xpN67cDLnKwJ92If+eNeCmRUQyVgfV7KqKmv3Pvm8qHxKgZkY2AMBXwNQK4o/wcd9TVcVbxmwtvLuDR8RMZ8HdA6AwQN0GXsBVAvwR2PtvUH9GCIFpd4fAZzP5uZNmhXfu/8THxvBSBwtZu0p/KpHFHSemVyWPeDtV1ayzecef9Rfdb6wDHNhcZE1eL8oTg3Qxe1W4K8Q/Cmm+ENtpdfI8qK3yp/rXSqCH7p+Hyq4sqHCu5clmjkTlj81OO5nBeYk0P2xITZIy9oofCbeXz062S4XCnARoOcjOOcWKCDPK+yfRfGnZj34OBafmWSJBcOoB+uHD913qF9n1JtBww5tuXyqE3vfSkGptwnAVFaVN/mjRla0fOiCMkbiKC3NC4qGZfKLBhERUV8VnXX7aJtonw3BWVDMBjC7nw47swo0iOJpMfK0qD5eW4lnAM+yVKgr08+59eSYn3o+BIfx/aq+0ruYJUpEGeOpyZu8oQh+bLaqzgZwNgQlAOL98NsPiOhzCjyt1vwDkvzLzoWnNrNQyEVxBHM6+YDyR5/kMwqd1DD5R0REge+s/n79KwB+d+QfAJBp59ySH0vZQgUmG+gpCkxWwWQBpgAYCWBIN398O4AmHF7avsUCWwWyFarV6uM5znqlHoxmjUmlfqjifPJvdzKBxSxPIspskym2CdiAw//cBwC5Dzw/BG2JU6GYIgaTrcpkAU7B4b59PIAR6H6CcC+AbVBsEdGterhv32Ik/vyO7QW18IQf8ygU4uifrLlT/HGjBzEKncdUDAERETlINz1xUz2A+uP9oQmzvMHxQdnZg1NtI5KCeCxmhgB2f3scB20qu21rxXV7wL3rKE0KynA9FO9y/uFSXLVltdfEEiWi/tZ82ektAJ488s+xGimZfNeLI9tkcALZdqikkoNMLJbyLdqzk+17UrH2tsbFZx5kNCkq4lDUQPAOhuJNfu7YcYxCh7YTWssoEBFRWDU+7R0EcBCHN7UmypjpZTfPgtolzt+I4L6GSu9nLFEiCm47Jbr1zX59JwNCUWcA8FTGo7XrsGGTGIaOFcVUMwpEREREvXfa+V8fYtT+CG6cbHk8WzSJ/2SJEhERucPAxpaDS1reFDNbVYTLojtQsVwCTERERNQHB1tavgVghuO3YVVwOfe8JCIicoupf/KmagW+y1AceaMZPHg3o9CJPyg2qIFhICIiIuqdwnnehwVYEIJb+UZDhbeaJUpEROQWAwAHW3EtgAqGA/BPGtHGKHSyecvlU1sZBiIiIqKemzr7tly1WB6CW9mQTGAJS5SIiMg9Bji88XVLKy5Q4KGoB8SOGc3lv51x/z8iIiKi3pF4PHkvANcPmWsXMZ/YstrjR2EiIiIHmdf/R+PT3sGGSu/jauV9UPwGQHsUA5LKHTOK1eJoCuX+f0RERES9kF/qfQHA+51/HxRZUlex5HmWKBERkZs6zXZrWLf0jwD+OGnOHYOGmJbJvvjjTRd/Low0JuKPHf0Iq8XRBKhlFIiIiIh6Jr/05hKBvd35d2SgsmF88f+yRImIiNx1zMTetnXXHMLhxE9kkj8T7n3xZPhmKKtFh5c+FS4BJiIiIuqB/AvvzJZ9r/4IwCDHb6VFLT6Dh+f7LFUiIiJ3GYbgTSk/VsQodJbI5gxAIiIiop6Qfa9+BcDprt+HQr6wcZ3XwBIlIiJyGxOAb31RgylmFDrZuf3Txa8wDERERETdU1C67L0AvhCCW/l1Q+XSe1iiRERE7mMC8C1UMINR6ITLf4mIiIi6aXLZl08C9B4A4vit7E4msIglSkREFA5MAL6FqHIJcEcKngBMRERE1E052rYcwMnOvwIqrtqy2mtiiRIREYUDE4BH4xLgTjVEuf8fERERUTcUlnoLFLjE+RsR3New1vsZS5SIiCg8mAA8YtSD9cMBjGckjmZhuASYiIiI6ATy594yXYE7nL8RwbZkHNewRImIiMKFCcAjEi3tnP3XhVhSuQSYiIiI6DjKy724iP8ggGGO34pV4FNbVnt7WKpEREThwgTgERIz3P+vs0NNzUVbGQYiIiKiY9vejqUAzg7BrdzRUOGtZokSERGFDxOAR6iCCcBOpBaeWMaBiIiIqGsz5t1cCsF1IbiVDckEbmKJEhERhRMTgK9TYQKwc4fn2/kAAAVrSURBVFC4/x8RERHRMZSUe0OttT8AEHP8VpIG+PSW1V4rS5WIiCicmAB8nSgTgB0owBOAiYiIiI4hmcRdAPKdf+cTLKmt9J5iiRIREYUXE4AAsPypBIDpDESHyqHCGYBEREREXSiYu+xjClzq+n2IYG3D+JlfZ4kSERGFGxOAACZg2HQACUbiaFbAE4CJiIiIOsif7U2C6N0huJWWlIl9Bg/P91mqRERE4cYEIICU+MWMQic2a/+QeoaBiIiI6K08gzjuBzDK9TsR4D83PXET3/eIiIgigAlAAGJ4AEgXtmy75uRDDAMRERHRm/LL8EUBznP/BRh/rKv07mGJEhERRQMTgABEwQRgRwru/0dERET0FvnzvHeIYlkIbmV3Mo7PAFCWKhERUTQwAQhAwROAOxLu/0dERET0hgmzvMFi8SMAWc6/+4p8bstqr4mlSkREFB1MAAIAZAZj0OHFUFHLKBAREREdNiQH3wBCsWrkBw0VSx9miRIREUVL5BOAY+6pmQBgBKvC0awaLgEmIiIiAjC9zHsfgMXO34hgW5tkX8MSJSIiip7IJwBjlvv/dSUBLgEmIiIiyp93+9iY4j4A4vitWKty2daK615jqRIREUVP5BOAopYJwM6aGhfP2M0wEBERUdRfFcVvv1eBPNdvRBXf3Fi59DEWKRERUTRFPgGoIkwAdn7XfYYxICIioqgrLPU+D8FFIbiVDa06/CaWKBERUXTxEBBwCXAnYpkAJCIiokgrOPuWYgW+FoJbSRrg09vWXXOIpUpERBRdnAEIFLMadGDxOINAREREkXXJqhhi/o8ADHL9VgTwaiu9p1ioRERE0RbpBOCU+zbnCDCR1eAorTE9uJZhICIioqgq3LHhkwDOcP0+RLC2bsLMr7JEiYiIKNIJwEOt/nC4f6Jbuj3QuPjMgwwDERERRZVVfDoEt3HA2thleHi+zxIlIiKiSCcAY2bPAQB8KXpTKmbkDoaBiIiIokyAU52/B8F/Nay9aSNLk4iIiICIJwCPzHSrYTV442X3tsYri2oZCSIiIoq4Vsdf6v5YV+GtYDESERHR6yJ/CIhA7mc1AKB4rGl7060MBBEREfG1CC+5+26LpmQcnzl8G0RERESHRT4B6Lf7dwHYFO2XXFmDnPYPwjs3xUeCiIiIIk/kPkevfL81+MCW1V4TC5GIiIjeKvIJwF2fLzlggPkAXo3g7SsU3xx+KPbe5stOb+HjQERERAQ0VCz9GQS/deyyd6gxH2xY4z3DEiQiIqKODEMA7FhY/LSoPQfAPyJyywrFbwGd27yo+JqGqwvaWAuIiIiI3nxXGjR4yL+q4lEHrjUpwIOxZNapDWuWPM6iIyIioq4IQ/AWnpq8idXvU5iPKDBDoINDdHd7RWW7BdaK4I/NC4s2s8CJiIiIjq9wzrJ3q9FLARQBGBeAS1IAO0SxWY08ba3+ZONabydLioiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIiIyGH/HzDNthlKlka8AAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIxLTAzLTEzVDExOjM5OjM4KzAwOjAwjoLHlgAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMS0wMy0xM1QxMTozOTozOCswMDowMP/ffyoAAAAASUVORK5CYII=");
    			add_location(image, file$3, 43, 10, 1249);
    			add_location(defs0, file$3, 31, 8, 891);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg1, "width", "55");
    			attr_dev(svg1, "height", "14");
    			attr_dev(svg1, "viewBox", "0 0 55 14");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "class", "svelte-105pe8i");
    			add_location(svg1, file$3, 22, 6, 618);
    			attr_dev(div2, "class", "text");
    			add_location(div2, file$3, 51, 6, 47312);
    			attr_dev(div3, "class", "paypal svelte-105pe8i");
    			add_location(div3, file$3, 21, 4, 590);
    			attr_dev(path1, "d", "M7 10H4V17H7V10Z");
    			attr_dev(path1, "fill", "#E4E4E4");
    			add_location(path1, file$3, 61, 8, 47548);
    			attr_dev(path2, "d", "M13.5 10H10.5V17H13.5V10Z");
    			attr_dev(path2, "fill", "#E4E4E4");
    			add_location(path2, file$3, 62, 8, 47602);
    			attr_dev(path3, "d", "M22 19H2V22H22V19Z");
    			attr_dev(path3, "fill", "#E4E4E4");
    			add_location(path3, file$3, 63, 8, 47665);
    			attr_dev(path4, "d", "M20 10H17V17H20V10Z");
    			attr_dev(path4, "fill", "#E4E4E4");
    			add_location(path4, file$3, 64, 8, 47721);
    			attr_dev(path5, "d", "M12 1L2 6V8H22V6L12 1Z");
    			attr_dev(path5, "fill", "#E4E4E4");
    			add_location(path5, file$3, 65, 8, 47778);
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "width", "24");
    			attr_dev(svg2, "height", "24");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			attr_dev(svg2, "fill", "none");
    			attr_dev(svg2, "class", "svelte-105pe8i");
    			add_location(svg2, file$3, 54, 6, 47390);
    			attr_dev(div4, "class", "text svelte-105pe8i");
    			add_location(div4, file$3, 67, 6, 47850);
    			attr_dev(div5, "class", "us__bank svelte-105pe8i");
    			add_location(div5, file$3, 53, 4, 47360);
    			add_location(span, file$3, 69, 31, 47926);
    			attr_dev(div6, "class", "more__payment svelte-105pe8i");
    			add_location(div6, file$3, 69, 4, 47899);
    			attr_dev(div7, "class", "tab__head__items svelte-105pe8i");
    			add_location(div7, file$3, 5, 2, 102);
    			attr_dev(label0, "for", "country");
    			attr_dev(label0, "class", "svelte-105pe8i");
    			add_location(label0, file$3, 72, 4, 48002);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "input svelte-105pe8i");
    			attr_dev(input0, "placeholder", "1234 1234 1234 1234");
    			attr_dev(input0, "autocomplete", "");
    			add_location(input0, file$3, 74, 6, 48081);
    			attr_dev(div8, "class", "icon__wrpper svelte-105pe8i");
    			add_location(div8, file$3, 80, 6, 48214);
    			attr_dev(div9, "class", "input__card svelte-105pe8i");
    			add_location(div9, file$3, 73, 4, 48048);
    			attr_dev(label1, "for", "input");
    			attr_dev(label1, "class", "svelte-105pe8i");
    			add_location(label1, file$3, 85, 8, 48343);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "input  svelte-105pe8i");
    			attr_dev(input1, "placeholder", "MM / YY");
    			attr_dev(input1, "autocomplete", "");
    			add_location(input1, file$3, 86, 8, 48390);
    			attr_dev(div10, "class", "column svelte-105pe8i");
    			add_location(div10, file$3, 84, 6, 48313);
    			attr_dev(label2, "for", "input ");
    			attr_dev(label2, "class", "svelte-105pe8i");
    			add_location(label2, file$3, 94, 8, 48572);
    			attr_dev(input2, "type", "password");
    			attr_dev(input2, "class", "input  svelte-105pe8i");
    			attr_dev(input2, "placeholder", "CVC");
    			attr_dev(input2, "autocomplete", "");
    			add_location(input2, file$3, 96, 10, 48649);
    			attr_dev(path6, "opacity", "0.2");
    			attr_dev(path6, "d", "M15.9282 1.56738H1.46939C0.793469 1.56738 0 2.34616 0 3.03677V14.0572C0 14.7478 0.793469 15.5266 1.46939 15.5266H19.8367C20.5127 15.5266 21.3061 14.7478 21.3061 14.0572V8.52493C20.6872 9.08168 19.9228 9.45113 19.102 9.59024V9.64902C19.102 10.1339 18.8376 10.3837 18.3673 10.3837H2.20408C1.73388 10.3837 1.46939 10.1339 1.46939 9.64902V8.91432C1.46939 8.42942 1.73388 8.17963 2.20408 8.17963H15.0833C14.6592 7.70963 14.3416 7.15353 14.1524 6.54941C13.9632 5.94528 13.9068 5.30741 13.9871 4.67945C14.0673 4.0515 14.2823 3.4483 14.6173 2.91117C14.9523 2.37403 15.3995 1.91564 15.9282 1.56738V1.56738Z");
    			attr_dev(path6, "fill", "black");
    			add_location(path6, file$3, 105, 14, 48997);
    			attr_dev(path7, "d", "M14.209 3.77148H0V5.97557H14.018C13.8945 5.23653 13.9602 4.47827 14.209 3.77148V3.77148Z");
    			attr_dev(path7, "fill", "black");
    			add_location(path7, file$3, 106, 14, 49649);
    			attr_dev(g, "clip-path", "url(#clip0_4072_12443)");
    			add_location(g, file$3, 104, 14, 48943);
    			attr_dev(path8, "d", "M18.8577 10.2857C17.4937 10.2857 16.1856 9.74388 15.2212 8.77941C14.2567 7.81493 13.7148 6.50683 13.7148 5.14286C13.7148 3.77889 14.2567 2.47078 15.2212 1.50631C16.1856 0.541835 17.4937 0 18.8577 0C20.2217 0 21.5298 0.541835 22.4942 1.50631C23.4587 2.47078 24.0006 3.77889 24.0006 5.14286C24.0006 6.50683 23.4587 7.81493 22.4942 8.77941C21.5298 9.74388 20.2217 10.2857 18.8577 10.2857ZM16.8153 3.01224H16.2348L14.8169 3.73224V4.46694L15.941 3.87918V7.27347H16.8226V3.01224H16.8153ZM18.505 3.6C18.9238 3.6 19.2177 3.8351 19.2177 4.17306C19.2177 4.54041 18.8724 4.79755 18.3728 4.79755H18.1524V5.42204H18.4169C18.9459 5.42204 19.3059 5.68653 19.3059 6.06857C19.3059 6.43592 18.9532 6.68571 18.4536 6.68571C18.0863 6.68571 17.7189 6.56816 17.3369 6.34041V7.0751C17.7483 7.25143 18.1597 7.34694 18.5638 7.34694C19.5263 7.34694 20.1875 6.85469 20.1875 6.14204C20.1875 5.64245 19.8789 5.23837 19.3646 5.07673C19.8055 4.9298 20.092 4.54041 20.092 4.09959C20.092 3.40898 19.4822 2.93878 18.6006 2.93878C18.2031 2.94318 17.8107 3.02816 17.4471 3.18857V3.90857C17.7997 3.7102 18.1597 3.6 18.505 3.6ZM21.6789 5.20163C22.2153 5.20163 22.5899 5.51755 22.5899 5.92898C22.5899 6.36245 22.2153 6.66367 21.6789 6.66367C21.3557 6.66367 21.0177 6.56082 20.6724 6.34776V7.10449C21.0324 7.26612 21.3997 7.34694 21.7597 7.34694C21.9508 7.34694 22.1271 7.31755 22.2961 7.27347C22.6781 6.64898 22.8985 5.92898 22.8985 5.15755L22.8838 4.84898C22.6107 4.68729 22.2975 4.60581 21.9801 4.61388C21.8479 4.61388 21.7083 4.62122 21.5614 4.64327V3.68816H22.6193C22.5276 3.453 22.4145 3.22675 22.2814 3.01224H20.7973V5.32653C21.0912 5.25306 21.385 5.20163 21.6789 5.20163Z");
    			attr_dev(path8, "fill", "black");
    			add_location(path8, file$3, 108, 14, 49798);
    			attr_dev(rect1, "width", "23.5102");
    			attr_dev(rect1, "height", "15.4286");
    			attr_dev(rect1, "fill", "white");
    			attr_dev(rect1, "transform", "translate(0 1.56738)");
    			add_location(rect1, file$3, 111, 14, 51548);
    			attr_dev(clipPath, "id", "clip0_4072_12443");
    			add_location(clipPath, file$3, 110, 14, 51500);
    			add_location(defs1, file$3, 109, 14, 51478);
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "width", "24");
    			attr_dev(svg3, "height", "17");
    			attr_dev(svg3, "viewBox", "0 0 24 17");
    			attr_dev(svg3, "fill", "none");
    			add_location(svg3, file$3, 103, 12, 48832);
    			attr_dev(div11, "class", "cvc__icon svelte-105pe8i");
    			add_location(div11, file$3, 102, 10, 48795);
    			attr_dev(div12, "class", "cvc__wrapp svelte-105pe8i");
    			add_location(div12, file$3, 95, 8, 48613);
    			attr_dev(div13, "class", "column right svelte-105pe8i");
    			add_location(div13, file$3, 93, 6, 48536);
    			attr_dev(div14, "class", "two__colums svelte-105pe8i");
    			add_location(div14, file$3, 83, 4, 48280);
    			attr_dev(div15, "class", "tab__payment__fields svelte-105pe8i");
    			add_location(div15, file$3, 71, 2, 47962);
    			attr_dev(div16, "class", "tab__wrapper");
    			add_location(div16, file$3, 4, 0, 72);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div7);
    			append_dev(div7, div1);
    			append_dev(div1, svg0);
    			append_dev(svg0, path0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div7, t2);
    			append_dev(div7, div3);
    			append_dev(div3, svg1);
    			append_dev(svg1, rect0);
    			append_dev(svg1, defs0);
    			append_dev(defs0, pattern);
    			append_dev(pattern, use);
    			append_dev(defs0, image);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div7, t5);
    			append_dev(div7, div5);
    			append_dev(div5, svg2);
    			append_dev(svg2, path1);
    			append_dev(svg2, path2);
    			append_dev(svg2, path3);
    			append_dev(svg2, path4);
    			append_dev(svg2, path5);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div7, t8);
    			append_dev(div7, div6);
    			append_dev(div6, span);
    			append_dev(div16, t10);
    			append_dev(div16, div15);
    			append_dev(div15, label0);
    			append_dev(div15, t12);
    			append_dev(div15, div9);
    			append_dev(div9, input0);
    			append_dev(div9, t13);
    			append_dev(div9, div8);
    			mount_component(cardsicons, div8, null);
    			append_dev(div15, t14);
    			append_dev(div15, div14);
    			append_dev(div14, div10);
    			append_dev(div10, label1);
    			append_dev(div10, t16);
    			append_dev(div10, input1);
    			append_dev(div14, t17);
    			append_dev(div14, div13);
    			append_dev(div13, label2);
    			append_dev(div13, t19);
    			append_dev(div13, div12);
    			append_dev(div12, input2);
    			append_dev(div12, t20);
    			append_dev(div12, div11);
    			append_dev(div11, svg3);
    			append_dev(svg3, g);
    			append_dev(g, path6);
    			append_dev(g, path7);
    			append_dev(svg3, path8);
    			append_dev(svg3, defs1);
    			append_dev(defs1, clipPath);
    			append_dev(clipPath, rect1);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cardsicons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cardsicons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div16);
    			destroy_component(cardsicons);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PaymentForm', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PaymentForm> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CardsIcons });
    	return [];
    }

    class PaymentForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaymentForm",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src\components\billing\Billing.svelte generated by Svelte v3.48.0 */
    const file$2 = "src\\components\\billing\\Billing.svelte";

    // (66:8) {#if $allowItemIndexBilling> 1}
    function create_if_block$1(ctx) {
    	let button;
    	let svg;
    	let path;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = text("Back");
    			attr_dev(path, "d", "M9.36881 12.568C9.53285 12.4039 9.625 12.1814 9.625 11.9494C9.625 11.7174 9.53285 11.4949 9.36881 11.3308L5.03756 6.99953L9.36881 2.66828C9.5282 2.50325 9.61639 2.28223 9.6144 2.0528C9.61241 1.82338 9.52038 1.60392 9.35815 1.44169C9.19592 1.27946 8.97646 1.18743 8.74704 1.18544C8.51761 1.18345 8.29659 1.27164 8.13156 1.43103L3.18169 6.38091C3.01765 6.54499 2.9255 6.76751 2.9255 6.99953C2.9255 7.23155 3.01765 7.45407 3.18169 7.61816L8.13156 12.568C8.29565 12.7321 8.51817 12.8242 8.75019 12.8242C8.98221 12.8242 9.20473 12.7321 9.36881 12.568Z");
    			attr_dev(path, "fill", "#CFCFCF");
    			add_location(path, file$2, 74, 14, 2287);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "14");
    			attr_dev(svg, "height", "14");
    			attr_dev(svg, "viewBox", "0 0 14 14");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "class", "svelte-1dgszgs");
    			add_location(svg, file$2, 67, 13, 2087);
    			attr_dev(button, "class", "btn prev svelte-1dgszgs");
    			add_location(button, file$2, 66, 10, 2029);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, path);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*prevTab*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(66:8) {#if $allowItemIndexBilling> 1}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div4;
    	let div2;
    	let h2;
    	let t0;
    	let span;
    	let t2;
    	let div1;
    	let form;
    	let tabs;
    	let t3;
    	let switch_instance;
    	let t4;
    	let div0;
    	let t5;
    	let button;
    	let t6;
    	let t7;
    	let div3;
    	let buttonleft;
    	let t8;
    	let buttonright;
    	let current;
    	let mounted;
    	let dispose;

    	tabs = new Tabs({
    			props: { tabItems: /*tabItems*/ ctx[3] },
    			$$inline: true
    		});

    	var switch_value = /*activeItem*/ ctx[0].component;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	let if_block = /*$allowItemIndexBilling*/ ctx[2] > 1 && create_if_block$1(ctx);
    	buttonleft = new ButtonLeft({ $$inline: true });
    	buttonleft.$on("click", /*prevStep*/ ctx[6]);
    	buttonright = new ButtonRight({ $$inline: true });
    	buttonright.$on("click", /*nextStep*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			h2 = element("h2");
    			t0 = text("Payment/Withdrawal ");
    			span = element("span");
    			span.textContent = "Methode";
    			t2 = space();
    			div1 = element("div");
    			form = element("form");
    			create_component(tabs.$$.fragment);
    			t3 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t4 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t5 = space();
    			button = element("button");
    			t6 = text(/*formButtonText*/ ctx[1]);
    			t7 = space();
    			div3 = element("div");
    			create_component(buttonleft.$$.fragment);
    			t8 = space();
    			create_component(buttonright.$$.fragment);
    			attr_dev(span, "class", "green svelte-1dgszgs");
    			add_location(span, file$2, 57, 27, 1747);
    			attr_dev(h2, "class", "main__head svelte-1dgszgs");
    			add_location(h2, file$2, 56, 4, 1695);
    			attr_dev(form, "class", "svelte-1dgszgs");
    			add_location(form, file$2, 60, 6, 1830);
    			attr_dev(button, "class", "btn next svelte-1dgszgs");
    			add_location(button, file$2, 81, 8, 2980);
    			attr_dev(div0, "class", "buttons__wrapper svelte-1dgszgs");
    			add_location(div0, file$2, 64, 6, 1946);
    			attr_dev(div1, "class", "main__tabs svelte-1dgszgs");
    			add_location(div1, file$2, 59, 4, 1798);
    			attr_dev(div2, "class", "info__main svelte-1dgszgs");
    			add_location(div2, file$2, 55, 2, 1665);
    			attr_dev(div3, "class", "bottom__btns");
    			add_location(div3, file$2, 86, 2, 3095);
    			attr_dev(div4, "class", "main__wrapper svelte-1dgszgs");
    			add_location(div4, file$2, 54, 0, 1634);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, h2);
    			append_dev(h2, t0);
    			append_dev(h2, span);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, form);
    			mount_component(tabs, form, null);
    			append_dev(form, t3);

    			if (switch_instance) {
    				mount_component(switch_instance, form, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			append_dev(div0, t5);
    			append_dev(div0, button);
    			append_dev(button, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			mount_component(buttonleft, div3, null);
    			append_dev(div3, t8);
    			mount_component(buttonright, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*nextTab*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (switch_value !== (switch_value = /*activeItem*/ ctx[0].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, form, null);
    				} else {
    					switch_instance = null;
    				}
    			}

    			if (/*$allowItemIndexBilling*/ ctx[2] > 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(div0, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*formButtonText*/ 2) set_data_dev(t6, /*formButtonText*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(buttonleft.$$.fragment, local);
    			transition_in(buttonright.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(buttonleft.$$.fragment, local);
    			transition_out(buttonright.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(tabs);
    			if (switch_instance) destroy_component(switch_instance);
    			if (if_block) if_block.d();
    			destroy_component(buttonleft);
    			destroy_component(buttonright);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $successMessageState;
    	let $allowItemIndexBilling;
    	validate_store(successMessageState, 'successMessageState');
    	component_subscribe($$self, successMessageState, $$value => $$invalidate(9, $successMessageState = $$value));
    	validate_store(allowItemIndexBilling, 'allowItemIndexBilling');
    	component_subscribe($$self, allowItemIndexBilling, $$value => $$invalidate(2, $allowItemIndexBilling = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Billing', slots, []);

    	let tabItems = [
    		{ name: "Address", component: AddressForm },
    		{ name: "Payment", component: PaymentForm }
    	];

    	let activeItem = tabItems[0];
    	let formButtonText = 'Next';
    	let nextButtonState = false;

    	function nextTab() {
    		if ($allowItemIndexBilling < 3) {
    			let index = tabItems.findIndex(object => {
    				return object.name === activeItem.name;
    			});

    			if (index === 0) {
    				$$invalidate(0, activeItem = tabItems[index + 1]);
    				set_store_value(allowItemIndexBilling, $allowItemIndexBilling = $allowItemIndexBilling + 1, $allowItemIndexBilling);
    				$$invalidate(1, formButtonText = "Confirm");
    			}
    		} else if (index === 1) {
    			nextButtonState = true;
    		}
    	}

    	function prevTab() {
    		if ($allowItemIndexBilling > 1) {
    			let index = tabItems.findIndex(object => {
    				return object.name === activeItem.name;
    			});

    			if (index != 0) {
    				$$invalidate(0, activeItem = tabItems[index - 1]);
    				set_store_value(allowItemIndexBilling, $allowItemIndexBilling = $allowItemIndexBilling - 1, $allowItemIndexBilling);
    				$$invalidate(1, formButtonText = "Next");
    				nextButtonState = false;
    			}
    		}
    	}

    	let prevStep = () => {
    		decrementStep();
    	};

    	let nextStep = () => {
    		set_store_value(successMessageState, $successMessageState = true, $successMessageState);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Billing> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Tabs,
    		AddressForm,
    		PaymentForm,
    		allowItemIndexBilling,
    		successMessageState,
    		decrementStep,
    		ButtonLeft,
    		ButtonRight,
    		tabItems,
    		activeItem,
    		formButtonText,
    		nextButtonState,
    		nextTab,
    		prevTab,
    		prevStep,
    		nextStep,
    		$successMessageState,
    		$allowItemIndexBilling
    	});

    	$$self.$inject_state = $$props => {
    		if ('tabItems' in $$props) $$invalidate(3, tabItems = $$props.tabItems);
    		if ('activeItem' in $$props) $$invalidate(0, activeItem = $$props.activeItem);
    		if ('formButtonText' in $$props) $$invalidate(1, formButtonText = $$props.formButtonText);
    		if ('nextButtonState' in $$props) nextButtonState = $$props.nextButtonState;
    		if ('prevStep' in $$props) $$invalidate(6, prevStep = $$props.prevStep);
    		if ('nextStep' in $$props) $$invalidate(7, nextStep = $$props.nextStep);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		activeItem,
    		formButtonText,
    		$allowItemIndexBilling,
    		tabItems,
    		nextTab,
    		prevTab,
    		prevStep,
    		nextStep
    	];
    }

    class Billing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Billing",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\components\SuccessMessage.svelte generated by Svelte v3.48.0 */

    const file$1 = "src\\components\\SuccessMessage.svelte";

    function create_fragment$1(ctx) {
    	let div6;
    	let div1;
    	let div0;
    	let t1;
    	let div5;
    	let div3;
    	let t2;
    	let span0;
    	let t4;
    	let div2;
    	let t5;
    	let span1;
    	let t7;
    	let p;
    	let t9;
    	let div4;
    	let a0;
    	let img0;
    	let img0_src_value;
    	let a1;
    	let img1;
    	let img1_src_value;
    	let a2;
    	let img2;
    	let img2_src_value;

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "You are now a Green Saver!";
    			t1 = space();
    			div5 = element("div");
    			div3 = element("div");
    			t2 = text("You have opened your account ");
    			span0 = element("span");
    			span0.textContent = "and added a payment/ withdraw source!";
    			t4 = space();
    			div2 = element("div");
    			t5 = text("Welcome to ESi ");
    			span1 = element("span");
    			span1.textContent = "green saver!";
    			t7 = space();
    			p = element("p");
    			p.textContent = "Share with your friends";
    			t9 = space();
    			div4 = element("div");
    			a0 = element("a");
    			img0 = element("img");
    			a1 = element("a");
    			img1 = element("img");
    			a2 = element("a");
    			img2 = element("img");
    			add_location(div0, file$1, 1, 28, 60);
    			attr_dev(div1, "class", "success__top svelte-94jiqo");
    			add_location(div1, file$1, 1, 2, 34);
    			attr_dev(span0, "class", "green svelte-94jiqo");
    			add_location(span0, file$1, 4, 35, 198);
    			attr_dev(span1, "class", "green svelte-94jiqo");
    			add_location(span1, file$1, 7, 26, 308);
    			add_location(div2, file$1, 7, 6, 288);
    			attr_dev(div3, "class", "like_h2 svelte-94jiqo");
    			add_location(div3, file$1, 3, 4, 140);
    			attr_dev(p, "class", "success__text svelte-94jiqo");
    			add_location(p, file$1, 9, 4, 371);
    			if (!src_url_equal(img0.src, img0_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/628b8ff16ae2f89abf979078_Facebook%20-%20Negative.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "loading", "lazy");
    			attr_dev(img0, "alt", "");
    			add_location(img0, file$1, 12, 9, 524);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "success__icon w-inline-block svelte-94jiqo");
    			add_location(a0, file$1, 11, 6, 465);
    			if (!src_url_equal(img1.src, img1_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/628b9087dc3e1e5c47d96b35_entypo-social_linkedin-with-circle.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "loading", "lazy");
    			attr_dev(img1, "alt", "");
    			add_location(img1, file$1, 18, 9, 782);
    			attr_dev(a1, "href", "#");
    			attr_dev(a1, "class", "success__icon w-inline-block svelte-94jiqo");
    			add_location(a1, file$1, 17, 7, 723);
    			if (!src_url_equal(img2.src, img2_src_value = "https://uploads-ssl.webflow.com/627ca4b5fcfd5674acf264e6/628b9097061243a2b52c214a_ant-design_twitter-circle-filled.svg")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "loading", "lazy");
    			attr_dev(img2, "alt", "");
    			add_location(img2, file$1, 24, 9, 1051);
    			attr_dev(a2, "href", "#");
    			attr_dev(a2, "class", "success__icon w-inline-block svelte-94jiqo");
    			add_location(a2, file$1, 23, 7, 992);
    			attr_dev(div4, "class", "success__icons svelte-94jiqo");
    			add_location(div4, file$1, 10, 4, 429);
    			attr_dev(div5, "class", "success__body svelte-94jiqo");
    			add_location(div5, file$1, 2, 2, 107);
    			attr_dev(div6, "class", "success__message svelte-94jiqo");
    			add_location(div6, file$1, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div1);
    			append_dev(div1, div0);
    			append_dev(div6, t1);
    			append_dev(div6, div5);
    			append_dev(div5, div3);
    			append_dev(div3, t2);
    			append_dev(div3, span0);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, t5);
    			append_dev(div2, span1);
    			append_dev(div5, t7);
    			append_dev(div5, p);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, a0);
    			append_dev(a0, img0);
    			append_dev(div4, a1);
    			append_dev(a1, img1);
    			append_dev(div4, a2);
    			append_dev(a2, img2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SuccessMessage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SuccessMessage> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class SuccessMessage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SuccessMessage",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.48.0 */
    const file = "src\\App.svelte";

    // (39:44) 
    function create_if_block_7(ctx) {
    	let successmessage;
    	let current;
    	successmessage = new SuccessMessage({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(successmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(successmessage, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(successmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(successmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(successmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(39:44) ",
    		ctx
    	});

    	return block;
    }

    // (22:3) {#if $successMessageState === false}
    function create_if_block_1(ctx) {
    	let div1;
    	let headsteps;
    	let t;
    	let div0;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	headsteps = new HeadSteps({ $$inline: true });

    	const if_block_creators = [
    		create_if_block_2,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5,
    		create_if_block_6
    	];

    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*stepCountValue*/ ctx[0] === 1) return 0;
    		if (/*stepCountValue*/ ctx[0] === 2) return 1;
    		if (/*stepCountValue*/ ctx[0] === 3) return 2;
    		if (/*stepCountValue*/ ctx[0] === 4) return 3;
    		if (/*stepCountValue*/ ctx[0] === 5) return 4;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(headsteps.$$.fragment);
    			t = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "step__content svelte-1rcbca3");
    			add_location(div0, file, 24, 6, 985);
    			attr_dev(div1, "class", "wrapper");
    			add_location(div1, file, 22, 6, 935);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(headsteps, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headsteps.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headsteps.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(headsteps);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(22:3) {#if $successMessageState === false}",
    		ctx
    	});

    	return block;
    }

    // (34:39) 
    function create_if_block_6(ctx) {
    	let billing;
    	let current;
    	billing = new Billing({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(billing.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(billing, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(billing.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(billing.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(billing, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(34:39) ",
    		ctx
    	});

    	return block;
    }

    // (32:39) 
    function create_if_block_5(ctx) {
    	let information;
    	let current;
    	information = new Information({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(information.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(information, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(information.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(information.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(information, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(32:39) ",
    		ctx
    	});

    	return block;
    }

    // (30:39) 
    function create_if_block_4(ctx) {
    	let legal;
    	let current;
    	legal = new Legal({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(legal.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(legal, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(legal.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(legal.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(legal, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(30:39) ",
    		ctx
    	});

    	return block;
    }

    // (28:39) 
    function create_if_block_3(ctx) {
    	let plan;
    	let current;
    	plan = new Plan({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(plan.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(plan, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(plan.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(plan.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(plan, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(28:39) ",
    		ctx
    	});

    	return block;
    }

    // (26:8) {#if stepCountValue === 1}
    function create_if_block_2(ctx) {
    	let contribution;
    	let current;
    	contribution = new Contribution({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(contribution.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contribution, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contribution.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contribution.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contribution, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(26:8) {#if stepCountValue === 1}",
    		ctx
    	});

    	return block;
    }

    // (47:0) {#if $confirmPopUpState === true}
    function create_if_block(ctx) {
    	let finalreview;
    	let current;
    	finalreview = new FinalReview({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(finalreview.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(finalreview, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(finalreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(finalreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(finalreview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(47:0) {#if $confirmPopUpState === true}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let main;
    	let div;
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let if_block1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_if_block_7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$successMessageState*/ ctx[1] === false) return 0;
    		if (/*$successMessageState*/ ctx[1] === true) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block1 = /*$confirmPopUpState*/ ctx[2] === true && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			main = element("main");
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(div, "class", "container__form svelte-1rcbca3");
    			add_location(div, file, 20, 2, 857);
    			attr_dev(main, "class", "svelte-1rcbca3");
    			add_location(main, file, 19, 0, 847);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(div, null);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (/*$confirmPopUpState*/ ctx[2] === true) {
    				if (if_block1) {
    					if (dirty & /*$confirmPopUpState*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $successMessageState;
    	let $confirmPopUpState;
    	validate_store(successMessageState, 'successMessageState');
    	component_subscribe($$self, successMessageState, $$value => $$invalidate(1, $successMessageState = $$value));
    	validate_store(confirmPopUpState, 'confirmPopUpState');
    	component_subscribe($$self, confirmPopUpState, $$value => $$invalidate(2, $confirmPopUpState = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let stepCountValue;

    	const unsubscribe = stepCounter.subscribe(value => {
    		$$invalidate(0, stepCountValue = value);
    	});

    	onDestroy(unsubscribe);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Contribution,
    		onDestroy,
    		HeadSteps,
    		Plan,
    		FinalReview,
    		stepCounter,
    		successMessageState,
    		Legal,
    		Information,
    		Billing,
    		confirmPopUpState,
    		SuccessMessage,
    		stepCountValue,
    		unsubscribe,
    		$successMessageState,
    		$confirmPopUpState
    	});

    	$$self.$inject_state = $$props => {
    		if ('stepCountValue' in $$props) $$invalidate(0, stepCountValue = $$props.stepCountValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [stepCountValue, $successMessageState, $confirmPopUpState];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,

    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
